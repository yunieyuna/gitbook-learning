# 7. Operators And Functions

## Chapter 7. Operators and Functions

_Operators_ and _functions_ are used to perform calculations, comparisons, and transformations within a SQL statement. This chapter provides code examples for commonly used operators and functions.

The following query highlights five operators (`+`, `=`, `OR`, `BETWEEN`, `AND`) and two functions (`UPPER`, `YEAR`):

<pre><code>-- Pay increases for employees
<strong>SELECT name, pay_rate + 5 AS new_pay_rate
</strong>FROM employees
<strong>WHERE UPPER(title) = 'ANALYST'
</strong><strong>      OR YEAR(start_date) BETWEEN 2016 AND 2018;
</strong></code></pre>

**OPERATORS VERSUS FUNCTIONS**

_Operators_ are symbols or keywords that perform a calculation or comparison. Operators can be found within the `SELECT`, `ON`, `WHERE`, and `HAVING` clauses of a query.

_Functions_ take in zero or more inputs, apply a calculation or transformation, and output a value. Functions can be found within the `SELECT`, `WHERE` and `HAVING` clauses of a query.

In addition to `SELECT` statements, operators and functions can also be used in `INSERT`, `UPDATE`, and `DELETE` statements.

This chapter includes one section on Operators and five sections on functions: [Aggregate Functions](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#aggregate\_functions), [Numeric Functions](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#numeric\_functions), [String Functions](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#string\_functions), [Date Time Functions](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#datetime\_functions), and [Null Functions](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#null\_functions).

[Table 7-1](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#common\_operators) lists common operators and [Table 7-2](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#common\_functions) lists common functions.

| Logical Operators                                                    | Comparison Operators (Symbols)                                                                                                                                    | Comparison Operators (Keywords)                                                                                                | Math Operators                                                                                            |
| -------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------- |
| <p><code>AND</code></p><p><code>OR</code></p><p><code>NOT</code></p> | <p><code>=</code></p><p><code>!=,</code> <code>&#x3C;></code></p><p><code>&#x3C;</code></p><p><code>&#x3C;=</code></p><p><code>></code></p><p><code>v=</code></p> | <p><code>BETWEEN</code></p><p><code>EXISTS</code></p><p><code>IN</code></p><p><code>IS NULL</code></p><p><code>LIKE</code></p> | <p><code>+</code></p><p><code>-</code></p><p><code>*</code></p><p><code>/</code></p><p><code>%</code></p> |

| Aggregate Functions                                                                                                             | Numeric Functions                                                                                                                 | String Functions                                                                                                                           | Datetime Functions                                                                                                                                         | Null Functions |
| ------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- |
| <p><code>COUNT()</code></p><p><code>SUM()</code></p><p><code>AVG()</code></p><p><code>MIN()</code></p><p><code>MAX()</code></p> | <p><code>ABS()</code></p><p><code>SQRT()</code></p><p><code>LOG()</code></p><p><code>ROUND()</code></p><p><code>CAST()</code></p> | <p><code>LENGTH()</code></p><p><code>TRIM()</code></p><p><code>CONCAT()</code></p><p><code>SUBSTR()</code></p><p><code>REGEXP()</code></p> | <p><code>CURRENT_ DATE</code></p><p><code>CURRENT_ TIME</code></p><p><code>DATEDIFF()</code></p><p><code>EXTRACT()</code></p><p><code>CONVERT()</code></p> | `COALESCE()`   |

## Operators

Operators can be symbols or keywords. They can perform calculations (`+`) or comparisons (`BETWEEN`). This section describes the available operators in SQL.

### Logical Operators

Logical operators are used to modify conditions, which result in `TRUE`, `FALSE`, or `NULL`. The logical operators in the code block (`NOT`, `AND`, `OR`) are bolded:

<pre><code>SELECT *
FROM employees
<strong>WHERE start_date IS NOT NULL
</strong><strong>      AND (title = 'analyst' OR pay_rate &#x3C; 25);
</strong></code></pre>

**TIP**

When using `AND` and `OR` to combine multiple conditional statements, it’s a good idea to clearly state the order of operations with parentheses: `()`.

[Table 7-3](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#logical\_operators\_table) lists the logical operators in SQL.

| Operator | Description                                                                                                   |
| -------- | ------------------------------------------------------------------------------------------------------------- |
| AND      | Returns `TRUE` if both conditions are `TRUE`. Returns `FALSE` if either is `FALSE`. Returns `NULL` otherwise. |
| OR       | Returns `TRUE` if either condition is `TRUE`. Returns `FALSE` if both are `FALSE`. Returns `NULL` otherwise.  |
| NOT      | Returns `TRUE` if the condition is `FALSE`. Returns `FALSE` if it is `TRUE`. Returns `NULL` otherwise.        |

Imagine there is a column called `name`. [Table 7-4](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#not\_example) shows how values in the column would be evaluated in a conditional statement without a `NOT` and with a `NOT`.

| `name`  | `name IN ('Henry', 'Harper')` | `name NOT IN ('Henry', 'Harper')` |
| ------- | ----------------------------- | --------------------------------- |
| `Henry` | TRUE                          | FALSE                             |
| `Lily`  | FALSE                         | TRUE                              |
| `NULL`  | NULL                          | NULL                              |

Imagine there are two columns called `name` and `age`. [Table 7-5](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#and\_and\_or\_example) shows how values in the columns would be evaluated in a conditional statement with an `AND` and with an `OR`.

| `name`  | `age`  | `name = 'Henry'` | `age > 3` | `name = 'Henry' AND age > 3` | `name = 'Henry' OR age > 3` |
| ------- | ------ | ---------------- | --------- | ---------------------------- | --------------------------- |
| `Henry` | 5      | TRUE             | TRUE      | TRUE                         | TRUE                        |
| `Henry` | 1      | TRUE             | FALSE     | FALSE                        | TRUE                        |
| `Lily`  | 2      | FALSE            | FALSE     | FALSE                        | FALSE                       |
| `Henry` | `NULL` | TRUE             | NULL      | NULL                         | TRUE                        |
| `Lily`  | `NULL` | FALSE            | NULL      | FALSE                        | NULL                        |

### Comparison Operators

Comparison operators are used in predicates.

**OPERATORS VERSUS PREDICATES**

_Predicates_ are comparisons that include an _operator_:

* The predicate `age = 35` includes the `=` operator.
* The predicate `COUNT(id) < 20` includes the `<` operator.

Predicates are also known as conditional statements. These comparisons are evaluated on each row in a table, and result in a value of `TRUE`, `FALSE`, or `NULL`.

The comparison operators in the code block (`IS NULL`, `=`, `BETWEEN`) are bolded:

<pre><code>SELECT *
FROM employees
<strong>WHERE start_date IS NOT NULL
</strong><strong>      AND (title = 'analyst'
</strong><strong>      OR pay_rate BETWEEN 15 AND 25);
</strong></code></pre>

[Table 7-6](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#comparison\_operators\_symbols\_table) lists comparison operators that are symbols and [Table 7-7](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#comparison\_operators\_keywords) lists comparison operators that are keywords.

| Operator | Description                        |
| -------- | ---------------------------------- |
| `=`      | Tests for equality                 |
| `!=, <>` | Tests for inequality               |
| `<`      | Tests for less than                |
| `<=`     | Tests for less than or equal to    |
| `>`      | Tests for greater than             |
| `>=`     | Tests for greater than or equal to |

**NOTE**

_MySQL_ also allows for `<=>`, which is a null-safe test for equality.

When using `=`, if two values are compared and one of them is `NULL`, the resulting value is `NULL`.

When using `<=>`, if two values are compared and one of them is `NULL`, the resulting value is `0`. If they are both `NULL`, the resulting value is `1`.

| Operator  | Description                                            |
| --------- | ------------------------------------------------------ |
| `BETWEEN` | Tests whether a value lies within a given range        |
| `EXISTS`  | Tests whether rows exist in a subquery                 |
| `IN`      | Tests whether a value is contained in a list of values |
| `IS NULL` | Tests whether a value is null or not                   |
| `LIKE`    | Tests whether a value matches a simple pattern         |

**NOTE**

The `LIKE` operator is used to match simple patterns, like finding text that starts with the letter `A`. More details can be found in the [`LIKE`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#like) section.

Regular expressions are used to match more complex patterns, like extracting any text located between two punctuation marks. More details can be found in the [regular expressions](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#use\_regular\_expressions) section.

Each keyword comparison operator is explained in detail in the following sections.

#### BETWEEN

Use `BETWEEN` to test if a value falls within a range. `BETWEEN` is a combination of `>=` and `<=`. The smaller of the two values should always be written first, with the `AND` operator separating the two.

To find all rows where the ages are greater than or equal to 35 and less than or equal to 44:

<pre><code>SELECT *
FROM my_table
<strong>WHERE age BETWEEN 35 AND 44;
</strong></code></pre>

To find all rows where the ages are less than 35 or greater than 44:

<pre><code>SELECT *
FROM my_table
<strong>WHERE age NOT BETWEEN 35 AND 44;
</strong></code></pre>

#### EXISTS

Use `EXISTS` to test if a subquery returns results or not. Typically, the subquery references another table.

The following query returns employees who also happen to be customers:

<pre><code>SELECT e.id, e.name
FROM employees e
<strong>WHERE EXISTS (SELECT *
</strong>              FROM customers c
              WHERE c.email = e.email);
</code></pre>

**EXISTS VERSUS JOIN**

The `EXISTS` query could also be written with a `JOIN`:

```
SELECT *
FROM employees e INNER JOIN customers c
     ON e.email = c.email;
```

A `JOIN` is preferred when you want values from both tables to be returned (`SELECT *`).

An `EXISTS` is preferred when you want values from a single table to be returned (`SELECT e.id, e.name`). This type of query is sometimes referred to as a _semi-join_. `EXISTS` is also useful when the second table has duplicate rows and you’re only interested in whether a row exists or not.

The following query returns customers who have never made a purchase:

<pre><code>SELECT c.id, c.name
FROM customers c
<strong>WHERE NOT EXISTS (SELECT *
</strong>                  FROM orders o
                  WHERE o.email = c.email);
</code></pre>

#### IN

Use `IN` to test whether a value falls within a list of values.

The following query returns values for a few employees:

<pre><code>SELECT *
FROM employees
<strong>WHERE e.id IN (10001, 10032, 10057);
</strong></code></pre>

The following query returns employees who have not taken a vacation day:

<pre><code>SELECT e.id
FROM employees e
<strong>WHERE e.id NOT IN (SELECT v.emp_id
</strong>                   FROM vacations v);
</code></pre>

**WARNING**

When using `NOT IN`, if there is even a single `NULL` value in the column in the subquery (`v.emp_id` in this case), the subquery will never be `TRUE`, meaning no rows will be returned.

If there are potentially `NULL` values in the column in the subquery, it is better to use `NOT EXISTS`:

<pre><code>SELECT e.id
FROM employees e
<strong>WHERE NOT EXISTS (SELECT *
</strong>                  FROM vacations v
                  WHERE v.emp_id = e.id);
</code></pre>

#### IS NULL

Use `IS NULL` or `IS NOT NULL` to test whether a value is null or not.

The following query returns employees who don’t have a manager:

<pre><code>SELECT *
FROM employees
<strong>WHERE manager IS NULL;
</strong></code></pre>

The following query returns employees who have a manager:

<pre><code>SELECT *
FROM employees
<strong>WHERE manager IS NOT NULL;
</strong></code></pre>

#### LIKE

Use `LIKE` to match a simple pattern. The percent sign (`%`) is a wildcard that means one or more characters.

Here is a sample table:

```
SELECT * FROM my_table;

+------+--------------------+
| id   | txt                |
+------+--------------------+
|    1 | You are great.     |
|    2 | Thank you!         |
|    3 | Thinking of you.   |
|    4 | I'm 100% positive. |
+------+--------------------+
```

Find all rows that _contain_ the term `you`:

<pre><code>SELECT *
FROM my_table
<strong>WHERE txt LIKE '%you%';
</strong>


-- MySQL, SQL Server and SQLite results
+------+------------------+
| id   | txt              |
+------+------------------+
|    1 | You are great.   |
|    2 | Thank you!       |
|    3 | Thinking of you. |
+------+------------------+

-- Oracle and PostgreSQL results
+------+------------------+
| id   | txt              |
+------+------------------+
|    2 | Thank you!       |
|    3 | Thinking of you. |
+------+------------------+
</code></pre>

In _MySQL_, _SQL Server_, and _SQLite_, the pattern is case insensitive. Both `You` and `you` are captured by `'%you%'`.

In _Oracle_ and _PostgreSQL_, the pattern is case sensitive. Only `you` is captured by `'%you%'`.

Find all rows that _start with_ the term `You`:

<pre><code>SELECT *
FROM my_table
<strong>WHERE txt LIKE 'You%';
</strong>
+------+----------------+
| id   | txt            |
+------+----------------+
|    1 | You are great. |
+------+----------------+
</code></pre>

Use `NOT LIKE` to return rows that don’t contain the characters.

Instead of the percent sign (`%`) to match one or more characters, you can use the underscore ( `_` ) to match exactly one character.

**WARNING**

Because `%` and `_` have special meaning when used with `LIKE`, if you want to search for those actual characters, you’ll need to add the `ESCAPE` keyword.

The following code finds all rows that contain the `%` symbol:

<pre><code>SELECT *
FROM my_table
<strong>WHERE txt LIKE '%!%%' ESCAPE '!';
</strong>
+------+--------------------+
| id   | txt                |
+------+--------------------+
|    4 | I'm 100% positive. |
+------+--------------------+
</code></pre>

After the `ESCAPE` keyword, we’ve declared `!` as the escape character, so when the `!` is put in front of the middle `%` in `%!%%`, `!%` is interpreted as `%`.

`LIKE` is useful when searching for a particular string of characters. For more advanced pattern searches, you can use regular expressions, which are covered in the [regular expressions](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#use\_regular\_expressions) section later in this chapter.

### Math Operators

Math operators are math symbols that can be used in SQL. The math operator in the code block (`/`) is bolded:

<pre><code><strong>SELECT salary / 52 AS weekly_pay
</strong>FROM my_table;
</code></pre>

[Table 7-8](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#math\_operators\_table) lists the math operators in SQL.

| Operator                                                          | Description        |
| ----------------------------------------------------------------- | ------------------ |
| `+`                                                               | Addition           |
| `-`                                                               | Subtraction        |
| `*`                                                               | Multiplication     |
| `/`                                                               | Division           |
| <p><code>%</code></p><p>(<code>MOD</code> in <em>Oracle</em>)</p> | Modulo (remainder) |

**NOTE**

In _PostgreSQL_, _SQL Server_, and _SQLite_, dividing an integer by an integer results in an integer:

```
SELECT 15/2;
7
```

If you want the result to include decimals, you can either divide by a decimal or use the [`CAST`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#convert\_data\_to\_a\_numeric\_data\_type) function:

<pre><code><strong>SELECT 15/2.0;
</strong>7.5
</code></pre>

<pre><code> –– PostgreSQL and SQL Server
<strong>SELECT CAST(15 AS DECIMAL) /
</strong><strong>       CAST(2 AS DECIMAL);
</strong>       7.5
</code></pre>

<pre><code>-- SQLite
<strong>SELECT CAST(15 AS REAL) /
</strong><strong>       CAST(2 AS REAL);
</strong>7.5
</code></pre>

Other math operators include:

* _Bitwise operators_ such as `&` (AND), `|` (OR), and `^` (XOR) for working with bits (0 and 1 values).
* _Assignment operators_ such as `+=` (add equals) and `-=` (subtract equals) for updating values in a table.

## Aggregate Functions

An _aggregate function_ performs a calculation on many rows of data and results in a single value. [Table 7-9](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#basic\_aggregate\_functions) lists the five basic aggregate functions in SQL.

| Function  | Description                        |
| --------- | ---------------------------------- |
| `COUNT()` | Counts the number of values        |
| `SUM()`   | Calculates the sum of a column     |
| `AVG()`   | Calculates the average of a column |
| `MIN()`   | Finds the minimum of a column      |
| `MAX()`   | Finds the maximum of a column      |

Aggregate functions apply calculations to non-null values in a column. The only exception is `COUNT(*)`, which counts _all_ rows, including null values.

You can also aggregate multiple rows into a single list using functions like `ARRAY_AGG`, `GROUP_CONCAT`, `LISTAGG`, and `STRING_AGG`. More details can be found in the [Aggregate rows into a single value or list](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#aggregate\_rows\_into\_a\_single\_value\_or\_list) section in [Chapter 8](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#advanced\_querying\_concepts).

**NOTE**

_Oracle_ supports additional aggregate functions like median (`MEDIAN`), mode (`STATS_MODE`), and standard deviation (`STDDEV`).

Aggregate functions (bolded in the example) are located in the `SELECT` and `HAVING` clauses of a query:

<pre><code><strong>SELECT COUNT(*) AS total_rows,
</strong><strong>       AVG(age) AS average_age
</strong>FROM my_table;

<strong>SELECT region, MIN(age), MAX(age)
</strong>FROM my_table
GROUP BY region
<strong>HAVING MIN(age) &#x3C; 18;
</strong></code></pre>

**WARNING**

If you choose to have both aggregate and nonaggregate columns in the `SELECT` statement, you _must_ include all nonaggregate columns in the [`GROUP BY`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch04.html#the\_group\_by\_clause) clause (`region` in the preceding example).

Some RDBMSs will throw an error if you do not do this. Other RDBMSs (such as _SQLite_), will not throw an error and allow the statement to run, even though the results returned will be _inaccurate_. It is good practice to double-check your results to make sure they make sense.

**MIN/MAX VERSUS LEAST/GREATEST**

The `MIN` and `MAX` functions find the smallest and largest values within a column.

The `LEAST` and `GREATEST` functions find the smallest and largest values within a row. Inputs can be numeric, string, or datetime values. If one value is `NULL`, the function returns `NULL`.

The following table shows the total miles run each quarter, and the query finds the miles run in the best quarter:

<pre><code>SELECT * FROM goat;

+--------+------+------+------+------+
| name   | q1   | q2   | q3   | q4   |
+--------+------+------+------+------+
| Ali    |  100 |  200 |  150 | NULL |
| Bolt   |  350 |  400 |  380 |  300 |
| Jordan |  200 |  250 |  300 |  320 |
+--------+------+------+------+------+

<strong>SELECT name, GREATEST(q1, q2, q3, q4)
</strong>             AS most_miles
FROM goat;

+--------+------------+
| name   | most_miles |
+--------+------------+
| Ali    |       NULL |
| Bolt   |        400 |
| Jordan |        320 |
+--------+------------+
</code></pre>

## Numeric Functions

Numeric functions can be applied to columns with [numeric data types](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch06.html#numeric\_data). This section covers common numeric functions in SQL.

### Apply Math Functions

There are multiple types of math calculations in SQL:

[Math Operators](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#math\_operators)

Calculations using symbols such as `+`, `-`, `*`, `/`, and `%`

[Aggregate Functions](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#aggregate\_functions)

Calculations that summarize an entire column of data into a single value such as `COUNT`, `SUM`, `AVG`, `MIN`, and `MAX`

[Math Functions](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#math\_functions\_table)

Calculations using keywords that apply to each row of data such as `SQRT`, `LOG`, and more that are listed in [Table 7-10](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#math\_functions\_table)

**NOTE**

_SQLite_ only supports the `ABS` function. Other math functions need to be manually enabled. More details can be found on the math functions page on the [SQLite website](https://oreil.ly/0XwjB).

| Category                                                                     | Function                                                                    | Description                                                                             | Code                                                                  | Result |
| ---------------------------------------------------------------------------- | --------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- | --------------------------------------------------------------------- | ------ |
| Positive and Negative Values                                                 | `ABS`                                                                       | Absolute value                                                                          | `SELECT ABS(-5);`                                                     | 5      |
| `SIGN`                                                                       | Returns –1, 0, or 1 depending on if a number is negative, zero, or positive | `SELECT SIGN(-5);`                                                                      | –1                                                                    |        |
| Exponents and Logarithms                                                     | `POWER`                                                                     | _x_ raised to the power of _y_                                                          | `SELECT POWER(5,2);`                                                  | 25     |
| `SQRT`                                                                       | Square root                                                                 | `SELECT SQRT(25);`                                                                      | 5                                                                     |        |
| `EXP`                                                                        | _e_ (=2.71828) raised to the power of _x_                                   | `SELECT EXP(2);`                                                                        | 7.389                                                                 |        |
| <p><code>LOG</code></p><p>(<code>LOG(y,x)</code> in <em>SQL Server</em>)</p> | Log of _y_ base _x_                                                         | <p><code>SELECT LOG(2,10);</code></p><p><code>SELECT LOG(10,2);</code></p>              | 3.322                                                                 |        |
| <p><code>LN</code></p><p>(<code>LOG</code> in <em>SQL Server</em>)</p>       | Natural log (base _e_)                                                      | <p><code>SELECT LN(10);</code></p><p><code>SELECT LOG(10);</code></p>                   | 2.303                                                                 |        |
| <p><code>LOG10</code></p><p>(<code>LOG(10,x)</code> in <em>Oracle</em>)</p>  | Log base 10                                                                 | <p><code>SELECT LOG10(100);</code></p><p><code>SELECT LOG(10,100) FROM dual;</code></p> | 2                                                                     |        |
| Other                                                                        | <p><code>MOD</code></p><p>(<code>x%y</code> in <em>SQL Server</em>)</p>     | Remainder of _x_ / _y_                                                                  | <p><code>SELECT MOD(12,5);</code></p><p><code>SELECT 12%5;</code></p> | 2      |
| <p><code>PI</code></p><p>(not available in <em>Oracle</em>)</p>              | Value of pi                                                                 | `SELECT PI();`                                                                          | 3.14159                                                               |        |
| `COS`, `SIN`, etc.                                                           | Cosine, sine, and other trig functions (input is in radians)                | `SELECT COS(.78);`                                                                      | 0.711                                                                 |        |

### Generate Random Numbers

[Table 7-11](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#random\_number\_generator) shows how to generate a random number in each RDBMS. In some cases, you can input a _seed_ so that the random number generated is the same each time.

| RDBMS                                  | Code                                  | Range of Results |
| -------------------------------------- | ------------------------------------- | ---------------- |
| <p>MySQL,</p><p>SQL Server</p>         | `SELECT RAND();`                      | 0 to 1           |
| `-- Optional seed SELECT RAND(22);`    |                                       |                  |
| Oracle                                 | `SELECT DBMS_RANDOM.VALUE FROM dual;` | 0 to 1           |
| `SELECT DBMS_RANDOM.RANDOM FROM dual;` | –2E31 to +2E31                        |                  |
| PostgreSQL                             | `SELECT RANDOM();`                    | 0 to 1           |
| SQLite                                 | `SELECT RANDOM();`                    | –9E18 to +9E18   |

The random number function is sometimes used to return a few random rows of a table. While not the most efficient query (since the table has to be sorted), it is a quick hack:

<pre><code>-- Return 5 random rows
SELECT *
FROM my_table
<strong>ORDER BY RANDOM()
</strong>LIMIT 5;
</code></pre>

_Oracle_ and _SQL Server_ allow you to randomly sample a table:

<pre><code>-- Return random 20% of rows in Oracle
SELECT *
FROM my_table
<strong>SAMPLE(20);
</strong>
-- Return random 100 rows in SQL Server
SELECT *
FROM my_table
<strong>TABLESAMPLE(100 ROWS);
</strong></code></pre>

### Round and Truncate Numbers

[Table 7-12](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#rounding\_options) shows the various ways to round numbers in each RDBMS.

| Function                                                                                                                          | Description                                                                   | Code                                                                                                                                      | Output |
| --------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- | ------ |
| <p><code>CEIL</code></p><p>(<code>CEILING</code> in <em>SQL Server</em>)</p>                                                      | Rounds up to the nearest integer                                              | <p><code>SELECT CEIL(98.7654);</code></p><p><code>SELECT CEILING(98.7654);</code></p>                                                     | 99     |
| `FLOOR`                                                                                                                           | Rounds down to the nearest integer                                            | `SELECT FLOOR(98.7654);`                                                                                                                  | 98     |
| `ROUND`                                                                                                                           | Rounds to a specific number of decimal places, defaults to 0 decimals         | `SELECT ROUND(98.7654,2);`                                                                                                                | 98.77  |
| <p><code>TRUNC</code></p><p>(<code>TRUNCATE</code> in <em>MySQL</em>;</p><p><code>ROUND(x,y,1)</code> in <em>SQL Server</em>)</p> | Cuts off number at a specific number of decimal places, default to 0 decimals | <p><code>SELECT TRUNC(98.7654,2);</code></p><p><code>SELECT TRUNCATE(98.7654,2);</code></p><p><code>SELECT ROUND(98.7654,2,1);</code></p> | 98.76  |

**NOTE**

_SQLite_ only supports the `ROUND` function. Other rounding options need to be manually enabled. More details can be found on the math functions page on the [SQLite website](https://oreil.ly/rF2Rt).

### Convert Data to a Numeric Data Type

The `CAST` function is used to convert between various data types, and is often used for numeric data.

In the following example, we want to compare a string column with a numeric column

Here is a table with a string column:

```
+------+---------+
| id   | str_col |
+------+---------+
|    1 | 1.33    |
|    2 | 5.5     |
|    3 | 7.8     |
+------+---------+
```

Try to compare the string column with numeric value:

```
SELECT *
FROM my_table
WHERE str_col > 3;

-- MySQL, Oracle, and SQLite results
+------+---------+
| id   | str_col |
+------+---------+
|    2 | 5.5     |
|    3 | 7.8     |
+------+---------+

-- PostgreSQL and SQL Server results
Error
```

**NOTE**

In _MySQL_, _Oracle_, and _SQLite_, the query returns the correct results because the string column is recognized as a numeric column when the `>` operator is introduced.

In _PostgreSQL_ and _SQL Server_, you must explicitly `CAST` the string column into a numeric column.

Cast the string column to a decimal column to compare it with a number:

<pre><code>SELECT *
FROM my_table
<strong>WHERE CAST(str_col AS DECIMAL) > 3;
</strong>
 id | str_col
----+---------
  2 | 5.5
  3 | 7.8
</code></pre>

**NOTE**

Using `CAST` does not permanently change the data type of the column; it is only for the duration of the query. To permanently change the data type of a column, you can [alter the table](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#modify\_a\_constraint).

## String Functions

String functions can be applied to columns with [string data types](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch06.html#string\_data). This section covers common string operations in SQL.

### Find the Length of a String

Use the `LENGTH` function.

In the `SELECT` clause:

<pre><code><strong>SELECT LENGTH(name)
</strong>FROM my_table;
</code></pre>

In the `WHERE` clause:

<pre><code>SELECT *
FROM my_table
<strong>WHERE LENGTH(name) &#x3C; 10;
</strong></code></pre>

In _SQL Server_, use `LEN` instead of `LENGTH`.

**NOTE**

Most RDBMSs exclude trailing spaces when calculating the length of a string, while _Oracle_ includes them.

Example string: `'Al   '`

Length: 2

Length in Oracle: 5

To exclude trailing spaces in Oracle, use the [`TRIM`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#trim\_unwanted\_characters\_around\_a\_string) function:

```
SELECT LENGTH(TRIM(name))
FROM my_table;
```

### Change the Case of a String

Use the `UPPER` or `LOWER` function.

`UPPER`:

<pre><code><strong>SELECT UPPER(type)
</strong>FROM my_table;
</code></pre>

`LOWER`:

<pre><code>SELECT *
FROM my_table
<strong>WHERE LOWER(type) = 'public';
</strong></code></pre>

_Oracle_ and _PostgreSQL_ also have `INITCAP(`_`string`_`)` to uppercase the first letter of each word in a string and lowercase the other letters.

### Trim Unwanted Characters Around a String

Use the `TRIM` function to remove both leading and trailing characters around a string value. The following table has several characters that we’d like to remove:

```
SELECT * FROM my_table;

+----------------+
| color          |
+----------------+
| !!red          |
|  .orange!      |
|    ..yellow..  |
+----------------+
```

#### Remove spaces around a string

By default, `TRIM` removes spaces from both the left and right sides of a string:

<pre><code><strong>SELECT TRIM(color) AS color_clean
</strong>FROM my_table;

+-------------+
| color_clean |
+-------------+
| !!red       |
| .orange!    |
| ..yellow..  |
+-------------+
</code></pre>

#### Remove other characters around a string

You can specify other characters to remove besides a single space. The following code removes exclamation marks around a string:

<pre><code><strong>SELECT TRIM('!' FROM color) AS color_clean
</strong>FROM my_table;

+-----------------+
| color_clean     |
+-----------------+
| red             |
|  .orange        |
|    ..yellow..   |
+-----------------+
</code></pre>

In _SQLite_, use `TRIM(color, '!')` instead.

#### Remove characters from the left or right side of a string

There are two options for removing characters on either side of a string.

Option 1: `TRIM(LEADING .. )` and `TRIM(TRAILING .. )`

In _MySQL_, _Oracle_ and _PostgreSQL_, you can remove characters from either the left or right side of a string with `TRIM(LEADING ..)` and `TRIM(TRAILING ..)`, respectively. The following code removes exclamation marks from the beginning of a string:

<pre><code><strong>SELECT TRIM(LEADING '!' FROM color) AS color_clean
</strong>FROM my_table;

+----------------+
| color_clean    |
+----------------+
| red            |
|  .orange!      |
|    ..yellow..  |
+----------------+
</code></pre>

Option 2: `LTRIM` and `RTRIM`

Use the keywords `LTRIM` and `RTRIM` to remove characters from either the left or right side of a string, respectively.

In _Oracle_, _PostgreSQL_, and _SQLite_, all unwanted characters can be listed within a single string. The following code removes periods, exclamation marks, and spaces from the beginning of a string:

<pre><code><strong>SELECT LTRIM(color, '.! ') AS color_clean
</strong>FROM my_table;

+-------------+
| color_clean |
+-------------+
| red         |
| orange!     |
| yellow..    |
+-------------+
</code></pre>

In _MySQL_ and _SQL Server_, only whitespace characters can be removed using `LTRIM(color)` or `RTRIM(color)`.

### Concatenate Strings

Use the `CONCAT` function or the concatenation operator (`||`).

<pre><code>-- MySQL, PostgreSQL, and SQL Server
<strong>SELECT CONCAT(id, '_', name) AS id_name
</strong>FROM my_table;

-- Oracle, PostgreSQL, and SQLite
<strong>SELECT id || '_' || name AS id_name
</strong>FROM my_table;

+-----------+
| id_name   |
+-----------+
| 1_Boots   |
| 2_Pumpkin |
| 3_Tiger   |
+-----------+
</code></pre>

### Search for Text in a String

There are two approaches to search for text in a string.

Approach 1: Does the text appear in the string or not?

Use the `LIKE` operator to determine whether text appears in a string or not. With the following query, only rows that contain the text `some` will be returned:

<pre><code>SELECT *
FROM my_table
<strong>WHERE my_text LIKE '%some%';
</strong></code></pre>

More details can be found in the [`LIKE`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#like) section earlier in this chapter.

Approach 2: Where does the text appear in the string?

Use the `INSTR`/`POSITION`/`CHARINDEX` function to determine the location of text in a string.

[Table 7-13](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#functions\_to\_find\_the\_location\_of\_text\_in\_a\_string) lists the parameters required by the location functions in each RDBMS.

| RDBMS      | Code Format                                                                                                                                                                                                                                                                        |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| MySQL      | <p><code>INSTR(</code><em><code>string</code></em><code>, </code><em><code>substring</code></em><code>)</code></p><p><code>LOCATE(</code><em><code>substring</code></em><code>, </code><em><code>string</code></em><code>, </code><em><code>position</code></em><code>)</code></p> |
| Oracle     | `INSTR(`_`string`_`,`` `_`substring`_`,`` `_`position`_`,`` `_`occurrence`_`)`                                                                                                                                                                                                     |
| PostgreSQL | <p><code>POSITION(</code><em><code>substring</code></em><code> IN </code><em><code>string</code></em><code>)</code></p><p><code>STRPOS(</code><em><code>string</code></em><code>, </code><em><code>substring</code></em><code>)</code></p>                                         |
| SQL Server | `CHARINDEX(`_`substring`_`,`` `_`string`_`,`` `_`position`_`)`                                                                                                                                                                                                                     |
| SQLite     | `INSTR(`_`string`_`,`` `_`substring`_`)`                                                                                                                                                                                                                                           |

The inputs are:

* _string_ (_required_): the string you are searching in (i.e., the name of a `VARCHAR` column)
* _substring_ (_required_): the string you are searching for (i.e., a character, a word, etc.)
* _position_ (_optional_): the starting position for the search. The default is to start at the first character (1). If _position_ is negative, the search begins at the end of the string.
* _occurrence_ (_optional_): the first/second/third, etc. time the substring appears in the string. The default is the first occurrence (1).

Here is a sample table:

```
+------------------------------+
| my_text                      |
+------------------------------+
| Here is some text.           |
| And some numbers - 1 2 3 4 5 |
| And some punctuation! :)     |
+------------------------------+
```

Find the location of the substring `some` within the string `my_text`:

<pre><code><strong>SELECT INSTR(my_text, 'some') AS some_location
</strong>FROM my_table;

+---------------+
| some_location |
+---------------+
|             9 |
|             5 |
|             5 |
+---------------+
</code></pre>

**COUNTING IN SQL STARTS AT 1**

Unlike other programming languages that are zero-indexed (the count starts from 0), the count starts from 1 in SQL.

The 9 in the preceding output means the ninth character.

**NOTE**

In _Oracle_, regular expressions can also be used to search for a substring using `REGEXP_INSTR`. More details are in the [regular expressions in Oracle](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#regular\_expressions\_in\_oracle) section.

### Extract a Portion of a String

Use the `SUBSTR` or `SUBSTRING` function. The function name and inputs differ for each RDBMS:

```
-- MySQL, Oracle, PostgreSQL, and SQLite
SUBSTR(string, start, length)

-- MySQL
SUBSTR(string FROM start FOR length)

-- MySQL, PostgreSQL, and SQL Server
SUBSTRING(string, start, length)

-- MySQL and PostgreSQL
SUBSTRING(string FROM start FOR length)
```

The inputs are:

* _string_ (_required_): the string you are searching in (i.e., the name of a `VARCHAR` column)
* _start_ (_required_): the starting location of the search. If _start_ is set to `1`, the search will start from the first character, `2` is the second character, and so on. If _start_ is set to `0`, it will be treated like a 1. If _start_ is negative, the search will start from the last character.
* _length_ (_optional_): the length of the string returned. If _length_ is omitted, then all characters from the _start_ to the end of the string will be returned. In _SQL Server_, _length_ is required. Here is a sample table:

```
+------------------------------+
| my_text                      |
+------------------------------+
| Here is some text.           |
| And some numbers - 1 2 3 4 5 |
| And some punctuation! :)     |
+------------------------------+
```

Extract a substring:

<pre><code><strong>SELECT SUBSTR(my_text, 14, 8) AS sub_str
</strong>FROM my_table;

+----------+
| sub_str  |
+----------+
| text.    |
| ers - 1  |
| tuation! |
+----------+
</code></pre>

**NOTE**

In _Oracle_, regular expressions can also be used to extract a substring using `REGEXP_SUBSTR`. More details are in the [regular expressions in Oracle](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#regular\_expressions\_in\_oracle) section.

### Replace Text in a String

Use the `REPLACE` function. Note the order of the inputs for the function:

```
REPLACE(string, old_string, new_string)
```

Here is a sample table:

```
+------------------------------+
| my_text                      |
+------------------------------+
| Here is some text.           |
| And some numbers - 1 2 3 4 5 |
| And some punctuation! :)     |
+------------------------------+
```

Replace the word `some` with the word `the`:

<pre><code><strong>SELECT REPLACE(my_text, 'some', 'the')
</strong>       AS new_text
FROM my_table;

+-----------------------------+
| new_text                    |
+-----------------------------+
| Here is the text.           |
| And the numbers - 1 2 3 4 5 |
| And the punctuation! :)     |
+-----------------------------+
</code></pre>

**NOTE**

In _Oracle_ and _PostgreSQL_, regular expressions can also be used to replace a string using `REGEXP_REPLACE`. More details are in the [regular expressions in Oracle](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#regular\_expressions\_in\_oracle) and [regular expressions in PostgreSQL](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#regular\_expressions\_in\_postgresql) sections.

### Delete Text from a String

You can use the `REPLACE` function, but specify an empty string as the replace value.

Replace the word `some` with an empty string:

<pre><code><strong>SELECT REPLACE(my_text, 'some ', '')
</strong>       AS new_text
FROM my_table;

+-------------------------+
| new_text                |
+-------------------------+
| Here is text.           |
| And numbers - 1 2 3 4 5 |
| And punctuation! :)     |
+-------------------------+
</code></pre>

### Use Regular Expressions

_Regular expressions_ allow you to match complex patterns. For example, finding all words that have exactly five letters or finding all words that start with a capital letter.

Imagine you have the following recipe for taco seasoning:

```
- 1 tablespoon chili powder
- .5 tablespoon ground cumin
- .5 teaspoon paprika
- .25 teaspoon garlic powder
- .25 teaspoon onion powder
- .25 teaspoon crushed red pepper flakes
- .25 teaspoon dried oregano
```

You want to exclude the amounts and just have a list of ingredients. To do so, you can write a regular expression to extract all of the text that follows the term `spoon`.

The regular expression would look like:

```
(?<=spoon ).*$
```

and the results would look like:

```
chili powder
ground cumin
paprika
garlic powder
onion powder
crushed red pepper flakes
dried oregano
```

The regular expression went through all of the text and extracted any text that was sandwiched between the term `spoon` and the end of the line.

A couple things to note about regular expressions:

* Regular expression syntax is not intuitive. It is helpful to break down the meaning of each part of a regular expression using an online tool, such as [Regex101](https://regex101.com/).
* Regular expressions are not SQL-specific. They can be used within many programming languages and text editors.
* [RegexOne](https://regexone.com/) provides a quick introductory tutorial. You can also reference Thomas Nield’s O’Reilly post, [“An Introduction to Regular Expressions.”](https://oreil.ly/1jJQk)

**TIP**

Instead of memorizing regular expression syntax, I recommend finding existing regular expressions and modifying them to fit your needs.

For the previous regular expression, I searched for “regular expression text after string.”

The second Google search result got me to `(?<=WORD).*$`. I used [Regex101](https://regex101.com/) to understand each part of the regular expression, and finally replaced `WORD` with `spoon`.

Regular expression functions vary widely by RDBMS, so there is a separate section for each one. SQLite does not support regular expressions by default, but they can be implemented. More details can be found in the [SQLite documentation](https://oreil.ly/gmxS6).

#### Regular Expressions in MySQL

Use `REGEXP` to look for a regular expression pattern anywhere in a string.

Here is a sample table:

```
+----------------------------+-------------+
| title                      | city        |
+----------------------------+-------------+
| 10 Things I Hate About You | Seattle     |
| 22 Jump Street             | New Orleans |
| The Blues Brothers         | Chicago     |
| Ferris Bueller's Day Off   | Chi         |
+----------------------------+-------------+
```

Find all variant spellings of Chicago:

<pre><code>SELECT *
FROM movies
<strong>WHERE city REGEXP '(Chicago|CHI|Chitown)';
</strong>
+--------------------------+---------+
| title                    | city    |
+--------------------------+---------+
| The Blues Brothers       | Chicago |
| Ferris Bueller's Day Off | Chi     |
+--------------------------+---------+
</code></pre>

MySQL’s regular expressions are case-insensitive for character strings; `CHI` and `Chi` are seen as equivalent.

Find all movies with numbers in the title:

<pre><code>SELECT *
FROM movies
<strong>WHERE title REGEXP '\\d';
</strong>
+----------------------------+-------------+
| title                      | city        |
+----------------------------+-------------+
| 10 Things I Hate About You | Seattle     |
| 22 Jump Street             | New Orleans |
+----------------------------+-------------+
</code></pre>

In MySQL, any single backslash in a regular expression (`\d` = any digit) needs to be changed to a double backslash.

#### Regular expressions in Oracle

Oracle supports many regular expression functions including:

* `REGEXP_LIKE` matches a regular expression pattern within the text.
* `REGEXP_COUNT` counts the number of times a pattern appears in the text.
* `REGEXP_INSTR` locates the positions that a pattern appears in the text.
* `REGEXP_SUBSTR` returns the substrings in the text that match a pattern.
* `REGEXP_REPLACE` replaces substrings that match a pattern with other text.

Here is a sample table:

```
 TITLE                        CITY
---------------------------- -------------
 10 Things I Hate About You   Seattle
 22 Jump Street               New Orleans
 The Blues Brothers           Chicago
 Ferris Bueller's Day Off     Chi
```

Find all movies with numbers in the title:

<pre><code>SELECT *
FROM movies
<strong>WHERE REGEXP_LIKE(title, '\d');
</strong>
 TITLE                        CITY
---------------------------- -------------
 10 Things I Hate About You   Seattle
 22 Jump Street               New Orleans
</code></pre>

**NOTE**

The following expressions are equivalent:

<pre><code><strong>REGEXP_LIKE(title, \d)
</strong><strong>REGEXP_LIKE(title, [0-9])
</strong><strong>REGEXP_LIKE(title, [[:digit:]])
</strong></code></pre>

The third option uses [POSIX](https://oreil.ly/G3Tkw) regular expression syntax, which is supported by Oracle.

Count the number of capital letters in the title:

<pre><code><strong>SELECT title, REGEXP_COUNT(title, '[A-Z]')
</strong>       AS num_caps
FROM movies;

 TITLE                        NUM_CAPS
---------------------------- ----------
 10 Things I Hate About You          5
 22 Jump Street                      2
 The Blues Brothers                  3
 Ferris Bueller's Day Off            4
</code></pre>

Find the location of the first vowel in the title:

<pre><code><strong>SELECT title, REGEXP_INSTR(title, '[aeiou]')
</strong>       AS first_vowel
FROM movies;

 TITLE                        FIRST_VOWEL
---------------------------- -------------
 10 Things I Hate About You             6
 22 Jump Street                         5
 The Blues Brothers                     3
 Ferris Bueller's Day Off               2
</code></pre>

Return all numbers in the title:

<pre><code><strong>SELECT title, REGEXP_SUBSTR(title, '[0-9]+')
</strong>       AS nums
FROM movies
WHERE REGEXP_SUBSTR(title, '[0‐9]+') IS NOT NULL;

 TITLE                        NUMS
---------------------------- ------
 10 Things I Hate About You     10
 22 Jump Street                 22
</code></pre>

Replace all numbers in the title with the number `100`:

<pre><code><strong>SELECT REGEXP_REPLACE(title, '[0-9]+', '100')
</strong>       AS one_hundred_title
FROM movies;

 ONE_HUNDRED_TITLE
-----------------------------
 100 Things I Hate About You
 100 Jump Street
</code></pre>

**NOTE**

More details and examples on regular expressions in Oracle can be found in the [_Oracle Regular Expressions Pocket Reference_](https://oreil.ly/5As3T) by Jonathan Gennick and Peter Linsley (O’Reilly).

#### Regular expressions in Po⁠⁠⁠stgreSQL

Use `SIMILAR TO` or `~` to look for a regular expression pattern anywhere in a string.

Here is a sample table:

```
           title            |    city
----------------------------+-------------
 10 Things I Hate About You | Seattle
 22 Jump Street             | New Orleans
 The Blues Brothers         | Chicago
 Ferris Bueller's Day Off   | Chi
```

Find all variant spellings of Chicago:

<pre><code>SELECT *
FROM movies
<strong>WHERE city SIMILAR TO '(Chicago|CHI|Chi|Chitown)';
</strong>
          title           |  city
--------------------------+---------
 The Blues Brothers       | Chicago
 Ferris Bueller's Day Off | Chi
</code></pre>

PostgreSQL’s regular expressions are case-sensitive for character strings; `CHI` and `Chi` are seen as different values.

**SIMILAR TO VERSUS \~**

`SIMILAR TO` offers limited regular expression capabilities, and is most often used to offer multiple alternatives `(Chicago|CHI|Chi)`. Other common regex symbols to use with `SIMILAR TO` are `*` (0 or more), `+` (1 or more), and `{}` (exact number of times).

The tilde (`~`) should be used for more advanced regular expressions along with [POSIX](https://oreil.ly/Thzdv) syntax, which is another flavor of regular expression that PostgreSQL supports.

The full list of supported symbols can be found in the [PostgreSQL documentation](https://oreil.ly/wsB46).

The following example uses `~` instead of `SIMILAR TO`.

Find all movies with numbers in the title:

<pre><code>SELECT *
FROM movies
<strong>WHERE title ~ '\d';
</strong>
+----------------------------+-------------+
| title                      | city        |
+----------------------------+-------------+
| 10 Things I Hate About You | Seattle     |
| 22 Jump Street             | New Orleans |
+----------------------------+-------------+
</code></pre>

PostgreSQL also supports `REGEXP_REPLACE`, which allows you to replace characters in a string that match a particular pattern.

Replace all numbers in the title with the number `100`:

<pre><code><strong>SELECT REGEXP_REPLACE(title, '\d+', '100')
</strong>FROM movies;

regexp_replace
-----------------------------
100 Things I Hate About You
100 Jump Street
The Blues Brothers
Ferris Bueller's Day Off
</code></pre>

The regular expression `\d` is equivalent to `[0-9]` and `[[:digit::]]`.

#### Regular expressions in SQL Server

SQL Server supports a very limited amount of regular expressions through its `LIKE` keyword.

Here is a sample table:

```
 title                        city
---------------------------- -------------
 10 Things I Hate About You   Seattle
 22 Jump Street               New Orleans
 The Blues Brothers           Chicago
 Ferris Bueller's Day Off     Chi
```

SQL Server uses a slightly different flavor of regular expression syntax, which is detailed in the [Microsoft documentation](https://oreil.ly/QANyP).

Find all movies with numbers in the title:

<pre><code>SELECT *
FROM movies
<strong>WHERE title LIKE '%[0-9]%';
</strong></code></pre>

```
 title                        city
---------------------------- -------------
 10 Things I Hate About You   Seattle
 22 Jump Street               New Orleans
```

### Convert Data to a String Data Type

When string functions are applied to nonstring data types, it is typically not an issue even though there is a data type mismatch.

The following table has a numeric column called `numbers`:

```
+---------+
| numbers |
+---------+
| 1.33    |
| 2.5     |
| 3.777   |
+---------+
```

When the string function `LENGTH` (or `LEN` in _SQL Server_) is applied on the numeric column, the statement executes without error in most RDBMSs:

<pre><code><strong>SELECT LENGTH(numbers) AS len_num
</strong>FROM my_table;

-- MySQL, Oracle, SQL Server, and SQLite results
+---------+
| len_num |
+---------+
|       4 |
|       3 |
|       5 |
+---------+

-- PostgreSQL results
Error
</code></pre>

In _PostgreSQL_, you must explicitly `CAST` the numeric column into a string column:

<pre><code><strong>SELECT LENGTH(CAST(numbers AS CHAR(5))) AS len_num
</strong>FROM my_table;

 len_num
---------
       4
       3
       5
</code></pre>

**NOTE**

Using `CAST` does not permanently change the data type of the column—it is only for the duration of the query. To permanently change the data type of a column, you can [alter the table](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#modify\_a\_constraint).

## Datetime Functions

Datetime functions can be applied to columns with [datetime data types](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch06.html#datetime\_data). This section covers common datetime functions in SQL.

### Return the Current Date or Time

The following statements return the current date, current time, and current date and time:

<pre><code>-- MySQL, PostgreSQL, and SQLite
<strong>SELECT CURRENT_DATE;
</strong><strong>SELECT CURRENT_TIME;
</strong><strong>SELECT CURRENT_TIMESTAMP;
</strong>
-- Oracle
<strong>SELECT CURRENT_DATE FROM dual;
</strong><strong>SELECT CAST(CURRENT_TIMESTAMP AS TIME) FROM dual;
</strong><strong>SELECT CURRENT_TIMESTAMP FROM dual;
</strong>
-- SQL Server
<strong>SELECT CAST(CURRENT_TIMESTAMP AS DATE);
</strong><strong>SELECT CAST(CURRENT_TIMESTAMP AS TIME);
</strong><strong>SELECT CURRENT_TIMESTAMP;
</strong></code></pre>

There are many other functions equivalent to these including `CURDATE()` in _MySQL_, `GETDATE()` in _SQL Server_, etc.

The following three situations show how these functions are used in practice.

Display the current time:

<pre><code><strong>SELECT CURRENT_TIME;
</strong>
+--------------+
| current_time |
+--------------+
| 20:53:35     |
+--------------+
</code></pre>

Create a table that marks the date and time of creation:

<pre><code>CREATE TABLE my_table
       (id INT,
       creation_datetime TIMESTAMP DEFAULT
<strong>                         CURRENT_TIMESTAMP);
</strong>
INSERT INTO my_table (id)
       VALUES (1), (2), (3);

 +------+---------------------+
 | id   | creation_datetime   |
 +------+---------------------+
 |    1 | 2021-02-15 20:57:12 |
 |    2 | 2021-02-15 20:57:12 |
 |    3 | 2021-02-15 20:57:12 |
 +------+---------------------+
</code></pre>

Find all rows of data before a certain date:

<pre><code>SELECT *
FROM   my_table
<strong>WHERE  creation_datetime &#x3C; CURRENT_DATE;
</strong>
 +------+---------------------+
 | id   | creation_datetime   |
 +------+---------------------+
 |    1 | 2021-01-15 10:47:02 |
 |    2 | 2021-01-15 10:47:02 |
 |    3 | 2021-01-15 10:47:02 |
 +------+---------------------+
</code></pre>

### Add or Subtract a Date or Time Interval

You can add or subtract various time intervals (years, months, days, hours, minutes, seconds, etc.) from date and time values.

[Table 7-14](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#return\_yesterdays\_date) lists the ways to subtract a day.

| RDBMS      | Code                                                                                                                                                                            |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| MySQL      | <p><code>SELECT CURRENT_DATE - INTERVAL 1 DAY;</code></p><p><code>SELECT SUBDATE(CURRENT_DATE, 1);</code></p><p><code>SELECT DATE_SUB(CURRENT_DATE, INTERVAL 1 DAY);</code></p> |
| Oracle     | `SELECT CURRENT_DATE - INTERVAL '1' DAY FROM dual;`                                                                                                                             |
| PostgreSQL | `SELECT CAST(CURRENT_DATE - INTERVAL '1 day' AS DATE);`                                                                                                                         |
| SQL Server | <p><code>SELECT CAST(CURRENT_TIMESTAMP - 1 AS DATE);</code></p><p><code>SELECT DATEADD(DAY, -1, CAST( CURRENT_TIMESTAMP AS DATE));</code></p>                                   |
| SQLite     | `SELECT DATE(CURRENT_DATE, '-1 day');`                                                                                                                                          |

[Table 7-15](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#return\_the\_date\_and\_time\_three\_hours\_from\_now) lists the ways to add three hours.

| RDBMS      | Code                                                                                                                                                                                                           |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| MySQL      | <p><code>SELECT CURRENT_TIMESTAMP + INTERVAL 3 HOUR;</code></p><p><code>SELECT ADDDATE(CURRENT_TIMESTAMP, INTERVAL 3 HOUR);</code></p><p><code>SELECT DATE_ADD(CURRENT_TIMESTAMP, INTERVAL 3 HOUR);</code></p> |
| Oracle     | `SELECT CURRENT_TIMESTAMP + INTERVAL '3' HOUR FROM dual;`                                                                                                                                                      |
| PostgreSQL | `SELECT CURRENT_TIMESTAMP + INTERVAL '3 hours';`                                                                                                                                                               |
| SQL Server | `SELECT DATEADD(HOUR, 3, CURRENT_TIMESTAMP);`                                                                                                                                                                  |
| SQLite     | `SELECT DATETIME(CURRENT_TIMESTAMP, '+3 hours');`                                                                                                                                                              |

### Find the Difference Between Two Dates or Times

You can find the difference between two dates, times, or datetimes in terms of various time intervals (years, months, days, hours, minutes, seconds, etc.).

#### Finding a date difference

Given a start and end date, [Table 7-16](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#days\_between\_two\_dates) lists the ways to find the days between the two dates.

Here is a sample table:

```
+------------+------------+
| start_date | end_date   |
+------------+------------+
| 2016-10-10 | 2020-11-11 |
| 2019-03-03 | 2021-04-04 |
+------------+------------+
```

| RDBMS      | Code                                                                              |
| ---------- | --------------------------------------------------------------------------------- |
| MySQL      | `SELECT DATEDIFF(end_date, start_date) AS day_diff FROM my_table;`                |
| Oracle     | `SELECT (end_date - start_date) AS day_diff FROM my_table;`                       |
| PostgreSQL | `SELECT AGE(end_date, start_date) AS day_diff FROM my_table;`                     |
| SQL Server | `SELECT DATEDIFF(day, start_date, end_date) AS day_diff FROM my_table;`           |
| SQLite     | `SELECT (julianday(end_date) - julianday(start_date)) AS day_diff FROM my_table;` |

After running the code in the table, these are the results:

```
-- MySQL, Oracle, SQL Server, and SQLite
+----------+
| day_diff |
+----------+
|     1493 |
|      763 |
+----------+

-- PostgreSQL

       day_diff
---------------------
 4 years 1 mon 1 day
 2 years 1 mon 1 day
```

#### Finding a time difference

Given a start and end time, [Table 7-17](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#seconds\_between\_two\_times) lists the ways to find the seconds between the two times.

Here is a sample table:

```
+------------+----------+
| start_time | end_time |
+------------+----------+
| 10:30:00   | 11:30:00 |
| 14:50:32   | 15:22:45 |
+------------+----------+
```

| RDBMS      | Code                                                                                       |
| ---------- | ------------------------------------------------------------------------------------------ |
| MySQL      | `SELECT TIMEDIFF(end_time, start_time) AS time_diff FROM my_table;`                        |
| Oracle     | No time data type                                                                          |
| PostgreSQL | `SELECT EXTRACT(epoch from end_time - start_time) AS time_diff FROM my_table;`             |
| SQL Server | `SELECT DATEDIFF(second, start_time, end_time) AS time_diff FROM my_table;`                |
| SQLite     | `SELECT (strftime('%s',end_time) - strftime('%s',start_time)) AS time_diff FROM my_table;` |

After running the code in the table, these are the results:

```
-- MySQL
+-----------+
| time_diff |
+-----------+
| 01:00:00  |
| 00:32:13  |
+-----------+
```

```
-- PostgreSQL, SQL Server, and SQLite

 time_diff
-----------
 3600
 1933
 
```

#### Finding a datetime difference

Given a start and end datetime, [Table 7-18](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#hours\_between\_two\_datetimes) lists the ways to find the number of hours between the two datetimes.

Here is a sample table:

```
+---------------------+---------------------+
| start_dt            | end_dt              |
+---------------------+---------------------+
| 2016-10-10 10:30:00 | 2020-11-11 11:30:00 |
| 2019-03-03 14:50:32 | 2021-04-04 15:22:45 |
+---------------------+---------------------+
```

| RDBMS      | Code                                                                                |
| ---------- | ----------------------------------------------------------------------------------- |
| MySQL      | `SELECT TIMESTAMPDIFF(hour, start_dt, end_dt) AS hour_diff FROM my_table;`          |
| Oracle     | `SELECT (end_dt - start_dt) AS hour_diff FROM my_table;`                            |
| PostgreSQL | `SELECT AGE(end_dt, start_dt) AS hour_diff FROM my_table;`                          |
| SQL Server | `SELECT DATEDIFF(hour, start_dt, end_dt) AS hour_diff FROM my_table;`               |
| SQLite     | `SELECT ((julianday(end_dt) - julianday(start_dt))*24) AS hour_diff FROM my_table;` |

After running the code in the table, these are the results:

```
-- MySQL, SQL Server, and SQLite
+-----------+
| hour_diff |
+-----------+
|     35833 |
|     18312 |
+-----------+

-- Oracle

 HOUR_DIFF
---------------------------
 +000001493 01:00:00.000000
 +000000763 00:32:13.000000

-- PostgreSQL

           hour_diff
------------------------------
 4 years 1 mon 1 day 01:00:00
 2 years 1 mon 1 day 00:32:13
```

**NOTE**

The _PostgreSQL_ result is lengthy:

```
SELECT AGE(end_dt, start_dt)
FROM my_table;

             age
------------------------------
 4 years 1 mon 1 day 01:00:00
 2 years 1 mon 1 day 00:32:13
```

Use the [`EXTRACT`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#extract\_a\_part\_of\_a\_date\_or\_time) function to pull out only the `year` field.

<pre><code><strong>SELECT EXTRACT(year FROM
</strong><strong>               AGE(end_dt, start_dt))
</strong>FROM my_table;

 date_part
-----------
<strong>        4
</strong><strong>        2
</strong></code></pre>

### Extract a Part of a Date or Time

There are multiple ways to extract a time unit (month, hour, etc.) from a date or time value. [Table 7-19](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#extract\_the\_month\_from\_a\_date) shows how to do so, specifically for the month time unit.

| RDBMS      | Code                                                                                                                     |
| ---------- | ------------------------------------------------------------------------------------------------------------------------ |
| MySQL      | <p><code>SELECT EXTRACT(month FROM CURRENT_DATE);</code></p><p><code>SELECT MONTH(CURRENT_DATE);</code></p>              |
| Oracle     | `SELECT EXTRACT(month FROM CURRENT_DATE) FROM dual;`                                                                     |
| PostgreSQL | <p><code>SELECT EXTRACT(month FROM CURRENT_DATE);</code></p><p><code>SELECT DATE_PART('month', CURRENT_DATE);</code></p> |
| SQL Server | <p><code>SELECT DATEPART(month, CURRENT_TIMESTAMP);</code></p><p><code>SELECT MONTH(CURRENT_TIMESTAMP);</code></p>       |
| SQLite     | `SELECT strftime('%m', CURRENT_DATE);`                                                                                   |

Both _MySQL_ and _SQL Server_ support time unit specific functions like `MONTH()`, as seen in [Table 7-19](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#extract\_the\_month\_from\_a\_date).

* _MySQL_ supports `YEAR()`, `QUARTER()`, `MONTH()`, `WEEK()`, `DAY()`, `HOUR()`, `MINUTE()`, and `SECOND()`.
* _SQL Server_ supports `YEAR()`, `MONTH()`, and `DAY()`.

You can replace the `month` or `%m` values in [Table 7-19](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#extract\_the\_month\_from\_a\_date) with other time units. [Table 7-20](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#time\_units\_options) lists the time units accepted by each RDBMS.

| MySQL                                                                                                             | Oracle                                                                 | PostgreSQL                                                                                                                                                               | SQL Server                                                                                                                                                                         | SQLite                                                                                                                                                                                                                                                                            |
| ----------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <p>microsecond</p><p>second</p><p>minute</p><p>hour</p><p>day</p><p>week</p><p>month</p><p>quarter</p><p>year</p> | <p>second</p><p>minute</p><p>hour</p><p>day</p><p>month</p><p>year</p> | <p>microsecond</p><p>millisecond</p><p>second</p><p>minute</p><p>hour</p><p>day</p><p>dow</p><p>week</p><p>month</p><p>quarter</p><p>year</p><p>decade</p><p>century</p> | <p>nanosecond</p><p>microsecond</p><p>millisecond</p><p>second</p><p>minute</p><p>hour</p><p>week</p><p>weekday</p><p>day</p><p>dayofyear</p><p>month</p><p>quarter</p><p>year</p> | <p>%f (fractional second)</p><p>%S (second)</p><p>%s (seconds since 1970-01-01)</p><p>%M (minute)</p><p>%H (hour)</p><p>%J (Julian day number)</p><p>%w (day of week)</p><p>%d (day of month)</p><p>%j (day of year)</p><p>%W (week of year)</p><p>%m (month)</p><p>%Y (year)</p> |

**NOTE**

You can also extract a time unit from a string value. The code can be found in [Table 7-28: Extract year from a string](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#extract\_year\_from\_a\_string).

### Determine the Day of the Week of a Date

Given a date, determine the day of the week:

* Date: `2020-03-16`
* Numeric day of the week: `2` (Sunday is the first day)
* Day of the week: `Monday`

[Table 7-21](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#return\_the\_numeric\_day\_of\_the\_week) returns the numeric day of the week of a given date. Sunday is the first day, Monday the second day, and so on.

| RDBMS      | Code                                                 | Range of Values |
| ---------- | ---------------------------------------------------- | --------------- |
| MySQL      | `SELECT DAYOFWEEK('2020-03-16');`                    | 1 to 7          |
| Oracle     | `SELECT TO_CHAR( date '2020-03-16', 'd') FROM dual;` | 1 to 7          |
| PostgreSQL | `SELECT DATE_PART('dow', date '2020-03-16');`        | 0 to 6          |
| SQL Server | `SELECT DATEPART(weekday, '2020-03-16');`            | 1 to 7          |
| SQLite     | `SELECT strftime('%w', '2020-03-16');`               | 0 to 6          |

[Table 7-22](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#return\_the\_day\_of\_the\_week) returns the day of the week of a given date.

| RDBMS      | Code                                                  |
| ---------- | ----------------------------------------------------- |
| MySQL      | `SELECT DAYNAME('2020-03-16');`                       |
| Oracle     | `SELECT TO_CHAR(date '2020-03-16', 'day') FROM dual;` |
| PostgreSQL | `SELECT TO_CHAR(date '2020-03-16', 'day');`           |
| SQL Server | `SELECT DATENAME(weekday, '2020-03-16');`             |
| SQLite     | Not available                                         |

### Round a Date to the Nearest Time Unit

_Oracle_ and _PostgreSQL_ support rounding and truncating (also known as rounding down).

#### Rounding in Oracle

Oracle supports rounding and truncating a date to the nearest year, month, or day (first day of the week).

To round down to the first of the month:

```
SELECT TRUNC(date '2020-02-25', 'month')
FROM   dual;

01-FEB-20
```

To round to the nearest month:

```
SELECT ROUND(date '2020-02-25', 'month')
FROM   dual;

01-MAR-20
```

#### Rounding in PostgreSQL

PostgreSQL supports truncating a date to the nearest year, quarter, month, week (first day of the week), day, hour, minute, or second. Additional time units can be found in the [PostgreSQL documentation](https://oreil.ly/OONv8).

To round down to the first of the month:

```
SELECT DATE_TRUNC('month', DATE '2020-02-25');

2020-02-01 00:00:00-06
```

To round down to the minute:

```
SELECT DATE_TRUNC('minute', TIME '10:30:59.12345');

10:30:00
```

### Convert a String to a Datetime Data Type

There are two ways to convert a string to a datetime data type:

* Use the `CAST` function for a simple case.
* Use `STR_TO_DATE`/`TO_DATE`/`CONVERT` for a custom case.

#### The CAST function

If a string column contains dates in a standard format, you can use the `CAST` function to turn it into a date data type.

[Table 7-23](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#convert\_a\_string\_to\_a\_date) shows the code for converting to a date data type.

| RDBMS                                            | Required Date Format | Code                                            |
| ------------------------------------------------ | -------------------- | ----------------------------------------------- |
| <p>MySQL,</p><p>PostgreSQL,</p><p>SQL Server</p> | `YYYY-MM-DD`         | `SELECT CAST('2020-10-15' AS DATE);`            |
| Oracle                                           | `DD-MON-YYYY`        | `SELECT CAST('15-OCT-2020' AS DATE) FROM dual;` |
| SQLite                                           | `YYYY-MM-DD`         | `SELECT DATE('2020-10-15');`                    |

[Table 7-24](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#convert\_a\_string\_to\_a\_time) shows the code for converting to a time data type.

| RDBMS                                            | Required Time Format                                           | Code                                            |
| ------------------------------------------------ | -------------------------------------------------------------- | ----------------------------------------------- |
| <p>MySQL,</p><p>PostgreSQL,</p><p>SQL Server</p> | `hh:mm:ss`                                                     | `SELECT CAST('14:30' AS TIME);`                 |
| Oracle                                           | <p><code>hh:mm:ss</code></p><p><code>hh:mm:ss AM/PM</code></p> | `SELECT CAST('02:30:00 PM' AS TIME) FROM dual;` |
| SQLite                                           | `hh:mm:ss`                                                     | `SELECT TIME('14:30');`                         |

[Table 7-25](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#convert\_a\_string\_to\_a\_datetime) shows the code for converting to a datetime data type.

| RDBMS                          | Required Datetime Format                                                               | Code                                                           |
| ------------------------------ | -------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| <p>MySQL,</p><p>SQL Server</p> | `YYYY-MM-DD hh:mm:ss`                                                                  | `SELECT CAST('2020-10-15 14:30' AS DATETIME);`                 |
| Oracle                         | <p><code>DD-MON-YYYY hh:mm:ss</code></p><p><code>DD-MON-YYYY hh:mm:ss AM/PM</code></p> | `SELECT CAST('15-OCT-20 02:30:00 PM' AS TIMESTAMP) FROM dual;` |
| PostgreSQL                     | `YYYY-MM-DD hh:mm:ss`                                                                  | `SELECT CAST('2020-10-15 14:30' AS TIMESTAMP);`                |
| SQLite                         | `YYYY-MM-DD hh:mm:ss`                                                                  | `SELECT DATETIME('2020-10-15 14:30');`                         |

The `CAST` function can also be used to convert dates to [numeric](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#convert\_data\_to\_a\_numeric\_data\_type) and [string](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#convert\_data\_to\_a\_string\_data\_type) data types.

#### The STR\_TO\_DATE, TO\_DATE, and CONVERT functions

For dates and times not in the standard `YYYY-MM-DD`/`DD-MON-YYYY`/`hh:mm:ss` formats, use a string to date or a string to time function instead.

[Table 7-26](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#string\_to\_date\_and\_time\_functions) lists the string to date and string to time functions for each RDBMS. The example strings in the code are in non-standard formats `MM-DD-YY` and `hhmm`.

| RDBMS      | String to date                                      | String to time                                     |
| ---------- | --------------------------------------------------- | -------------------------------------------------- |
| MySQL      | `SELECT STR_TO_DATE('10-15-22', '%m-%d-%y');`       | `SELECT STR_TO_DATE('1030', '%H%i');`              |
| Oracle     | `SELECT TO_DATE('10-15-22', 'MM-DD-YY') FROM dual;` | `SELECT TO_TIMESTAMP('1030', 'HH24MI') FROM dual;` |
| PostgreSQL | `SELECT TO_DATE('10-15-22', 'MM-DD-YY');`           | `SELECT TO_TIMESTAMP('1030', 'HH24MI');`           |
| SQL Server | `SELECT CONVERT( VARCHAR, '10-15-22', 105);`        | `SELECT CAST( CONCAT(10,':',30) AS TIME);`         |
| SQLite     | No nonstardard date function                        | No non-standard time function                      |

**NOTE**

_SQL Server_ uses the `CONVERT` function to change a string to a datetime data type. `VARCHAR` is the original data type, `10-15-22` is the date, and `105` stands for the format `MM-DD-YYYY`.

Other date formats are `MM/DD/YYYY` (101), `YYYY.MM.DD` (102), `DD/MM/YYYY` (103), and `DD.MM.YYYY` (104). More formats are listed in the [Microsoft documentation](https://oreil.ly/qY0IH).

The time formats are `hh:mi:ss` (108) and `hh:mi:ss:mmm` (114), neither which match the format in [Table 7-26](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#string\_to\_date\_and\_time\_functions), which is why the time can’t be read in by SQL Server using `CONVERT`.

You can replace the `%H%i` or `HH24MI` values in [Table 7-26](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#string\_to\_date\_and\_time\_functions) with other time units. [Table 7-27](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#datetime\_format\_specifiers) lists common format specifiers for _MySQL_, _Oracle_, and _PostgreSQL_.

| MySQL | Oracle and PostgreSQL | Description                      |
| ----- | --------------------- | -------------------------------- |
| %Y    | YYYY                  | 4-digit year                     |
| %y    | YY                    | 2-digit year                     |
| %m    | MM                    | Numeric month (1–12)             |
| %b    | MON                   | Abbreviated month (Jan–Dec)      |
| %M    | MONTH                 | Name of month (January–December) |
| %d    | DD                    | Day (1–31)                       |
| %h    | HH or HH12            | 12 hours (1–12)                  |
| %H    | HH24                  | 24 hours (0–23)                  |
| %i    | MI                    | Minutes (0–59)                   |
| %s    | SS                    | Seconds (0–59)                   |

#### Apply a date function to a string column

Imagine you have the following string column:

```
str_column
10/15/2022
10/16/2023
10/17/2024
```

You want to extract the year from each date:

```
year_column
2022
2023
2024
```

Problem

You cannot use a datetime function (`EXTRACT`) on a string column (`str_column`).

Solution

First convert the string column into a date column. Then apply the datetime function. [Table 7-28](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#extract\_year\_from\_a\_string) lists how to do so in each RDBMS.

| RDBMS      | Code                                                                         |
| ---------- | ---------------------------------------------------------------------------- |
| MySQL      | `SELECT YEAR(STR_TO_DATE(str_column, '%m/%d/%Y')) FROM my_table;`            |
| Oracle     | `SELECT EXTRACT(YEAR FROM TO_DATE(str_column, 'MM/DD/YYYY')) FROM my_table;` |
| PostgreSQL | `SELECT EXTRACT(YEAR FROM TO_DATE(str_column, 'MM/DD/YYYY')) FROM my_table;` |
| SQL Server | `SELECT YEAR(CONVERT(CHAR, str_column, 101)) FROM my_table;`                 |
| SQLite     | `SELECT SUBSTR(str_column, 7) FROM my_table;`                                |

**NOTE**

_SQLite_ does not have datetime functions, but a workaround is to use the [`SUBSTR`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#extract\_a\_portion\_of\_a\_string) (substring) function to extract the last four digits.

## Null Functions

Null functions can be applied to any type of column and are triggered when a null value is encountered.

### Return an Alternative Value if There Is a Null Value

Use the `COALESCE` function.

Here is a sample table:

```
+------+----------+
| id   | greeting |
+------+----------+
|    1 | hi there |
|    2 | hello!   |
|    3 | NULL     |
+------+----------+
```

When there is no greeting, return `hi`:

<pre><code><strong>SELECT COALESCE(greeting, 'hi') AS greeting
</strong>FROM my_table;

+----------+
| greeting |
+----------+
| hi there |
| hello!   |
| hi       |
+----------+
</code></pre>

_MySQL_ and _SQLite_ also accept `IFNULL(greeting, 'hi')`.

_Oracle_ also accepts `NVL(greeting, 'hi')`.

_SQL Server_ also accepts `ISNULL(greeting, 'hi')`.
