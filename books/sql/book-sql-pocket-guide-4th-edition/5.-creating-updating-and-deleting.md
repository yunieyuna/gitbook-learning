# 5. Creating, Updating, And Deleting

## Chapter 5. Creating, Updating, and Deleting

The majority of this book covers how to read data from a database with SQL queries. Reading is one of the four basic database operations out of create, read, update, and delete (CRUD).

This chapter focuses on the remaining three operations for [Databases](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#crud\_databases), [Tables](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#creating\_tables), [Indexes](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#crud\_indexes), and [Views](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#crud\_views). In addition, the [Transaction Management](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#transaction\_management) section covers how to execute multiple commands as a single unit.

## Databases

A _database_ is a place to store data in an organized way.

Within a database, you can create _database objects_, which are things that store or reference data. Common database objects include [tables](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#creating\_tables), [constraints](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#create\_a\_table\_with\_constraints), [indexes](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#crud\_indexes), and [views](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#crud\_views).

A _data model_ or a _schema_ describes how database objects are organized within a database.

[Figure 5-1](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#star\_schema) shows a database that contains many tables. The specifics around how the tables are defined (i.e., the `Sales` table contains five columns) and how they connect with one another (i.e., the `customer_id` column in the `Sales` table matches the `customer_id` column in the `Customer` table) are all a part of the _schema_ of the database.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492090397/files/assets/spg4_0501.png" alt="spg4 0501" height="773" width="600"><figcaption></figcaption></figure>

**Figure 5-1. A database containing a star schema**

The tables in [Figure 5-1](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#star\_schema) are arranged in a _star schema_, which is a basic way of organizing tables in a database. The star schema includes a _fact table_ in the center and is surrounded by _dimension tables_ (also known as _lookup tables_). The fact table records transactions made (sales in this case) along with IDs of additional information, which are fully detailed out in the dimension tables.

### Data Model Versus Schema

When designing a database, you would first come up with a _data model_, which is how you want your database organized at a high level. It could look like [Figure 5-1](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#star\_schema) and include table names, how they are connected to one another, etc.

When you are ready to take action, you would create a _schema_, which is the implementation of the data model in a database. Within the software you are working in, you would specify the tables, constraints, primary and foreign keys, etc.

**NOTE**

The definition of a schema varies for some RDBMSs.

In _MySQL_, a schema is the same thing as a database and the two terms can be used interchangeably.

In _Oracle_, a schema consists of the database objects owned by a particular user, so the terms _schema_ and _user_ are used interchangeably.

### Display Names of Existing Databases

All database objects reside in databases, so a good first step is to see what databases currently exist. [Table 5-1](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_display\_names\_of\_existing\_databases) shows the code to display the names of all existing databases in each RDBMS.

| RDBMS      | Code                                                      |
| ---------- | --------------------------------------------------------- |
| MySQL      | `SHOW databases;`                                         |
| Oracle     | `SELECT * FROM global_name;`                              |
| PostgreSQL | `\l`                                                      |
| SQL Server | `SELECT name FROM master.sys.databases;`                  |
| SQLite     | `.database` (or look in the file browser for _.db_ files) |

**NOTE**

_SQLite_: For most RDBMS software, databases are located within the RDBMS. However, for SQLite, databases are stored outside of SQLite as _.db_ files. To use a database, you would specify a _.db_ file name when launching SQLite:

```
> sqlite3 existing_db.db
```

### Display Name of Current Database

You may want to confirm the database you are currently in before writing any queries. [Table 5-2](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_display\_name\_of\_current\_database) shows the code to display the name of the database you are currently in for each RDBMS.

| RDBMS      | Code                         |
| ---------- | ---------------------------- |
| MySQL      | `SELECT database();`         |
| Oracle     | `SELECT * FROM global_name;` |
| PostgreSQL | `SELECT current_database();` |
| SQL Server | `SELECT db_name();`          |
| SQLite     | `.database`                  |

**NOTE**

You may have noticed that the current database code is the same as the existing database code for Oracle and SQLite.

An instance of _Oracle_ can only connect to a single database at a time, and you typically don’t switch databases.

With _SQLite_, you can only open up and work with a single database file at a time.

### Switch to Another Database

You may want to use data in another database or switch to a newly created database. [Table 5-3](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_switch\_to\_another\_database) shows the code to switch to another database in each RDBMS.

| RDBMS                          | Code                                                                                                                     |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------------------ |
| <p>MySQL,</p><p>SQL Server</p> | `USE another_db;`                                                                                                        |
| Oracle                         | You typically don’t switch databases (see earlier note), but to switch users, you would type: **`connect another_user`** |
| PostgreSQL                     | `\c another_db`                                                                                                          |
| SQLite                         | `.open another_db`                                                                                                       |

### Create a Database

If you have CREATE privileges, you can create a new database. If not, you may only be able to work within an existing database. [Table 5-4](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_create\_a\_database) shows the code to create a database in each RDBMS.

| RDBMS                                                          | Code                         |
| -------------------------------------------------------------- | ---------------------------- |
| <p>MySQL,</p><p>Oracle,</p><p>PostgreSQL,</p><p>SQL Server</p> | `CREATE DATABASE my_new_db;` |
| SQLite                                                         | `> sqlite3 my_new_db.db`     |

**NOTE**

_Oracle_: There are some additional steps (regarding instances, environment variables, etc.) surrounding the `CREATE DATABASE` statement in Oracle, which can be found in the Oracle [documentation](https://oreil.ly/lXKOF).

_SQLite_: The `>` symbol is not a character that you actually type. It just signifies that this is command line code, not SQL code.

### Delete a Database

If you have DELETE privileges, you can delete a database. [Table 5-5](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_delete\_a\_database) shows the code to delete a database in each RDBMS.

**WARNING**

If you delete a database, you will lose all of the data in the database. _There is no undo_, unless a backup has been created. I recommend not running this command unless you are 100% sure you don’t need the database.

| RDBMS                                                          | Code                                      |
| -------------------------------------------------------------- | ----------------------------------------- |
| <p>MySQL,</p><p>Oracle,</p><p>PostgreSQL,</p><p>SQL Server</p> | `DROP DATABASE my_new_db;`                |
| SQLite                                                         | Delete the _.db_ file in the file browser |

**NOTE**

_Oracle_: There are some additional steps (regarding mounting, etc.) surrounding the `DROP DATABASE` statement in Oracle, which can be found in the Oracle [documentation](https://oreil.ly/v0Tjd).

In some RDBMSs, you can’t drop a database you are currently in. You would have to first switch to another database, such as the default one, before dropping the database:

* In _PostgreSQL_, the default database is `postgres`:

```
\c postgres
DROP DATABASE my_new_db;
```

* In _SQL Server_, the default database is `master`:

```
USE master;
go
DROP DATABASE my_new_db;
go
```

## Creating Tables

Tables consist of rows and columns, and store all of the data in a database. In SQL, there are a few additional requirements for tables:

* Each row of a table should be unique
* All data in a column must be of the same data type (integer, text, etc.)

**NOTE**

In _SQLite_, the data in a column _does not_ have to all be of the same data type. SQLite is more flexible in that each value has a data type associated with it, rather than an entire column.

To be compatible with other RDBMSs, SQLite does support columns having data type assignments. These _type affinities_ are recommended data types for the columns, and are not required.

### Create a Simple Table

It takes two steps to create a table in SQL. You must first define the structure of a table before loading data into it:

1.  Create a table.

    The following code creates an empty table called `my_simple_table` with three columns: `id`, `country`, and `name`. All values in the first column (`id`) must be integers, and the other two columns (`country`, `name`) can contain up to 2 and up to 15 characters:\


    ```

    CREATE TABLE my_simple_table (
       id INTEGER,
       country VARCHAR(2),
       name VARCHAR(15)
    );
    ```

    More data types in addition to `INTEGER` and `VARCHAR` are listed in [Chapter 6](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch06.html#data\_types).
2. Insert rows.
   1.  Insert a single row of data.

       The following code inserts one row of data into columns `id`, `country`, and `name`:\


       ```

       INSERT INTO my_simple_table (id, country, name)
       VALUES (1, 'US', 'Sam');
       ```
   2.  Insert multiple rows of data.

       [Table 5-6](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_insert\_multiple\_rows\_of\_data) shows how to insert multiple rows of data into a table in each RDBMS, instead of one row at a time.

| RDBMS                                                          | Code                                                                                                                                                                                                                                        |
| -------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <p>MySQL,</p><p>PostgreSQL,</p><p>SQL Server,</p><p>SQLite</p> | `INSERT INTO my_simple_table (id, country, name) VALUES (2, 'US', 'Selena'), (3, 'CA', 'Shawn'), (4, 'US', 'Sutton');`                                                                                                                      |
| Oracle                                                         | `INSERT ALL INTO my_simple_table (id, country, name) VALUES (2, 'US', 'Selena') INTO my_simple_table (id, country, name) VALUES (3, 'CA', 'Shawn') INTO my_simple_table (id, country, name) VALUES (4, 'US', 'Sutton') SELECT * FROM dual;` |

After inserting the data, the table would look like this:

```
SELECT * FROM my_simple_table;

id  country  name
--- -------- -------
  1 US       Sam
  2 US       Selena
  3 CA       Shawn
  4 US       Sutton
```

When inserting rows of data, the order of the values must match the order of the column names exactly.

Values in any columns omitted from the column list will take on their default value of `NULL`, unless another [default value](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#setting\_default\_values\_in\_a\_column\_with\_default) is specified.

**NOTE**

You need CREATE privileges to create a table. If you get an error when running the preceding code, you do not have the permission to do so and need to talk to your database administrator.

### Display Names of Existing Tables

Before creating a table, you may want to see if the table name already exists. [Table 5-7](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_display\_names\_of\_existing\_tables) shows the code to display the names of existing tables in the database for each RDBMS.

| RDBMS                                                            | Code                                                                        |
| ---------------------------------------------------------------- | --------------------------------------------------------------------------- |
| MySQL                                                            | `SHOW tables;`                                                              |
| Oracle                                                           | `-- All tables, including system tables SELECT table_name FROM all_tables;` |
| `-- All user created tables SELECT table_name FROM user_tables;` |                                                                             |
| PostgreSQL                                                       | `\dt`                                                                       |
| SQL Server                                                       | `SELECT table_name FROM information_schema.tables;`                         |
| SQLite                                                           | `.tables`                                                                   |

### Create a Table That Does Not Already Exist

In _MySQL_, _PostgreSQL_, and _SQLite_, you can check for existing tables using the `IF NOT EXISTS` keywords when creating a table:

<pre><code><strong>CREATE TABLE IF NOT EXISTS my_simple_table (
</strong>   id INTEGER,
   country VARCHAR(2),
   name VARCHAR(15)
);
</code></pre>

If the table name does not exist, a new table will get created. If the table name already exists, without the `IF NOT EXISTS`, you would get an error message. With the `IF NOT EXISTS`, no new table gets created and you would avoid an error message.

If you want to replace an existing table, there are two approaches to doing so:

* You could use [`DROP TABLE`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#delete\_a\_table) to completely delete the existing table, and then create a new one.
* You could _truncate_ the existing table, meaning you keep the schema (aka structure) of the table, but clear out the data inside of it. This can be done by using [`DELETE FROM`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#delete\_rows\_from\_a\_table) to delete data from the table.

### Create a Table with Constraints

A _constraint_ is a rule that specifies what data can be inserted into a table. The following code creates two tables and multiple constraints (bolded):

<pre><code>CREATE TABLE another_table (
   country VARCHAR(2) NOT NULL,
   name VARCHAR(15) NOT NULL,
   description VARCHAR(50),
   CONSTRAINT pk_another_table
<strong>      PRIMARY KEY (country, name)
</strong>);

CREATE TABLE my_table (
<strong>   id INTEGER NOT NULL,
</strong><strong>   country VARCHAR(2) DEFAULT 'CA'
</strong>      CONSTRAINT chk_country
<strong>      CHECK (country IN ('CA','US')),
</strong>   name VARCHAR(15),
   cap_name VARCHAR(15),
   CONSTRAINT pk
<strong>      PRIMARY KEY (id),
</strong>   CONSTRAINT fk1
<strong>      FOREIGN KEY (country, name)
</strong><strong>      REFERENCES another_table (country, name),
</strong>   CONSTRAINT unq_country_name
<strong>      UNIQUE (country, name),
</strong>   CONSTRAINT chk_upper_name
<strong>      CHECK (cap_name = UPPER(name))
</strong>);
</code></pre>

The `CONSTRAINT` keyword names the constraint for future reference and is optional. You should avoid using the same name for both a column and a constraint.

For quick access to the constraint sections: [`NOT NULL`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#not\_allowing\_null\_values\_in\_a\_column\_with\_not\_null), [`DEFAULT`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#setting\_default\_values\_in\_a\_column\_with\_default), [`CHECK`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#restricting\_values\_in\_a\_column\_with\_check), [`UNIQUE`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#requiring\_unique\_values\_in\_a\_column\_with\_unique), [`PRIMARY KEY`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#specify\_a\_primary\_key), [`FOREIGN KEY`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#specify\_a\_foreign\_key).

#### Constraint: Not allowing NULL values in a column with NOT NULL

In a SQL table, cells without a value are replaced with the term `NULL`. For each column, you can specify whether `NULL` values are allowed or not:

<pre><code>CREATE TABLE my_table (
<strong>   id INTEGER NOT NULL,
</strong><strong>   country VARCHAR(2) NULL,
</strong>   name VARCHAR(15)
);
</code></pre>

The `NOT NULL` constraint on the `id` column means that the column will not allow `NULL` values. In other words, there can be no missing values inserted into the column, or else you will get an error message.

The `NULL` constraint on the `country` column means that the column will allow `NULL` values. If you are inserting data into the table and exclude the `country` column, then no value will be inserted, and the cell will be replaced with a `NULL` value.

By not specifying `NULL` or `NOT NULL`, the `name` column defaults to `NULL`, meaning it will allow `NULL` values.

#### Constraint: Setting default values in a column with DEFAULT

When inserting data into a table, missing values get replaced with the term `NULL`. To replace missing values with another value, you can use the `DEFAULT` constraint. The following code turns any missing `country` value into `CA`:

<pre><code>CREATE TABLE my_table (
   id INTEGER,
<strong>   country VARCHAR(2) DEFAULT 'CA',
</strong>   name VARCHAR(15)
);
</code></pre>

#### Constraint: Restricting values in a column with CHECK

You can restrict the values allowed in a column by using the `CHECK` constraint. The following code only allows values of `CA` and `US` in the `country` column.

You can place the `CHECK` keyword immediately after the column name and data type:

<pre><code>CREATE TABLE my_table (
   id INTEGER,
<strong>   country VARCHAR(2) CHECK
</strong><strong>      (country IN ('CA', 'US')),
</strong>   name VARCHAR(15)
);
</code></pre>

Or you can place the `CHECK` keyword after all the column names and data types:

<pre><code>CREATE TABLE my_table (
   id INTEGER,
   country VARCHAR(2),
   name VARCHAR(15),
<strong>   CHECK (country IN ('CA','US'))
</strong>);
</code></pre>

You can also include logic that checks multiple columns:

<pre><code>CREATE TABLE my_table (
   id INTEGER,
   country VARCHAR(2),
   name VARCHAR(15),
<strong>   CONSTRAINT chk_id_country
</strong><strong>   CHECK (id > 100 AND country IN ('CA','US'))
</strong>);
</code></pre>

#### Constraint: Requiring unique values in a column with UNIQUE

You can require the values of a column to be unique by using the `UNIQUE` constraint.

You can place the `UNIQUE` keyword immediately after the column name and data type:

<pre><code>CREATE TABLE my_table (
<strong>   id INTEGER UNIQUE,
</strong>   country VARCHAR(2),
   name VARCHAR(15)
);
</code></pre>

Or you can place the `UNIQUE` keyword after all the column names and data types:

<pre><code>CREATE TABLE my_table (
   id INTEGER,
   country VARCHAR(2),
   name VARCHAR(15),
<strong>   UNIQUE (id)
</strong>);
</code></pre>

You can also include logic that forces the combination of multiple columns to be unique. The following code requires unique `country`/`name` combinations, meaning that one row can include `CA`/`Emma` and another can include `US`/`Emma`:

<pre><code>CREATE TABLE my_table (
   id INTEGER,
   country VARCHAR(2),
   name VARCHAR(15),
<strong>   CONSTRAINT unq_country_name
</strong><strong>   UNIQUE (country, name)
</strong>);
</code></pre>

### Create a Table with Primary and Foreign Keys

Primary keys and foreign keys are special types of constraints that uniquely identify rows of data.

#### Specify a primary key

A _primary key_ uniquely identifies each row of data in a table. A primary key can be made up of one or more columns in a table. Every table should have a primary key.

You can place the `PRIMARY KEY` keywords immediately after the column name and data type:

<pre><code>CREATE TABLE my_table (
<strong>   id INTEGER PRIMARY KEY,
</strong>   country VARCHAR(2),
   name VARCHAR(15)
);
</code></pre>

Or you can place the `PRIMARY KEY` keywords after all the column names and data types:

<pre><code>CREATE TABLE my_table (
   id INTEGER,
   country VARCHAR(2),
   name VARCHAR(15),
<strong>   PRIMARY KEY (id)
</strong>);
</code></pre>

To specify a primary key consisting of multiple columns (also known as a _composite key_):

<pre><code>CREATE TABLE my_table (
   id INTEGER NOT NULL,
   country VARCHAR(2),
   name VARCHAR(15) NOT NULL,
<strong>   CONSTRAINT pk_id_name
</strong><strong>   PRIMARY KEY (id, name)
</strong>);
</code></pre>

By creating a `PRIMARY KEY`, the constraints that you are putting on the column(s) are that they cannot include `NULL` values ([`NOT NULL`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#not\_allowing\_null\_values\_in\_a\_column\_with\_not\_null)) and the values must be unique ([`UNIQUE`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#requiring\_unique\_values\_in\_a\_column\_with\_unique)).

**PRIMARY KEY BEST PRACTICES**

_Every table should have a primary key._ This ensures that every row can be uniquely identified.

_It is recommended that primary keys consist of ID columns_, like `(country_id, name_id)` instead of `(country, name)`. Technically, multiple rows could have the same `country` and `name` combination. By adding columns that contain unique IDs (`101`, `102`, etc.), the combination of `country_id` and `name_id` is guaranteed to be unique.

_Primary keys should be immutable_, meaning that they can’t be changed. This allows for a particular row in a table to always be identified by the same primary key.

#### Specify a foreign key

A _foreign key_ in a table refers to a primary key in another table. The two tables can be linked together by the common column. A table can have zero or more foreign keys.

[Figure 5-2](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#foreign\_key\_visual) shows a data model of two tables: the `customers` table, which has a primary key of `id`, and the `orders` table, which has a primary key of `o_id`. From the viewpoint of `customers`, its `order_id` column matches with values of the `o_id` column, making `order_id` a foreign key because it refers to a primary key in another table.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492090397/files/assets/spg4_0502.png" alt="spg4 0502" height="236" width="600"><figcaption></figcaption></figure>

**Figure 5-2. Two tables with primary keys and a foreign key**

To specify a foreign key, use the following steps:

1.  Locate the table you plan to reference and identify the primary key.

    In this case, we will be referencing `orders`, specifically the `o_id` column:

    <pre><code>
    CREATE TABLE orders (
    <strong>   o_id INTEGER PRIMARY KEY,
    </strong>   o_location VARCHAR(20),
       o_price DECIMAL(6,2)
    );
    </code></pre>
2.  Create a table with a foreign key that references the primary key in the other table.

    In this case, we are creating the `customers` table where the `order_id` column references the `o_id` primary key in the `orders` table:

    <pre><code>  CREATE TABLE customers (
       id INTEGER PRIMARY KEY,
       order_id INTEGER,
       name VARCHAR(15),
       location VARCHAR(20),
    <strong>   FOREIGN KEY (order_id)
    </strong><strong>   REFERENCES orders (o_id)
    </strong>);
    </code></pre>

To specify a foreign key consisting of multiple columns, the primary key must consist of multiple columns as well:

<pre><code>CREATE TABLE orders (
   o_id INTEGER,
   o_location VARCHAR(20),
   o_price DECIMAL(6,2),
<strong>   PRIMARY KEY (o_id, o_location)
</strong>);
</code></pre>

<pre><code>CREATE TABLE customers (
   id INTEGER PRIMARY KEY,
   order_id INTEGER,
   name VARCHAR(15),
   location VARCHAR(20),
<strong>   CONSTRAINT fk_id_name
</strong><strong>   FOREIGN KEY (order_id, location)
</strong><strong>   REFERENCES orders (o_id, o_location)
</strong>);
</code></pre>

**NOTE**

The foreign key (`order_id`) and primary key it references (`o_id`) must both be the same data type.

### Create a Table with an Automatically Generated Field

If you plan to load a dataset without a unique ID column, you may want to create a column that automatically generates a unique ID. The code in [Table 5-8](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_automatically\_generate\_a\_unique\_id) automatically generates sequential numbers (1, 2, 3, etc.) in the `u_id` column, in each RDBMS.

| RDBMS      | Code                                                                                                                                                                                                     |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| MySQL      | <pre><code>CREATE TABLE my_table (
<strong>   u_id INTEGER PRIMARY KEY AUTO_INCREMENT,
</strong>   country VARCHAR(2),
   name VARCHAR(15)
);
</code></pre>                                              |
| Oracle     | <pre><code>CREATE TABLE my_table (
<strong>  u_id INTEGER GENERATED BY DEFAULT
</strong><strong>               ON NULL AS IDENTITY,
</strong>  country VARCHAR2(2),
  name VARCHAR2(15)
);
</code></pre> |
| PostgreSQL | <pre><code>CREATE TABLE my_table (
<strong>   u_id SERIAL,
</strong>   country VARCHAR(2),
   name VARCHAR(15)
);
</code></pre>                                                                          |
| SQL Server | <pre><code>-- u_id to begin at 1 and increment by 1
CREATE TABLE my_table (
<strong>   u_id INTEGER IDENTITY(1,1),
</strong>   country VARCHAR(2),
   name VARCHAR(15)
);
</code></pre>                  |
| SQLite     | <pre><code>CREATE TABLE my_table (
<strong>   u_id INTEGER PRIMARY KEY AUTOINCREMENT,
</strong>   country VARCHAR(2),
   name VARCHAR(15)
);
</code></pre>                                               |

**NOTE**

In _Oracle_, `VARCHAR2` is typically used instead of `VARCHAR`. They are identical in terms of functionality, but `VARCHAR` may one day be modified, so it’s safer to use `VARCHAR2`.

_SQLite_ recommends against using `AUTOINCREMENT` unless absolutely necessary because it uses additional computing resources. The code will still run without error.

### Insert the Results of a Query into a Table

Instead of manually typing values to insert into a new table, you may want to load a new table with data from existing table(s).

Here is a table:

```
SELECT * FROM my_simple_table;

id  country  name
--- -------- -------
  1 US       Sam
  2 US       Selena
  3 CA       Shawn
  4 US       Sutton
```

Create a new table with two columns:

```
CREATE TABLE new_table_two_columns (
             id INTEGER,
             name VARCHAR(15)
);
```

Insert the results from a query into the new table:

```
INSERT INTO new_table_two_columns
            (id, name)
SELECT id, name
FROM   my_simple_table
WHERE  id < 3;
```

The new table would then look like:

```
SELECT * FROM new_table_two_columns;

id  name
--- -------
  1 Sam
  2 Selena
```

You can also insert values from an existing table and either add or modify other values along the way.

Create a new table with four columns:

```
CREATE TABLE new_table_four_columns (
             id INTEGER,
             name VARCHAR(15),
             new_num_column INTEGER,
             new_text_column VARCHAR(30)
);
```

Insert the results from a query into the new table and fill in values for the new columns:

```
INSERT INTO new_table_four_columns
       (id, name, new_num_column, new_text_column)
SELECT id, name, 2017, 'stargazing'
FROM   my_simple_table
WHERE  id = 2;
```

Insert the results from a query into the new table and change a value in the row (`id` in this case):

```
INSERT INTO new_table_four_columns
       (id, name, new_num_column, new_text_column)
SELECT 3, name, 2017, 'wolves'
FROM   my_simple_table
WHERE  id = 2;
```

The new table would then look like:

```
SELECT * FROM new_table_four_columns;

id  name    new_num_column  new_text_column
--- ------- --------------- ----------------
  2 Selena  2017            stargazing
  3 Selena  2017            wolves
```

### Insert Data from a Text File into a Table

You may want to load data from a _text file_ (data stored in plain text without special formatting) into a table. A common type of text file is a _.csv_ file (comma separated values). Text files can be opened up in applications outside of an RDBMS including Excel, Notepad, TextEdit, etc.

The following code shows how to load the _my\_data.csv_ file into a table.

Contents of the _my\_data.csv_ file:

```
unique_id,canada_us,artist_name
5,"CA","Celine"
6,"CA","Michael"
7,"US","Stefani"
8,,"Olivia"
...
```

Create a table:

```
CREATE TABLE new_table (
   id INTEGER,
   country VARCHAR(2),
   name VARCHAR(15)
);
```

The code in [Table 5-9](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_insert\_data\_from\_a\_csv\_file) loads the _my\_data.csv_ file into the `new_table` table for each RDBMS. When loading data, you can specify additional details about the data, such as:

* The data is separated by commas (`,`)
* Text values are enclosed in double quotes (`""`)
* Each new row is on a new line ()
* The first row of the text file (which contains the header) should be ignored

| RDBMS      | Code                                                                                                                                                                                                                                                                               |
| ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| MySQL      | `LOAD DATA LOCAL INFILE '<file_path>/my_data.csv' INTO TABLE new_table FIELDS TERMINATED BY ',' ENCLOSED BY '"' LINES TERMINATED BY '\n' IGNORE 1 ROWS;`                                                                                                                           |
| Oracle     | While this can be done at the command line using `sqlldr`, the better approach is to load data through a [graphical user interface](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch02.html#database\_tools) like SQL\*Loader or SQL Developer instead. |
| PostgreSQL | `\copy new_table FROM '<file_path>/my_data.csv' DELIMITER ',' CSV HEADER`                                                                                                                                                                                                          |
| SQL Server | `BULK INSERT new_table FROM '<file_path>/my_data.csv' WITH ( FORMAT = 'CSV', FIELDTERMINATOR = ',', FIELDQUOTE = '"', ROWTERMINATOR = '\n', FIRSTROW = 2, TABLOCK );`                                                                                                              |
| SQLite     | `.mode csv .import <file_path>/my_data.csv new_table --skip 1`                                                                                                                                                                                                                     |

After inserting the data, the table would look like this:

```
SELECT * FROM new_table;

id  country  name
--- -------- --------
  5 CA       Celine
  6 CA       Michael
  7 US       Stefani
  8 NULL     Olivia
...
```

**EXAMPLE FILEPATH TO DESKTOP**

If _my\_data.csv_ is on your Desktop, this is what the file path would look like for each operating system:

* Linux: _/home/my\_username/Desktop/my\_data.csv_
* MacOS: _/Users/my\_username/Desktop/my\_data.csv_
* Windows: _C:\Users\my\_username\Desktop\my\_data.csv_

**NOTE**

If _MySQL_ gives you an error that says that loading local data is disabled, you can enable it by updating the global variable `local_infile`, quitting and restarting MySQL:

```
SET GLOBAL local_infile=1;
quit
```

#### Missing Data and NULL Values

Each RDBMS interprets missing data from a _.csv_ file in a different way. When the following line in a _.csv_ file:

```
8,,"Olivia"
```

is inserted into a SQL table, the missing value between `8` and `Olivia` would get replaced with:

* A `NULL` value in _PostgreSQL_ and _SQL Server_
* An empty string (`''`) in _MySQL_ and _SQLite_

In _MySQL_ and _SQLite_, you can use  in a _.csv_ file to represent a `NULL` value in a SQL table. When the following line in a _.csv_ file,

```
8,\N,"Olivia"
```

is inserted into a _MySQL_ table, the  would get replaced with a `NULL` value in the table.

When it is inserted into a _SQLite_ table, the  would be hardcoded into the table. You could then run the code,

```
UPDATE new_table
SET country = NULL
WHERE country = '\N';
```

to replace the  placeholders with `NULL` values in the table.

## Modifying Tables

This section covers how to change the table name, columns, constraints, and data in a table.

**NOTE**

You need ALTER privileges to modify a table. If you get an error when running the code in this section, you do not have the permission to do so and need to talk to your database administrator.

### Rename a Table or Column

After you’ve created a table, you can still rename the table and the columns of the table.

**WARNING**

If you modify a table, the table will be permanently changed. _There is no undo_, unless there has been a backup created. Double-check your statements before executing them.

#### Rename a table

The code in [Table 5-10](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_rename\_a\_table) shows how to rename a table in each RDBMS.

| RDBMS                             | Code                                                   |
| --------------------------------- | ------------------------------------------------------ |
| MySQL, Oracle, PostgreSQL, SQLite | `ALTER TABLE old_table_name RENAME TO new_table_name;` |
| SQL Server                        | `EXEC sp_rename 'old_table_name', 'new_table_name';`   |

#### Rename a column

The code in [Table 5-11](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_rename\_a\_column) shows how to rename a column in each RDBMS.

| RDBMS                                                      | Code                                                                      |
| ---------------------------------------------------------- | ------------------------------------------------------------------------- |
| <p>MySQL,</p><p>Oracle,</p><p>PostgreSQL,</p><p>SQLite</p> | `ALTER TABLE my_table RENAME COLUMN old_column_name TO new_column_name;`  |
| SQL Server                                                 | `EXEC sp_rename 'my_table.old_column_name', 'new_column_name', 'COLUMN';` |

### Display, Add, and Delete Columns

After you’ve created a table, you can view, add, and delete columns from the table.

#### Display the columns of a table

The code in [Table 5-12](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_display\_the\_columns\_of\_a\_table) shows how to display the columns of a table in each RDBMS.

| RDBMS                      | Code                                                                                |
| -------------------------- | ----------------------------------------------------------------------------------- |
| <p>MySQL,</p><p>Oracle</p> | `DESCRIBE my_table;`                                                                |
| PostgreSQL                 | `\d my_table`                                                                       |
| SQL Server                 | `SELECT column_name FROM information_schema.columns WHERE table_name = 'my_table';` |
| SQLite                     | `pragma table_info(my_table);`                                                      |

#### Add a column to a table

The code in [Table 5-13](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_add\_a\_column\_to\_a\_table) shows how to add a column to a table in each RDBMS.

| RDBMS                          | Code                                                                                                     |
| ------------------------------ | -------------------------------------------------------------------------------------------------------- |
| <p>MySQL,</p><p>PostgreSQL</p> | `ALTER TABLE my_table ADD new_num_column INTEGER, ADD new_text_column VARCHAR(30);`                      |
| Oracle                         | `ALTER TABLE my_table ADD ( new_num_column INTEGER, new_text_column VARCHAR(30));`                       |
| SQL Server                     | `ALTER TABLE my_table ADD new_num_column INTEGER, new_text_column VARCHAR(30);`                          |
| SQLite                         | `ALTER TABLE my_table ADD new_num_column INTEGER; ALTER TABLE my_table ADD new_text_column VARCHAR(30);` |

#### Delete a column from a table

The code in [Table 5-14](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_delete\_a\_column\_from\_a\_table) shows how to delete a column from a table in each RDBMS.

**NOTE**

If a column has any constraints, you must first [delete the constraints](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#delete\_a\_constraint) before deleting the column.

| RDBMS                          | Code                                                                                                                                                                       |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <p>MySQL,</p><p>PostgreSQL</p> | `ALTER TABLE my_table DROP COLUMN new_num_column, DROP COLUMN new_text_column;`                                                                                            |
| Oracle                         | <p><code>ALTER TABLE my_table DROP COLUMN new_num_column;</code></p><p><code>ALTER TABLE my_table DROP COLUMN new_text_column;</code></p>                                  |
| SQL Server                     | `ALTER TABLE my_table DROP COLUMN new_num_column, new_text_column;`                                                                                                        |
| SQLite                         | Refer to the [manual modifications steps for SQLite](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#manual\_modifications\_in\_sqlite) |

**MANUAL MODIFICATIONS IN SQLITE**

SQLite does not support some table modifications, such as deleting columns or adding/modifying/deleting constraints.

As a workaround, you can either use a [graphical user interface](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch02.html#database\_tools) to generate code to modify a table, or you can manually create a new table and copy over data (see following steps).

1.  Create a new table with the columns and constraints you want.

    ```
    CREATE TABLE my_table_2 (
       id INTEGER NOT NULL,
       country VARCHAR(2),
       name VARCHAR(30)
    );
    ```
2.  Copy data from the old table to the new table.

    ```
    INSERT INTO my_table_2
    SELECT id, country, name
    FROM my_table;
    ```
3.  Confirm that the data is in the new table.

    ```
    SELECT * FROM my_table_2;
    ```
4.  Delete the old table.

    ```
    DROP TABLE my_table;
    ```
5.  Rename the new table.

    ```
    ALTER TABLE my_table_2 RENAME TO my_table;
    ```

### Display, Add, and Delete Rows

After you’ve created a table, you can view, add, and delete rows from the table.

#### Display rows of a table

To display the rows of a table, simply write a `SELECT` statement:

```
SELECT * FROM my_table;
```

#### Add rows to a table

Use `INSERT INTO` to add rows of data to a table:

```
INSERT INTO my_table
   (id, country, name)
VALUES (9, 'US', 'Charlie');
```

#### Delete rows from a table

Use `DELETE FROM` to delete rows of data from a table:

```
DELETE FROM my_table
WHERE id = 9;
```

Omit the `WHERE` clause to remove all rows from a table:

```
DELETE FROM my_table;
```

Deleting rows from a table is also known as _truncating_, which removes all of the data in a table without changing the table definition. So while the column names and constraints of the table still exist, it is now empty.

To get rid of a table completely, you can [drop the table](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#delete\_a\_table).

### Display, Add, Modify, and Delete Constraints

A _constraint_ is a rule that specifies what data can be inserted into a table. More on the various types of constraints can be found earlier in this chapter in the [Create a Table with Constraints](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#create\_a\_table\_with\_constraints) section.

#### Display the constraints of a table

The code in [Table 5-15](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_display\_the\_constraints\_of\_a\_table) shows how to display the constraints of a table in each RDBMS.

| RDBMS                                                                                                                                                                                                           | Code                                                                                                                                                                     |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| MySQL                                                                                                                                                                                                           | `SHOW CREATE TABLE my_table;`                                                                                                                                            |
| Oracle                                                                                                                                                                                                          | `SELECT * FROM user_cons_columns WHERE table_name = 'MY_TABLE';`                                                                                                         |
| PostgreSQL                                                                                                                                                                                                      | `\d my_table`                                                                                                                                                            |
| SQL Server                                                                                                                                                                                                      | `-- List constraints (except default ones) SELECT table_name, constraint_name, constraint_type FROM information_schema.table_constraints WHERE table_name = 'my_table';` |
| `-- List all default constraints SELECT OBJECT_NAME(parent_object_id), COL_NAME(parent_object_id, parent_column_id), definition FROM sys.default_constraints WHERE OBJECT_NAME(parent_object_id) = 'my_table';` |                                                                                                                                                                          |
| SQLite                                                                                                                                                                                                          | `.schema my_table`                                                                                                                                                       |

**NOTE**

_Oracle_ stores table names and column names in all caps, unless you surround the column name with [double quotes](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch03.html#quotes). When referring to a table name or a column name in a SQL statement, you must write the name in all caps (`MY_TABLE`).

#### Add a constraint

Let’s start with the following `CREATE TABLE` statement:

```
CREATE TABLE my_table (
   id INTEGER NOT NULL,
   country VARCHAR(2) DEFAULT 'CA',
   name VARCHAR(15),
   lower_name VARCHAR(15)
);
```

The code in [Table 5-16](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_add\_a\_constraint) adds a constraint that makes sure that the `lower_name` column is a lowercase version of the `name` column in each RDBMS.

| RDBMS                                            | Code                                                                                                                                                                       |
| ------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <p>MySQL,</p><p>PostgreSQL,</p><p>SQL Server</p> | `ALTER TABLE my_table ADD CONSTRAINT chk_lower_name CHECK (lower_name = LOWER(name));`                                                                                     |
| Oracle                                           | `ALTER TABLE my_table ADD ( CONSTRAINT chk_lower_name CHECK (lower_name = LOWER(name)));`                                                                                  |
| SQLite                                           | Refer to the [manual modifications steps for SQLite](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#manual\_modifications\_in\_sqlite) |

#### Modify a constraint

Let’s start with the following `CREATE TABLE` statement:

```
CREATE TABLE my_table (
   id INTEGER NOT NULL,
   country VARCHAR(2) DEFAULT 'CA',
   name VARCHAR(15),
   lower_name VARCHAR(15)
);
```

The code in [Table 5-17](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_modify\_contraints\_in\_a\_table) modifies the following constraints:

* Changes the `country` column from defaulting to `CA` to defaulting to `NULL`
* Changes the `name` column from allowing 15 characters to allowing 30 characters

| RDBMS                                                      | Code                                                                                                                                                                       |
| ---------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| MySQL                                                      | `ALTER TABLE my_table MODIFY country VARCHAR(2) NULL, MODIFY name VARCHAR(30);`                                                                                            |
| Oracle                                                     | `ALTER TABLE my_table MODIFY ( country DEFAULT NULL, name VARCHAR2(30) );`                                                                                                 |
| PostgreSQL                                                 | `ALTER TABLE my_table ALTER country DROP DEFAULT, ALTER name TYPE VARCHAR(30);`                                                                                            |
| SQL Server                                                 | `ALTER TABLE my_table ALTER COLUMN country VARCHAR(2) NULL;`                                                                                                               |
| `ALTER TABLE my_table ALTER COLUMN name VARCHAR(30) NULL;` |                                                                                                                                                                            |
| SQLite                                                     | Refer to the [manual modifications steps for SQLite](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#manual\_modifications\_in\_sqlite) |

#### Delete a constraint

The code in [Table 5-18](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_delete\_a\_constraint\_from\_a\_table) shows how to delete a constraint from a table in each RDBMS.

| RDBMS                                             | Code                                                                                                                                                                       |
| ------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| MySQL                                             | `ALTER TABLE my_table DROP CHECK chk_lower_name;`                                                                                                                          |
| <p>Oracle,</p><p>PostgreSQL,</p><p>SQL Server</p> | `ALTER TABLE my_table DROP CONSTRAINT chk_lower_name;`                                                                                                                     |
| SQLite                                            | Refer to the [manual modifications steps for SQLite](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#manual\_modifications\_in\_sqlite) |

**NOTE**

In _MySQL_, `CHECK` can be replaced with `DEFAULT`, `INDEX` (for `UNIQUE` constraints), `PRIMARY KEY`, and `FOREIGN KEY`. To delete a `NOT NULL` constraint, you would [`MODIFY`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#modify\_a\_constraint) the constraint instead.

### Update a Column of Data

Use `UPDATE .. SET ..` to update the values in a column of data.

Here is a table:

```
SELECT *
FROM my_table;

id  country  name     awards
--- -------- -------- -------
  2 CA       Celine         5
  3 CA       Michael        4
  4 US       Stefani        9
```

Preview the change you’d like to make:

<pre><code><strong>SELECT LOWER(name)
</strong>FROM my_table;

LOWER(name)
------------
<strong>celine
</strong><strong>michael
</strong><strong>stefani
</strong></code></pre>

Update the values in a column of data:

<pre><code>UPDATE my_table
<strong>SET name = LOWER(name);
</strong>
SELECT * FROM my_table;



id  country  name     awards
--- -------- -------- -------
<strong>  2 CA       celine         5
</strong><strong>  3 CA       michael        4
</strong><strong>  4 US       stefani        9
</strong></code></pre>

### Update Rows of Data

Use `UPDATE .. SET .. WHERE ..` to update values in a row or multiple rows of data.

Here is a table:

```
SELECT *
FROM my_table;

id  country  name     awards
--- -------- -------- -------
  2 CA       Celine         5
  3 CA       Michael        4
  4 US       Stefani        9
```

Preview the change you’d like to make:

<pre><code><strong>SELECT awards + 1
</strong>FROM my_table
<strong>WHERE country = 'CA';
</strong>
awards + 1
-----------
<strong>          6
</strong><strong>          5
</strong></code></pre>

Update the values in multiple rows of data:

<pre><code>UPDATE my_table
<strong>SET awards = awards + 1
</strong><strong>WHERE country = 'CA';
</strong>
SELECT * FROM my_table;

id  country  name     awards
--- -------- -------- -------
<strong>  2 CA       Celine         6
</strong><strong>  3 CA       Michael        5
</strong>  4 US       Stefani        9
</code></pre>

**WARNING**

It is very important to include a `WHERE` clause along with the `SET` clause when you are updating specific rows of data. Without the `WHERE` clause, the entire table would be updated.

### Update Rows of Data with the Results of a Query

Instead of manually typing values to update a table, you can set a new value based on the results of a query.

Here is a table:

```
SELECT * FROM my_table;

id  country  name     awards
--- -------- -------- -------
  2 CA       Celine         5
  3 CA       Michael        4
  4 US       Stefani        9
```

Preview the change you’d like to make:

<pre><code><strong>SELECT MIN(awards) FROM my_table;
</strong>
MIN(awards)
------------
<strong>           4
</strong></code></pre>

Update values based on a query:

<pre><code>UPDATE my_table
<strong>SET awards = (SELECT MIN(awards) FROM my_table)
</strong>WHERE country = 'CA';

SELECT * FROM my_table;

id  country  name     awards
--- -------- -------- -------
<strong>  2 CA       Celine         4
</strong><strong>  3 CA       Michael        4
</strong>  4 US       Stefani        9
</code></pre>

**NOTE**

_MySQL_ does not allow you to update a table with a query on the same table. In the preceding example, you cannot have `UPDATE my_table` and `FROM my_table`. The statement will run if you query `FROM another_table`.

The results of the query must always return one column and either zero or one row. If zero rows are returned, then the value is set to `NULL`.

### Delete a Table

When you no longer need a table, you can delete it using a `DROP TABLE` statement:

```
DROP TABLE my_table;
```

In _MySQL_, _PostgreSQL_, _SQL Server_, and _SQLite_, you can also add `IF EXISTS` to avoid an error message if the table doesn’t exist:

```
DROP TABLE IF EXISTS my_table;
```

**WARNING**

If you drop a table, you will lose all of the data in the table. _There is no undo_, unless there has been a backup created. I recommend not running this command unless you are 100% sure you don’t need the table.

#### Delete a table with foreign key references

If other tables have foreign keys that reference the table you are dropping, you will need to delete the foreign key constraints in the other tables along with the table you are dropping.

The code in [Table 5-19](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_delete\_a\_table\_with\_foreign\_key\_references) shows how to delete a table with foreign key references in each RDBMS.

| RDBMS                                        | Code                                                                                                                                                                                                                                                   |
| -------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Oracle                                       | `DROP TABLE my_table CASCADE CONSTRAINTS;`                                                                                                                                                                                                             |
| PostgreSQL                                   | `DROP TABLE my_table CASCADE;`                                                                                                                                                                                                                         |
| <p>MySQL,</p><p>SQL Server,</p><p>SQLite</p> | There is no `CASCADE` keyword, so you must manually [delete](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#delete\_a\_constraint) any foreign key constraints that reference the table before dropping the table. |

**WARNING**

It is dangerous to use `CASCADE` without knowing exactly what you are deleting. Please proceed with caution. I recommend not running this command unless you are 100% sure you don’t need the constraints.”

## Indexes

Imagine you have a table with 10 million rows. You write a query on the table to return values that were logged on `2021-01-01`:

```
SELECT *
FROM my_table
WHERE log_date = '2021-01-01';
```

This query would take a long time to run. The reason is because behind the scenes, every single row is checked to see if the `log_date` matches `2021-01-01` or not. That is 10 million checks.

To speed this up, you could create an _index_ on the `log_date` column. This is something you would do one time, and all future queries could benefit from it.

### Book Index Versus SQL Index Comparison

To better understand how a SQL index works, it’s helpful to use an analogy. [Table 5-20](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#book\_index\_vs\_sql\_index\_comparison\_table) compares the index at the end of this book with an index in a SQL table.

|                   | Book                                                                                                                                             | SQL Table                                                                                                                                                   |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Terms             | <p>A book has many <em>pages</em>.</p><p>Each page has <em>attributes</em> including the word count, concepts covered, etc.</p>                  | <p>A table has many <em>rows</em>.</p><p>Each row has <em>columns</em>, including <code>customer_id</code>, <code>log_date</code>, etc.</p>                 |
| Scenario          | You are reading this book and want to find all pages about the concept _subqueries_.                                                             | You are querying a table and want to find all rows where the `log_date` is `2021-01-01`.                                                                    |
| The slow approach | You could start from page 1 and flip through every page of this book to see if _subqueries_ are mentioned or not. This would take a long time.   | You could start from row 1 and scan through every row to see whether the `log_date` is `2021-01-01` or not. This would take a long time.                    |
| Create an index   | An index was created for all concepts in this book. Each concept is listed in the index along with the page numbers that talk about the concept. | An index was created on the `log_date` column in the table. Every `log_date` is listed in the index along with the row numbers that contain the `log_date`. |
| The fast approach | To find pages about _subqueries_, you can go to the index to quickly find the page numbers that reference _subqueries_ and go to those pages.    | To find rows with a `log_date` of `2021-01-01`, your query uses the index to quickly find the row numbers that contain the date and return those rows.      |

When the same query is run on `my_table` (that now has the `log_date` column indexed):

```
SELECT *
FROM my_table
WHERE log_date = '2021-01-01';
```

the query will run much faster because instead of checking each row in the table, it sees the `log_date` of `2021-01-01`, goes to the index, and quickly pulls all rows that have that `log_date`.

**TIP**

It’s a good idea to create an index on a few columns that you filter on often. For example, the primary key column, the date column, etc.

You wouldn’t want to create an index for too many columns, though, because it does take up space. Also, any time rows are added or removed, the index would need to be rebuilt, which is time consuming.

### Create an Index to Speed Up Queries

The following code creates a new index called `my_index` on the `log_date` column in the `my_table` table:

```
CREATE INDEX my_index ON my_table (log_date);
```

**NOTE**

When creating an index in _Oracle_, you must uppercase the column name and surround it in quotes:

```
CREATE INDEX my_index ON my_table
  ('LOG_DATE');
```

Oracle automatically creates an index for `PRIMARY KEY` and `UNIQUE` columns when a table is created.

Indexes can take a long time to create. However, it’s a one-time task that’s worth it in the long run for many faster queries in the future.

You can also create a multicolumn index or a _composite index_. The following code creates an index on two columns: `log_date` and `team`:

```
CREATE INDEX my_index ON my_table (log_date, team);
```

The order of the columns matters here. If you write a query that filters on:

* Both columns: the index will make the query fast
* The first column (`log_date`): the index will make the query fast
* The second column (`team`): the index will not help because it first organizes data by the `log_date` and then the `team` column

**NOTE**

You need CREATE privileges to create an index. If you get an error when running the preceding code, you do not have the permission to do so and need to talk to your database administrator.

#### Delete an index

The code in [Table 5-21](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_delete\_an\_index) shows how to delete an index in each RDBMS.

| RDBMS                      | Code                               |
| -------------------------- | ---------------------------------- |
| MySQL, SQL Server          | `DROP INDEX my_index ON my_table;` |
| Oracle, PostgreSQL, SQLite | `DROP INDEX my_index;`             |

**WARNING**

Dropping an index cannot be undone. Be 100% sure you want to delete an index before dropping it.

On the bright side, there is no data loss. The data in the table is untouched, and you can always recreate the index.

## Views

Imagine you have a long and complex SQL query that includes many joins, filters, aggregations, etc. The results of the query are useful to you and something that you want to reference again at a later point.

This is a great situation to create a _view_, or give a name to the output of a query. Remember that the output of a query is a single table, so a view looks just like a table. The difference is that the view doesn’t actually hold any data like a table, but just references the data instead.

**NOTE**

Sometimes database adminstrators (DBAs) will create views to restrict access to tables. Imagine there is a `customer` table. Most people should only be able to read the data in the table, and not make changes to it.

The DBA can create a `customer` view that includes data identical to the `customer` table. Now, everyone can query the `customer` _view_, and only the DBA would be able to edit the data within the `customer` _table_.

The following code is a complex query that we don’t want to write over and over again:

```
-- Number of waterfalls owned by each owner
SELECT o.id, o.name,
       COUNT(w.id) AS num_waterfalls
FROM owner o LEFT JOIN waterfall w
     ON o.id = w.owner_id
GROUP BY o.id, o.name;

id    name             num_waterfalls
----- ---------------- ---------------
    1 Pictured Rocks                 3
    2 Michigan Nature                3
    3 AF LLC                         1
    4 MI DNR                         1
    5 Horseshoe Falls                0
```

Let’s say that we want to find the average number of waterfalls that an owner owns. We could do this using either a subquery or a view:

<pre><code><strong>-- Subquery Approach
</strong><strong>SELECT AVG(num_waterfalls) FROM
</strong>(SELECT o.id, o.name,
        COUNT(w.id) AS num_waterfalls
FROM owner o LEFT JOIN waterfall w
     ON o.id = w.owner_id
<strong>GROUP BY o.id, o.name) my_subquery;
</strong>
AVG(num_waterfalls)
--------------------
                 1.6
</code></pre>

<pre><code><strong>-- View Approach
</strong><strong>CREATE VIEW owner_waterfalls_vw AS
</strong>SELECT o.id, o.name,
       COUNT(w.id) AS num_waterfalls
FROM owner o LEFT JOIN waterfall w
     ON o.id = w.owner_id
GROUP BY o.id, o.name;

<strong>SELECT AVG(num_waterfalls)
</strong><strong>  FROM owner_waterfalls_vw;
</strong>
AVG(num_waterfalls)
--------------------
                 1.6
</code></pre>

**NOTE**

You need CREATE privileges to create a view. If you get an error when running the preceding code, you do not have the permission to do so and need to talk to your database administrator.

**SUBQUERIES VERSUS VIEWS**

Both subqueries and views represent the results of a query, which can then go on to be queried themselves.

* A _subquery_ is temporary. It only exists for the duration of the query and is great for one-time use.
* A _view_ is saved. Once a view is created, you can continue to write queries that reference the view.

### Create a View to Save the Results of a Query

Use `CREATE VIEW` to save the results of a query as a view. The view can then be queried, just like a table.

Using this query:

```
SELECT *
FROM my_table
WHERE country = 'US';

id  country  name
--- -------- ------
  1 US       Anna
  2 US       Emily
  3 US       Molly
```

Create a view:

```
CREATE VIEW my_view AS
SELECT *
FROM my_table
WHERE country = 'US';
```

Query the view:

```
SELECT * FROM my_view;

id  country  name
--- -------- ------
  1 US       Anna
  2 US       Emily
  3 US       Molly
```

#### Display existing views

The code in [Table 5-22](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_display\_existing\_views) shows how to display all existing views in each RDBMS.

| RDBMS      | Code                                                                                                              |
| ---------- | ----------------------------------------------------------------------------------------------------------------- |
| MySQL      | `SHOW FULL TABLES WHERE table_type = 'VIEW';`                                                                     |
| Oracle     | `SELECT view_name FROM user_views;`                                                                               |
| PostgreSQL | `SELECT table_name FROM information_schema.views WHERE table_schema NOT IN ('information_schema', 'pg_catalog');` |
| SQL Server | `SELECT table_name FROM information_schema.views;`                                                                |
| SQLite     | `SELECT name FROM sqlite_master WHERE type = 'view';`                                                             |

#### Update a view

To update a view is another way of saying to overwrite a view. The code in [Table 5-23](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#code\_to\_update\_a\_view) shows how to update a view in each RDBMS.

| RDBMS                                        | Code                                                                                               |
| -------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| <p>MySQL,</p><p>Oracle,</p><p>PostgreSQL</p> | `CREATE OR REPLACE VIEW my_view AS SELECT * FROM my_table WHERE country = 'CA';`                   |
| SQL Server                                   | `CREATE OR ALTER VIEW my_view AS SELECT * FROM my_table WHERE country = 'CA';`                     |
| SQLite                                       | `DROP VIEW IF EXISTS my_view; CREATE VIEW my_view AS SELECT * FROM my_table WHERE country = 'CA';` |

#### Delete a view

When you no longer need a view, you can delete it using a `DROP VIEW` statement:

```
DROP VIEW my_view;
```

**WARNING**

Dropping a view cannot be undone. Be 100% sure you want to delete a view before dropping it.

On the bright side, there is no data loss. The data is still in the original table, and you can always recreate the view.

## Transaction Management

A _transaction_ allows you to more safely update a database. It consists of a sequence of operations that are executed as a single unit. Either all of the operations are executed or none of them are, which is also known as _atomicity_.

The following code kicks off a transaction before making any changes to the tables. After the statements are run, no updates are permanently made to the database until the changes are committed:

<pre><code><strong>START TRANSACTION;
</strong>
<strong>INSERT INTO page_views (user_id, page)
</strong>   VALUES (525, 'home');
<strong>INSERT INTO page_views (user_id, page)
</strong>   VALUES (525, 'contact us');
<strong>DELETE FROM new_users WHERE user_id = 525;
</strong><strong>UPDATE page_views SET page = 'request info'
</strong>   WHERE page = 'contact us';

<strong>COMMIT;
</strong></code></pre>

**WHY IS IT SAFER TO USE A TRANSACTION?**

After starting a transaction:

All four statements are treated as one unit.

Imagine you run the first three statements, and while you’re doing that, someone else edits the database in a way that your fourth statement doesn’t run. This is problematic because for you to update the database properly, all four statements need to run together. The transaction does just that—it requires all four statements to act as one unit, so either all of them run or none of them run.

You can undo your changes if needed.

After starting the transaction, you can run each of the statements and see how they would affect the tables. If everything looks right, you can end the transaction and lock in your changes with a `COMMIT`. If something looks wrong and you want to return things back to the way they were before the transaction, you can do so with a [`ROLLBACK`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#undo\_changes\_with\_a\_rollback).

In general, if you are updating a database, it is good practice to use a transaction.

The following sections cover two scenarios in which using a transaction is helpful—one ending in a `COMMIT` to confirm changes and the other ending in a `ROLLBACK` to undo changes.

### Double-Check Changes Before a COMMIT

Imagine you want to delete some rows of data, but you want to double-check that the correct rows are going to get deleted before you permanently remove them from the table.

The following code shows the step-by-step process for how you would use a transaction in SQL to do so.

1.  Start a transaction.

    <pre><code>
    -- MySQL and PostgreSQL
    <strong>START TRANSACTION;
    </strong>or
    <strong>BEGIN;
    </strong>
    -- SQL Server and SQLite
    <strong>BEGIN TRANSACTION;
    </strong></code></pre>

    In _Oracle_, you are essentially always in a transaction. A transaction begins when you execute your first SQL statement. After a transaction has ended (with a `COMMIT` or `ROLLBACK`), another one begins when the next SQL statement is executed.
2.  View the table you plan to change.

    You are in transaction mode at this point, meaning no changes will be made to the database.

    <pre><code>
    <strong>SELECT * FROM books;
    </strong>
    +------+--------------+
    | id   | title        |
    +------+--------------+
    |    1 | Becoming     |
    |    2 | Born a Crime |
    |    3 | Bossypants   |
    +------+--------------+
    </code></pre>
3.  Test the change and see how it affects the table.

    You want to delete all multiword book titles. The following `SELECT` statement lets you view all the multiword book titles in the table.

    <pre><code>
    <strong>SELECT * FROM books WHERE title LIKE '% %';
    </strong>
    +------+--------------+
    | id   | title        |
    +------+--------------+
    |    2 | Born a Crime |
    +------+--------------+
    </code></pre>

    The following `DELETE` statement uses the same `WHERE` clause to now delete the multiword book titles in the table.

    <pre><code>
    <strong>DELETE FROM books WHERE title LIKE '% %';
    </strong>
    <strong>SELECT * FROM books;
    </strong>
    +------+--------------+
    | id   | title        |
    +------+--------------+
    |    1 | Becoming     |
    |    3 | Bossypants   |
    +------+--------------+
    </code></pre>

    You are still in transaction mode at this point, so the change has not been made permanent.
4.  Confirm the change with `COMMIT`.

    Use `COMMIT` to lock in the changes. After this step, you are no longer in transaction mode.

    <pre><code>
    <strong>COMMIT;
    </strong></code></pre>

**WARNING**

You cannot undo (aka rollback) a transaction once it has been committed.

### Undo Changes with a ROLLBACK

Transactions are especially useful to test out changes and undo them if necessary.

1.  Start a transaction.

    <pre><code>
    -- MySQL and PostgreSQL
    <strong>START TRANSACTION;
    </strong>or
    <strong>BEGIN;
    </strong>
    -- SQL Server and SQLite
    <strong>BEGIN TRANSACTION;
    </strong></code></pre>

    In _Oracle_, you are essentially always in a transaction. A transaction begins when you execute your first SQL statement. After a transaction has ended (with a `COMMIT` or `ROLLBACK`), another one begins when the next SQL statement is executed.
2.  View the table you plan to change.

    You are in transaction mode at this point, meaning no changes will be made to the database.

    <pre><code>
    <strong>SELECT * FROM books;
    </strong>
    +------+--------------+
    | id   | title        |
    +------+--------------+
    |    1 | Becoming     |
    |    2 | Born a Crime |
    |    3 | Bossypants   |
    +------+--------------+
    </code></pre>
3.  Test the change and see how it affects the table.

    You want to delete all multiword book titles. The following `DELETE` statement accidentally deletes the entire table (you’ve forgotten a space in `'%%'`). You didn’t want this to happen!

    <pre><code>
    <strong>DELETE FROM books WHERE title LIKE '%%';
    </strong>
    <strong>SELECT * FROM books;
    </strong>
    +------+--------------+
    | id   | title        |
    +------+--------------+
    </code></pre>

    It’s a good thing you’re still in transaction mode at this point, so the change has not been made permanent.
4.  Undo the change with `ROLLBACK`.

    Instead of `COMMIT`, `ROLLBACK` the changes. The table will not be deleted. After this step, you are no longer in transaction mode and can continue on with your other statements.

    <pre><code>
    <strong>ROLLBACK;
    </strong></code></pre>
