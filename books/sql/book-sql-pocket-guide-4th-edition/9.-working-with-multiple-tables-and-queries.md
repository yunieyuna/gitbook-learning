# 9. Working With Multiple Tables And Queries

## Chapter 9. Working with Multiple Tables and Queries

This chapter covers how to bring together multiple tables by either joining them or using union operators, and also how to work with multiple queries using common table expressions.

[Table 9-1](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#working\_with\_multiple\_tables\_and\_queries\_table) includes descriptions and code examples of the three concepts covered in this chapter.

| Concept                                                                                                                                   | Description                                                                                                                  | Code Example                                                                                                                                                                         |
| ----------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [Joining Tables](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#joining\_tables)                      | Combine the columns of two tables based on matching rows.                                                                    | <pre><code>SELECT c.id, l.city
FROM customers c
<strong>  INNER JOIN loc l
</strong><strong>  ON c.lid = l.id;
</strong></code></pre>                                                |
| [Union Operators](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#union\_operators)                    | Combine the rows of two tables based on matching columns.                                                                    | <pre><code>SELECT name, city
FROM employees;
<strong>UNION
</strong>SELECT name, city
FROM customers;
</code></pre>                                                                  |
| [Common Table Expressions](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#common\_table\_expressions) | Temporarily save the output of a query, for another query to reference it. Also includes recursive and hierarchical queries. | <pre><code><strong>WITH my_cte AS (
</strong>  SELECT name,
    SUM(order_id)
    AS num_orders
  FROM customers
  GROUP BY name)

SELECT MAX(num_orders)
FROM my_cte;
</code></pre> |

## Joining Tables

In SQL, _joining_ means combining data from multiple tables together within a single query. The following two tables list the state a person lives in and the pets they own:

```
-- states            -- pets
+------+-------+    +------+------+
| name | state |    | name | pet  |
+------+-------+    +------+------+
| Ada  | AZ    |    | Deb  | dog  |
| Deb  | DE    |    | Deb  | duck |
+------+-------+    | Pat  | pig  |
                    +------+------+
```

Use the `JOIN` clause to join the two tables into one table:

<pre><code>SELECT *
<strong>FROM states s INNER JOIN pets p
</strong><strong>     ON s.name = p.name;
</strong>
+------+-------+------+------+
| name | state | name | pet  |
+------+-------+------+------+
| Deb  | DE    | Deb  | dog  |
| Deb  | DE    | Deb  | duck |
+------+-------+------+------+
</code></pre>

The resulting table only includes rows for `Deb` since she is present in both tables.

The left two columns are from the `states` table and the right two are from the `pets` table. The columns in the output can be referenced using the aliases `s.name`, `s.state`, `p.name`, and `p.pet`.

**BREAKING DOWN THE JOIN CLAUSE**

```
states s INNER JOIN pets p ON s.name = p.name
```

Tables (`states`, `pets`)

The tables we would like to combine.

Aliases (`s`, `p`)

These are nicknames for the tables. This is optional, but recommended for simplicity. Without aliases, the `ON` clause could be written as `states.name = pets.name`.

Join Type (`INNER JOIN`)

The `INNER` portion specifies that only matching rows should be returned. If only `JOIN` is written, then it defaults to an `INNER JOIN`. Other join types can be found in [Table 9-2](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#ways\_to\_join\_together\_tables).

Join Condition (`ON s.name = p.name`)

The condition that must be true in order for two rows to be considered matching. Equal (`=`) is the most common operator, but others can be used as well including not equal (`!=` or `<>`), `>`, `<`, `BETWEEN`, etc.

In addition to the `INNER JOIN`, [Table 9-2](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#ways\_to\_join\_together\_tables) lists the various types of joins in SQL. The following query shows the general format for joining tables together:

<pre><code>SELECT *
<strong>FROM states s [JOIN_TYPE] pets p
</strong>     ON s.name = p.name;
</code></pre>

Replace the bolded `[JOIN_TYPE]` portion with the keywords in the Keyword column to get the results shown in the Resulting Rows column. For the `CROSS JOIN` join type, exclude the `ON` clause to get the results shown in the table.

| Keyword                                                                                                                   | Description                                                                   | Resulting Rows                                                                                                                                                                                              |
| ------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `JOIN`                                                                                                                    | Defaults to an `INNER JOIN`.                                                  | <pre><code> nm  | st | nm  | pt
-----+----+-----+------
 Deb | DE | Deb | dog
 Deb | DE | Deb | duck
</code></pre>                                                                                          |
| [`INNER JOIN`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#inner\_join)            | Returns the rows in common.                                                   | <pre><code> nm  | st | nm  | pt
-----+----+-----+------
 Deb | DE | Deb | dog
 Deb | DE | Deb | duck
</code></pre>                                                                                          |
| [`LEFT JOIN`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#left\_join)              | Returns the rows in the left table and the matching rows in the other table.  | <pre><code> nm  | st | nm   | pt
-----+----+------+------
 Ada | AZ | NULL | NULL
 Deb | DE | Deb  | dog
 Deb | DE | Deb  | duck
</code></pre>                                                              |
| [`RIGHT JOIN`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#right\_join)            | Returns the rows in the right table and the matching rows in the other table. | <pre><code> nm   | st   | nm  | pt
------+------+-----+------
 Deb  | DE   | Deb | dog
 Deb  | DE   | Deb | duck
 NULL | NULL | Pat | pig
</code></pre>                                                     |
| [`FULL OUTER JOIN`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#full\_outer\_join) | Returns the rows in both tables.                                              | <pre><code> nm   | st   | nm   | pt
------+------+------+------
 Ada  | AZ   | NULL | NULL
 Deb  | DE   | Deb  | dog
 Deb  | DE   | Deb  | duck
 NULL | NULL | Pat  | pig
</code></pre>                     |
| [`CROSS JOIN`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#cross\_join)            | Returns all combinations of rows in the two tables.                           | <pre><code> nm  | st | nm  | pt
-----+----+-----+------
 Ada | AZ | Deb | dog
 Ada | AZ | Deb | duck
 Ada | AZ | Pat | pig
 Deb | DE | Deb | dog
 Deb | DE | Deb | duck
 Deb | DE | Pat | pig
</code></pre> |

In addition to joining tables using the standard `JOIN ... ON ...` syntax, [Table 9-3](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#syntax\_join\_together\_tables) lists others ways to join tables in SQL.

| Type                                                                                                                        | Description                                                                                                           | Code                                                                                                                                                                            |
| --------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [`JOIN ... ON ...` Syntax](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#join\_basics) | Most common join syntax that works with `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL OUTER JOIN`, and `CROSS JOIN`. | `SELECT * FROM states s`` `**`INNER JOIN`**` ``pets p`` `**`ON`**` ``s.name = p.name;`                                                                                          |
| [`USING` Shortcut](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#using)                | Use `USING` instead of the `ON` clause if the names of the columns that you are joining on match.                     | `SELECT * FROM states INNER JOIN pets`` `**`USING (name)`**`;`                                                                                                                  |
| [`NATURAL JOIN` Shortcut](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#natural\_join) | Use `NATURAL JOIN` instead of `INNER JOIN` if the names of all of the columns that you are joining on match.          | `SELECT * FROM states`` `**`NATURAL JOIN`**` ``pets;`                                                                                                                           |
| [Old Join Syntax](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#join\_basics)          | Return all the combinations of the rows in two tables. Equivalent to a `CROSS JOIN`.                                  | `SELECT * FROM`` `**`states s, pets p`**` ``WHERE s.name = p.name;`                                                                                                             |
| [Self Join](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#self\_join)                  | Use either the old join or new join syntax to return all the combinations of the rows in a table with itself.         | `SELECT * FROM`` `**`states s1, states s2`**` ``WHERE s1.region = s2.region; SELECT * FROM`` `**`states s1`**` ``INNER JOIN`` `**`states s2`**` ``WHERE s1.region = s2.region;` |

The following sections describe the concepts in Tables [9-2](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#ways\_to\_join\_together\_tables) and [9-3](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#syntax\_join\_together\_tables) in detail.

### Join Basics and INNER JOIN

This section walks through how a join works conceptually, as well as the basic join syntax using an `INNER JOIN`.

#### Join basics

You can think of joining tables in two steps:

1. Display all combinations of rows in the tables.
2. Filter on the rows that have matching values.

Here are two tables we’d like to join:

```
-- states            -- pets
+------+-------+    +------+------+
| name | state |    | name | pet  |
+------+-------+    +------+------+
| Ada  | AZ    |    | Deb  | dog  |
| Deb  | DE    |    | Deb  | duck |
+------+-------+    | Pat  | pig  |
                    +------+------+
```

Step 1: Display all combinations of rows.

By listing the table names in the `FROM` clause, all possible combinations of rows from the two tables are returned.

<pre><code>SELECT *
<strong>FROM states, pets;
</strong>
+------+-------+------+------+
| name | state | name | pet  |
+------+-------+------+------+
| Ada  | AZ    | Deb  | dog  |
| Deb  | DE    | Deb  | dog  |
| Ada  | AZ    | Deb  | duck |
| Deb  | DE    | Deb  | duck |
| Ada  | AZ    | Pat  | pig  |
| Deb  | DE    | Pat  | pig  |
+------+-------+------+------+
</code></pre>

The `FROM states, pets` syntax is an older way of doing a join in SQL. A more modern way of doing the same thing is using a [`CROSS JOIN`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#cross\_join).

Step 2: Filter on the rows that have matching names.

You likely don’t want to display all combinations of rows in the two tables, but rather only situations where the `name` column of both tables match.

<pre><code>SELECT *
FROM states s, pets p
<strong>WHERE s.name = p.name;
</strong>
+------+-------+------+------+
| name | state | name | pet  |
+------+-------+------+------+
| Deb  | DE    | Deb  | dog  |
| Deb  | DE    | Deb  | duck |
+------+-------+------+------+
</code></pre>

The row `Deb`/`DE` is listed twice because it matched two `Deb` values in the `pets` table.

The preceding code is equivalent to an [`INNER JOIN`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#inner\_join).

**NOTE**

The two-step process described previously is purely conceptual. Databases will rarely do a cross join when executing a join, but instead do it in a more optimized way.

However, thinking in these conceptual terms will help you correctly write join queries and understand their results.

#### INNER JOIN

The most common way to join together two tables is using an `INNER JOIN`, which returns rows that are in both tables.

Use `INNER JOIN` to only return people in both tables

<pre><code>SELECT *
<strong>FROM states s INNER JOIN pets p
</strong><strong>     ON s.name = p.name;
</strong>


+------+-------+------+------+
| name | state | name | pet  |
+------+-------+------+------+
| Deb  | DE    | Deb  | dog  |
| Deb  | DE    | Deb  | duck |
+------+-------+------+------+
</code></pre>

Join together more than two tables

This can be done by including additional sets of the `JOIN .. ON ..` keywords:

<pre><code>SELECT *
FROM states s
<strong>     INNER JOIN pets p
</strong><strong>        ON s.name = p.name
</strong><strong>     INNER JOIN lunch l
</strong><strong>        ON s.name = l.name;
</strong></code></pre>

Join on more than one column

This can be done by including additional conditions within the `ON` clause. Imagine you want to join the following tables on both `name` and `age`:

```
-- states_ages            -- pets_ages
+------+-------+-----+    +------+-----+-----+
| name | state | age |    | name | pet | age |
+------+-------+-----+    +------+-----+-----+
| Ada  | AK    |  25 |    | Ada  | ant |  30 |
| Ada  | AZ    |  30 |    | Pat  | pig |  45 |
+------+-------+-----+    +------+-----+-----+
```

<pre><code>SELECT *
FROM states_ages s INNER JOIN pets_ages p
<strong>     ON s.name = p.name
</strong><strong>     AND s.age = p.age;
</strong>
+------+-------+------+------+------+------+
| name | state | age  | name | pet  | age  |
+------+-------+------+------+------+------+
| Ada  | AZ    |   30 | Ada  | ant  |   30 |
+------+-------+------+------+------+------+
</code></pre>

### LEFT JOIN, RIGHT JOIN, and FULL OUTER JOIN

Use `LEFT JOIN`, `RIGHT JOIN`, and `FULL OUTER JOIN` to bring together rows from two tables, including ones that don’t appear in both tables.

#### LEFT JOIN

Use `LEFT JOIN` to return all people in the `states` table. People in the `states` table that are not in the `pets` table get returned with `NULL` values.

<pre><code>SELECT *
<strong>FROM states s LEFT JOIN pets p
</strong>     ON s.name = p.name;

+------+-------+------+------+
| name | state | name | pet  |
+------+-------+------+------+
<strong>| Ada  | AZ    | NULL | NULL |
</strong>| Deb  | DE    | Deb  | dog  |
| Deb  | DE    | Deb  | duck |
+------+-------+------+------+
</code></pre>

A `LEFT JOIN` is equivalent to a `LEFT OUTER JOIN`.

#### RIGHT JOIN

Use `RIGHT JOIN` to return all people in the `pets` table. People in the `pets` table that are not in the `states` table get returned with `NULL` values.

<pre><code>SELECT *
<strong>FROM states s RIGHT JOIN pets p
</strong>     ON s.name = p.name;

+------+-------+------+------+
| name | state | name | pet  |
+------+-------+------+------+
| Deb  | DE    | Deb  | dog  |
| Deb  | DE    | Deb  | duck |
<strong>| NULL | NULL  | Pat  | pig  |
</strong>+------+-------+------+------+
</code></pre>

A `RIGHT JOIN` is equivalent to a `RIGHT OUTER JOIN`.

_SQLite_ does not support `RIGHT JOIN`.

**TIP**

The `LEFT JOIN` is much more common than the `RIGHT JOIN`. If a `RIGHT JOIN` is needed, swap the two tables within the `FROM` clause and do a `LEFT JOIN` instead.

#### FULL OUTER JOIN

Use `FULL OUTER JOIN` to return all people in both the `states` and `pets` tables. Missing values from both tables are returned with `NULL` values.

<pre><code>SELECT *
<strong>FROM states s FULL OUTER JOIN pets p
</strong>     ON s.name = p.name;

+------+-------+------+------+
| name | state | name | pet  |
+------+-------+------+------+
<strong>| Ada  | AZ    | NULL | NULL |
</strong>| Deb  | DE    | Deb  | dog  |
| Deb  | DE    | Deb  | duck |
<strong>| NULL | NULL  | Pat  | pig  |
</strong>+------+-------+------+------+
</code></pre>

A `FULL OUTER JOIN` is equivalent to a `FULL JOIN`.

_MySQL_ and _SQLite_ do not support `FULL OUTER JOIN`.

### USING and NATURAL JOIN

When joining tables together, to save on typing, you can use the `USING` or `NATURAL JOIN` shortcutsinstead of the standard `JOIN .. ON ..` syntax.

#### USING

_MySQL_, _Oracle_, _PostgreSQL_, and _SQLite_ support the `USING` clause.

You can use the `USING` shortcut in place of the `ON` clause to join on two columns of the exact same name. The join must be an equi-join (`=` in the `ON` clause) to use `USING`.

<pre><code>-- ON clause
SELECT *
FROM states s INNER JOIN pets p
<strong>     ON s.name = p.name;
</strong>
+------+-------+------+------+
| name | state | name | pet  |
+------+-------+------+------+
| Deb  | DE    | Deb  | dog  |
| Deb  | DE    | Deb  | duck |
+------+-------+------+------+

-- Equivalent USING shortcut
SELECT *
FROM states INNER JOIN pets
<strong>     USING (name);
</strong>
+------+-------+------+
| name | state | pet  |
+------+-------+------+
| Deb  | DE    | dog  |
| Deb  | DE    | duck |
+------+-------+------+
</code></pre>

The difference between the two queries is that the first query returns four columns including `s.name` and `p.name`, while the second query returns three columns because the two `name` columns get merged together as one and is simply called `name`.

#### NATURAL JOIN

_MySQL_, _Oracle_, _PostgreSQL_, and _SQLite_ support a `NATURAL JOIN`.

You can use the `NATURAL JOIN` shortcut in place of the `INNER JOIN .. ON ..` syntax to join two tables based on all columns of the exact same name. The join must be an equi-join (`=` in the `ON` clause) to use a `NATURAL JOIN`.

<pre><code>-- INNER JOIN ... ON ... AND ...
SELECT *
<strong>FROM states_ages s INNER JOIN pets_ages p
</strong><strong>     ON s.name = p.name
</strong><strong>     AND s.age = p.age;
</strong>
+------+-------+------+------+------+------+
| name | state | age  | name | pet  | age  |
+------+-------+------+------+------+------+
| Ada  | AZ    |   30 | Ada  | ant  |   30 |
+------+-------+------+------+------+------+

-- Equivalent NATURAL JOIN shortcut
SELECT *
<strong>FROM states_ages NATURAL JOIN pets_ages;
</strong>
+------+------+-------+------+
| name | age  | state | pet  |
+------+------+-------+------+
| Ada  |   30 | AZ    | ant  |
+------+------+-------+------+
</code></pre>

The difference between the two queries is that the first query returns six columns including `s.name`, `s.age`, `p.name`, and `p.age`, while the second query returns four columns because the duplicate `name` and `age` columns get merged together and are simply called `name` and `age`.

**WARNING**

Be careful when using a `NATURAL JOIN`. It saves quite a bit of typing, but can do an unexpected join if a column of a matching name is added or removed from a table. It is better to use for quick queries versus production code.

### CROSS JOIN and Self Join

Another way of joining tables together is by displaying all combinations of the rows in two tables. This can be done with a `CROSS JOIN`. If this is done on a table with itself, it is called a _self join_. A self join is useful when you want to compare rows within the same table.

#### CROSS JOIN

Use `CROSS JOIN` to return all combinations of the rows in two tables. It is equivalent to listing out the tables in the `FROM` clause (which is sometimes referred to as “old join syntax”).

<pre><code>-- CROSS JOIN
SELECT *
<strong>FROM states CROSS JOIN pets;
</strong>
-- Equivalent table list
SELECT *
<strong>FROM states, pets;
</strong>
+------+-------+------+------+
| name | state | name | pet  |
+------+-------+------+------+
| Ada  | AZ    | Deb  | dog  |
| Deb  | DE    | Deb  | dog  |
| Ada  | AZ    | Deb  | duck |
| Deb  | DE    | Deb  | duck |
| Ada  | AZ    | Pat  | pig  |
| Deb  | DE    | Pat  | pig  |
+------+-------+------+------+
</code></pre>

Once all combinations are listed out, you can choose to filter on the results by adding a `WHERE` clause to return fewer rows based on what you’re looking for.

#### Self join

You can join a table with itself using a self join. There are typically two steps to a self join:

1. Display all combinations of the rows in a table with itself.
2. Filter on the resulting rows based on some criteria.

The following are two examples of self joins in practice.

Here is a table of employees and their managers:

```
SELECT * FROM employee;

+------+--------+----------+--------+
| dept | emp_id | emp_name | mgr_id |
+------+--------+----------+--------+
| tech |    201 | lisa     |    101 |
| tech |    202 | monica   |    101 |
| data |    203 | nancy    |    201 |
| data |    204 | olivia   |    201 |
| data |    205 | penny    |    202 |
+------+--------+----------+--------+
```

Example 1: Return a list of employees and their managers.

<pre><code>SELECT e1.emp_name, e2.emp_name as mgr_name
<strong>FROM employee e1, employee e2
</strong><strong>WHERE e1.mgr_id = e2.emp_id;
</strong>
+----------+----------+
| emp_name | mgr_name |
+----------+----------+
| nancy    | lisa     |
| olivia   | lisa     |
| penny    | monica   |
+----------+----------+
</code></pre>

Example 2: Match each employee with another employee in their department.

<pre><code>SELECT e.dept, e.emp_name, matching_emp.emp_name
<strong>FROM employee e, employee matching_emp
</strong><strong>WHERE e.dept = matching_emp.dept
</strong><strong>      AND e.emp_name &#x3C;> matching_emp.emp_name;
</strong>
+------+----------+----------+
| dept | emp_name | emp_name |
+------+----------+----------+
| tech | monica   | lisa     |
| tech | lisa     | monica   |
| data | penny    | nancy    |
| data | olivia   | nancy    |
| data | penny    | olivia   |
| data | nancy    | olivia   |
| data | olivia   | penny    |
| data | nancy    | penny    |
+------+----------+----------+
</code></pre>

**NOTE**

The preceding query has duplicate rows (`monica`/`lisa` and `lisa`/`monica`). To remove the duplicates and return just four rows instead of eight, you can add the line:

```
AND e.emp_name < matching_emp.emp_name
```

to the `WHERE` clause to only return rows where the first name is before the second name alphabetically. Here is the output without duplicates:

```
+------+----------+----------+
| dept | emp_name | emp_name |
+------+----------+----------+
| tech | lisa     | monica   |
| data | nancy    | olivia   |
| data | nancy    | penny    |
| data | olivia   | penny    |
+------+----------+----------+
```

## Union Operators

Use the `UNION` keyword to combine the results of two or more `SELECT` statements. The difference between a [`JOIN`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#joining\_tables) and a `UNION` is that `JOIN` links together multiple tables within a single query, whereas `UNION` stacks the results of multiple queries:

<pre><code>-- JOIN example
SELECT *
<strong>FROM birthdays b JOIN candles c
</strong>     ON b.name = c.name;

-- UNION example
SELECT * FROM writers
<strong>UNION
</strong>SELECT * FROM artists;
</code></pre>

[Figure 9-1](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#join\_vs\_union) shows the difference between the results of a `JOIN` and a `UNION`, based on the preceding code.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492090397/files/assets/spg4_0901.png" alt="spg4 0901" height="668" width="600"><figcaption></figcaption></figure>

**Figure 9-1. `JOIN` versus `UNION`**

There are three ways to combine the rows of two tables together. These are also known as _union operators_:

`UNION`

Combines the results of multiple statements.

`EXCEPT` (`MINUS` in _Oracle_)

Returns the results minus another set of results.

`INTERSECT`

Returns overlapping results.

### UNION

The `UNION` keyword combines the results of two or more `SELECT` statements into one output.

Here are two tables we’d like to combine:

```
-- staff
+---------+---------+
| name    | origin  |
+---------+---------+
| michael | NULL    |
| janet   | NULL    |
| tahani  | england |
+---------+---------+

-- residents
+---------+---------+------------+
| name    | country | occupation |
+---------+---------+------------+
| eleanor | usa     | temp       |
| chidi   | nigeria | professor  |
| tahani  | england | model      |
| jason   | usa     | dj         |
+---------+---------+------------+
```

Use `UNION` to combine the two tables and eliminate any duplicate rows:

<pre><code>SELECT name, origin FROM staff
<strong>UNION
</strong>SELECT name, country FROM residents;

+---------+---------+
| name    | origin  |
+---------+---------+
| michael | NULL    |
| janet   | NULL    |
| tahani  | england |
| eleanor | usa     |
| chidi   | nigeria |
| jason   | usa     |
+---------+---------+
</code></pre>

Note that `tahani`/`england` appears in both the `staff` and `residents` tables. However, it only shows up as one row in the result set because `UNION` removes duplicate rows from the output.

**WHICH QUERIES CAN YOU UNION TOGETHER?**

When doing a `UNION` on two queries, some characteristics of the queries must match and others do not have to match.

Number of Columns: MUST MATCH

When you union together two queries, you must specify the same number of columns in both queries.

Column Names: DO NOT HAVE TO MATCH

The column names of the two queries do not need to match to do a `UNION`. The column names used in the first `SELECT` statement in a `UNION` query become the names of the output columns.

Data Types: MUST MATCH

The data types of the two queries need to match to do a `UNION`. If they do not match, you can use the [`CAST`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#convert\_data\_to\_a\_numeric\_data\_type) function to cast them into the same data type before doing a `UNION`.

#### UNION ALL

Use `UNION ALL` to combine the two tables and preserve duplicate rows:

<pre><code>SELECT name, origin FROM staff
<strong>UNION ALL
</strong>SELECT name, country FROM residents;

+---------+---------+
| name    | origin  |
+---------+---------+
| michael | NULL    |
| janet   | NULL    |
<strong>| tahani  | england |
</strong>| eleanor | usa     |
| chidi   | nigeria |
<strong>| tahani  | england |
</strong>| jason   | usa     |
+---------+---------+
</code></pre>

**TIP**

If you know with certainty that no duplicate rows are possible, use `UNION ALL` to improve performance. `UNION` does an additional sort behind the scenes to identify the duplicates.

#### UNION with other clauses

You can also include other clauses when using a `UNION`, such as `WHERE`, `JOIN`, etc. However, only one `ORDER BY` clause is allowed for the whole query, and it should be at the very end.

Filter out null values and sort the results of a `UNION` query:

<pre><code>SELECT name, origin
FROM staff
<strong>WHERE origin IS NOT NULL
</strong>
<strong>UNION
</strong>
SELECT name, country
FROM residents

<strong>ORDER BY name;
</strong>
+---------+---------+
| name    | origin  |
+---------+---------+
| chidi   | nigeria |
| eleanor | usa     |
| jason   | usa     |
| tahani  | england |
+---------+---------+
</code></pre>

#### UNION with more than two tables

You can union together more than two tables by including additional `UNION` clauses.

Combine the rows of more than two tables:

<pre><code>SELECT name, origin
FROM staff

<strong>UNION
</strong>
SELECT name, country
FROM residents

<strong>UNION
</strong>
SELECT name, country
FROM pets;
</code></pre>

**TIP**

`UNION` is typically used to combine results from multiple tables. If you are combining results from a single table, it is better to write a single query instead and use the appropriate `WHERE` clause, `CASE` statement, etc.

### EXCEPT and INTERSECT

In addition to using a `UNION` to combine the rows of multiple tables, you can use `EXCEPT` and `INTERSECT` to combine the rows in different ways.

#### EXCEPT

Use `EXCEPT` to “subtract” the results of one query from another query.

Return the staff members that are not residents:

<pre><code>SELECT name FROM staff
<strong>EXCEPT
</strong>SELECT name FROM residents;

+---------+
| name    |
+---------+
| michael |
| janet   |
+---------+
</code></pre>

_MySQL_ does not support `EXCEPT`. Instead, you can use the [`NOT IN`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#in) keywords as a workaround:

<pre><code>SELECT name
FROM staff
<strong>WHERE name NOT IN (SELECT name FROM residents);
</strong></code></pre>

_Oracle_ uses `MINUS` instead of `EXCEPT`.

_PostgreSQL_ also supports `EXCEPT ALL`, which does not remove duplicates. `EXCEPT` removes all occurrences of a value, while `EXCEPT ALL` removes specific instances.

#### INTERSECT

Use `INTERSECT` to find the rows in common between two queries.

Return the staff members that are residents as well:

<pre><code>SELECT name, origin FROM staff
<strong>INTERSECT
</strong>SELECT name, country FROM residents;

+---------+---------+
| name    | origin  |
+---------+---------+
| tahani  | england |
+---------+---------+
</code></pre>

_MySQL_ does not support `INTERSECT`. Instead, you can use an [`INNER JOIN`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#inner\_join) as a workaround:

<pre><code>SELECT s.name, s.origin
<strong>FROM staff s INNER JOIN residents r
</strong>     ON s.name = r.name;
</code></pre>

_PostgreSQL_ also supports `INTERSECT ALL`, which preserves duplicate values.

**UNION OPERATORS: ORDER OF EVALUATION**

When writing a statement with multiple union operators (`UNION`, `EXCEPT`, `INTERSECT`), use parentheses to specify the order in which the operations should occur.

```
SELECT * FROM staff
EXCEPT
(SELECT * FROM residents
UNION
SELECT * FROM pets);
```

Unless otherwise specified, union operators are performed in top-down order, except that `INTERSECT` takes precedence over `UNION` and `EXCEPT`.

## Common Table Expressions

A _common table expression (CTE)_ is a temporary result set. In other words, it temporarily saves the output of a query for you to write other queries that reference it.

You can spot a CTE when you see the `WITH` keyword. There are two types of CTEs:

Nonrecursive CTE

A query for other queries to reference (see [“CTEs Versus Subqueries”](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#ctes\_vs\_subqueries)).

Recursive CTE

A query that references itself (see [“Recursive CTEs”](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#recursive\_ctes)).

**NOTE**

Nonrecursive CTEs are a lot more common than recursive CTEs. Most of the time, if someone mentions a CTE, they are referring to a nonrecursive CTE.

Here is an example of a nonrecursive CTE in practice:

<pre><code>-- Query the results of my_cte
<strong>WITH my_cte AS (
</strong>   SELECT name, AVG(grade) AS avg_grade
   FROM my_table
   GROUP BY name)

SELECT *
<strong>FROM my_cte
</strong>WHERE avg_grade &#x3C; 70;
</code></pre>

Here is an example of a recursive CTE in practice:

<pre><code>-- Generate the numbers 1 through 10
<strong>WITH RECURSIVE my_cte(n) AS
</strong>(
  SELECT 1 -- Include FROM dual in Oracle
  UNION ALL
<strong>  SELECT n + 1 FROM my_cte WHERE n &#x3C; 10
</strong>)

<strong>SELECT * FROM my_cte;
</strong></code></pre>

In _MySQL_ and _PostgreSQL_, the `RECURSIVE` keyword is required. In _Oracle_ and _SQL Server_, the `RECURSIVE` keyword must be left out. _SQLite_ works with either syntax.

In _Oracle_, you may see older code that uses the `CONNECT BY` syntax for recursive queries, but CTEs are much more common these days.

### CTEs Versus Subqueries

Both CTEs and subqueries allow you to write a query, and then write another query that references the first query. This section describes the difference between the two approaches.

Imagine your goal is to find the department that has the largest average salary. This can be done in two steps: write a query that returns the average salary for each department; use a CTE or subquery to write a query around the first query to return the department with the largest average salary.

Step 1. Query that finds the average salary for each department

```

SELECT dept, AVG(salary) AS avg_salary
FROM employees
GROUP BY dept;

+-------+------------+
| dept  | avg_salary |
+-------+------------+
| mktg  |      78000 |
| sales |      61000 |
| tech  |      83000 |
+-------+------------+
```

Step 2. CTE and subquery that find the department with the largest average salary using the preceding query

<pre><code>
<strong>-- CTE approach
</strong><strong>WITH avg_dept_salary AS (
</strong>   SELECT dept, AVG(salary) AS avg_salary
   FROM employees
   GROUP BY dept)

SELECT *
<strong>FROM avg_dept_salary
</strong>ORDER BY avg_salary DESC
LIMIT 1;

<strong>-- Equivalent subquery approach
</strong>SELECT *
FROM

(SELECT dept, AVG(salary) AS avg_salary
FROM employees
<strong>GROUP BY dept) avg_dept_salary
</strong>
ORDER BY avg_salary DESC
LIMIT 1;

+------+------------+
| dept | avg_salary |
+------+------------+
| tech |      83000 |
+------+------------+
</code></pre>

The `LIMIT` clause syntax differs by software. Replace `LIMIT 1` with `ROWNUM = 1` in _Oracle_ and `TOP 1` in _SQL Server_. More details can be found in [The LIMIT Clause](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch04.html#the\_limit\_clause) section in [Chapter 4](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch04.html#querying\_basics).

**ADVANTAGES OF A CTE VERSUS A SUBQUERY**

There are a few advantages to using a CTE instead of a subquery.

Multiple References

Once a CTE is defined, you can reference it by name multiple times within the `SELECT` queries that follow:

<pre><code><strong>WITH my_cte AS (...)
</strong>
<strong>SELECT * FROM my_cte WHERE id > 10
</strong>UNION
<strong>SELECT * FROM my_cte WHERE score > 90;
</strong></code></pre>

With a subquery, you would need to write out the full subquery each time.

Multiple Tables

CTE syntax is more readable when working with multiple tables because you can list all the CTEs up front:

<pre><code><strong>WITH my_cte1 AS (...),
</strong><strong>     my_cte2 AS (...)
</strong>
SELECT *
<strong>FROM my_cte1 m1
</strong><strong>     INNER JOIN my_cte2 m2
</strong>     ON m1.id = m2.id;
</code></pre>

With subqueries, the subqueries would be scattered throughout the overall query.

CTEs are _not supported_ in older SQL software, which is why subqueries are still commonly used.

### Recursive CTEs

This section walks through two practical situations where a recursive CTE would be useful.

#### Fill in missing rows in a sequence of data

The following table includes dates and prices. Note that the `date` column is missing data for the second and fifth of the month.

```
SELECT * FROM stock_prices;

+------------+--------+
| date       | price  |
+------------+--------+
| 2021-03-01 | 668.27 |
| 2021-03-03 | 678.83 |
| 2021-03-04 | 635.40 |
| 2021-03-06 | 591.01 |
+------------+--------+
```

Fill in the dates with a two-step process:

1. Use a recursive CTE to generate a sequence of dates.
2. Join the sequence of dates with the original table.

**NOTE**

The following code runs in _MySQL_. [Table 9-4](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#generating\_a\_date\_column\_in\_each\_rdbms) has the syntax for each RDBMS.

Step 1: Use a recursive CTE to generate a sequence of dates called `my_dates`.

The `my_dates` table starts with the date `2021-03-01`, and adds on the next date again and again, up until the date `2021-03-06`:

<pre><code>-- MySQL syntax
<strong>WITH RECURSIVE my_dates(dt) AS (
</strong>   SELECT '2021-03-01'
   UNION ALL
<strong>   SELECT dt + INTERVAL 1 DAY
</strong>   FROM my_dates
   WHERE dt &#x3C; '2021-03-06')

SELECT * FROM my_dates;

+------------+
| dt         |
+------------+
| 2021-03-01 |
| 2021-03-02 |
| 2021-03-03 |
| 2021-03-04 |
| 2021-03-05 |
| 2021-03-06 |
+------------+
</code></pre>

Step 2: Left join the recursive CTE with the original table.

<pre><code>
-- MySQL syntax
WITH RECURSIVE my_dates(dt) AS (
   SELECT '2021-03-01'
   UNION ALL
   SELECT dt + INTERVAL 1 DAY
   FROM my_dates
   WHERE dt &#x3C; '2021-03-06')

SELECT d.dt, s.price
<strong>FROM my_dates d
</strong><strong>     LEFT JOIN stock_prices s
</strong>     ON d.dt = s.date;

+------------+--------+
| dt         | price  |
+------------+--------+
| 2021-03-01 | 668.27 |
| 2021-03-02 |   NULL |
| 2021-03-03 | 678.83 |
| 2021-03-04 | 635.40 |
| 2021-03-05 |   NULL |
| 2021-03-06 | 591.01 |
+------------+--------+
</code></pre>

Step 3 (Optional): Fill in the null values with the previous day’s price.

Replace the `SELECT` clause (`SELECT d.dt, s.price`) with:

```
SELECT d.dt, COALESCE(s.price,
       LAG(s.price) OVER
       (ORDER BY d.dt)) AS price
...

+------------+--------+
| dt         | price  |
+------------+--------+
| 2021-03-01 | 668.27 |
| 2021-03-02 | 668.27 |
| 2021-03-03 | 678.83 |
| 2021-03-04 | 635.40 |
| 2021-03-05 | 635.40 |
| 2021-03-06 | 591.01 |
+------------+--------+
```

There are syntax differences for each RDBMS.

Here is the general syntax for generating a date column. The bolded portions differ by RDBMS, and the software-specific code is listed in [Table 9-4](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#generating\_a\_date\_column\_in\_each\_rdbms).

<pre><code><strong>[WITH] my_dates(dt) AS (
</strong><strong>   SELECT [DATE]
</strong>   UNION ALL
<strong>   SELECT [DATE PLUS ONE]
</strong>   FROM my_dates
<strong>   WHERE dt &#x3C; [LAST DATE])
</strong>
SELECT * FROM my_dates;
</code></pre>

| RDBMS      | WITH             | DATE                          | DATE PLUS ONE                         | LAST DATE           |
| ---------- | ---------------- | ----------------------------- | ------------------------------------- | ------------------- |
| MySQL      | `WITH RECURSIVE` | `'2021-03-01'`                | `dt + INTERVAL 1 DAY`                 | `'2021-03-06'`      |
| Oracle     | `WITH`           | `DATE '2021-03-01'`           | `dt + INTERVAL '1' DAY`               | `DATE '2021-03-06'` |
| PostgreSQL | `WITH RECURSIVE` | `CAST( '2021-03-01' AS DATE)` | `CAST(dt + INTERVAL '1 day' AS DATE)` | `'2021-03-06'`      |
| SQL Server | `WITH`           | `CAST( '2021-03-01' AS DATE)` | `DATEADD(DAY, 1, CAST(dt AS DATE))`   | `'2021-03-06'`      |
| SQLite     | `WITH RECURSIVE` | `DATE( '2021-03-01')`         | `DATE(dt, '1 day')`                   | `'2021-03-06'`      |

#### Return all the parents of a child row

The following table includes the roles of various family members. The rightmost column includes the `id` of a person’s parent.

```
SELECT * FROM family_tree;

+------+---------+----------+-----------+
| id   | name    | role     | parent_id |
+------+---------+----------+-----------+
|    1 | Lao Ye  | Grandpa  |      NULL |
|    2 | Lao Lao | Grandma  |      NULL |
|    3 | Ollie   | Dad      |      NULL |
|    4 | Alice   | Mom      |         1 |
|    4 | Alice   | Mom      |         2 |
|    5 | Henry   | Son      |         3 |
|    5 | Henry   | Son      |         4 |
|    6 | Lily    | Daughter |         3 |
|    6 | Lily    | Daughter |         4 |
+------+---------+----------+-----------+
```

**NOTE**

The following code runs in _MySQL_. [Table 9-5](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#listing\_all\_the\_parents\_in\_each\_rdbms) has the syntax for each RDBMS.

You can list each person’s parents and grandparents with a recursive CTE:

<pre><code>-- MySQL syntax
<strong>WITH RECURSIVE my_cte (id, name, lineage) AS (
</strong><strong>   SELECT id, name, name AS lineage
</strong>   FROM family_tree
   WHERE parent_id IS NULL
<strong>   UNION ALL
</strong>   SELECT ft.id, ft.name,
<strong>          CONCAT(mc.lineage, ' > ', ft.name)
</strong>   FROM family_tree ft
<strong>        INNER JOIN my_cte mc
</strong>        ON ft.parent_id = mc.id)

SELECT * FROM my_cte ORDER BY id;

+------+---------+-------------------------+
| id   | name    | lineage                 |
+------+---------+-------------------------+
|    1 | Lao Ye  | Lao Ye                  |
|    2 | Lao Lao | Lao Lao                 |
|    3 | Ollie   | Ollie                   |
|    4 | Alice   | Lao Ye > Alice          |
|    4 | Alice   | Lao Lao > Alice         |
|    5 | Henry   | Ollie > Henry           |
|    5 | Henry   | Lao Ye > Alice > Henry  |
|    5 | Henry   | Lao Lao > Alice > Henry |
|    6 | Lily    | Ollie > Lily            |
|    6 | Lily    | Lao Ye > Alice > Lily   |
|    6 | Lily    | Lao Lao > Alice > Lily  |
+------+---------+-------------------------+
</code></pre>

In the preceding code (also known as a _hierarchical query_), `my_cte` contains two statements that are unioned together:

* The first `SELECT` statement is the starting point. The rows where the `parent_id` is `NULL` are treated as the tree roots.
* The second `SELECT` statement defines the recursive link between the parent and child rows. The children of each tree root are returned and tacked on to the `lineage` column until the full lineage is spelled out.

There are syntax differences for each RDBMS.

Here is the general syntax for listing all the parents. The bolded portions differ by RDBMS, and the software-specific code is listed in [Table 9-5](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch09.html#listing\_all\_the\_parents\_in\_each\_rdbms).

<pre><code><strong>[WITH] my_cte (id, name, lineage) AS (
</strong><strong>   SELECT id, name, [NAME] AS lineage
</strong>   FROM family_tree
   WHERE parent_id IS NULL
   UNION ALL
<strong>   SELECT ft.id, ft.name, [LINEAGE]
</strong>   FROM family_tree ft
        INNER JOIN my_cte mc
        ON ft.parent_id = mc.id)

SELECT * FROM my_cte ORDER BY id;
</code></pre>

| RDBMS      | WITH             | NAME                        | LINEAGE                                                    |
| ---------- | ---------------- | --------------------------- | ---------------------------------------------------------- |
| MySQL      | `WITH RECURSIVE` | `name`                      | `CONCAT(mc.lineage, ' > ', ft.name)`                       |
| Oracle     | `WITH`           | `name`                      | `mc.lineage \|\| ' > ' \|\| ft.name`                       |
| PostgreSQL | `WITH RECURSIVE` | `CAST(name AS VARCHAR(30))` | `CAST(CONCAT( mc.lineage, ' > ', ft.name) AS VARCHAR(30))` |
| SQL Server | `WITH`           | `CAST(name AS VARCHAR(30))` | `CAST(CONCAT( mc.lineage, ' > ', ft.name) AS VARCHAR(30))` |
| SQLite     | `WITH RECURSIVE` | `name`                      | `mc.lineage \|\| ' > ' \|\| ft.name`                       |
