# 8. Advanced Querying Concepts

## Chapter 8. Advanced Querying Concepts

This chapter covers a few advanced ways of wrangling data using SQL queries, beyond the six main clauses covered in [Chapter 4, “Querying Basics”](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch04.html#querying\_basics), and the common keywords covered in [Chapter 7, “Operators and Functions”](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#operators\_and\_functions).

[Table 8-1](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#advanced\_querying\_concepts\_table) includes descriptions and code examples of the four concepts covered in this chapter.

| Concept                                                                                                                                   | Description                                                                                                                                 | Code Example                                                                                                                                                          |
| ----------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Case Statements](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#case\_statements)                    | If a condition is met, return a particular value. Otherwise, return another value.                                                          | <pre><code>SELECT house_id,
<strong>  CASE WHEN flg = 1
</strong><strong>  THEN 'for sale'
</strong><strong>  ELSE 'sold' END
</strong>FROM houses;
</code></pre>     |
| [Grouping and Summarizing](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#grouping\_and\_summarizing) | Split data into groups, aggregate the data within each group, and return a value for each _group_.                                          | <pre><code>SELECT zip, AVG(ft)
FROM houses
<strong>GROUP BY zip;
</strong></code></pre>                                                                               |
| [Window Functions](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#window\_functions)                  | Split data into groups, aggregate or order the data within each group, and return a value for each _row_.                                   | <pre><code>SELECT zip,
<strong>  ROW_NUMBER() OVER
</strong><strong>  (PARTITION BY zip
</strong><strong>  ORDER BY price)
</strong>FROM houses;
</code></pre>        |
| [Pivoting and Unpivoting](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#pivoting\_and\_unpivoting)   | Turn values in a column into multiple columns or consolidate multiple columns into a single column. Supported by _Oracle_ and _SQL Server_. | <pre><code>-- Oracle syntax
SELECT *
FROM listing_info
<strong>PIVOT
</strong><strong>  (COUNT(*) FOR
</strong><strong>  room IN ('bd','br'));
</strong></code></pre> |

This chapter describes each of the concepts in [Table 8-1](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#advanced\_querying\_concepts\_table) in detail, along with common use cases.

## Case Statements

A `CASE` statement is used to apply if-else logic within a query. For example, you could use a `CASE` statement to spell out values. If a `1` is seen, display `vip`. Otherwise, display `general` `admission`.

```
+--------+       +-------------------+
| ticket |       | ticket            |
+--------+       +-------------------+
|      1 |       | vip               |
|      0 |  -->  | general admission |
|      1 |       | vip               |
+--------+       +-------------------+
```

In _Oracle_, you may also see the [`DECODE`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch03.html#oracle\_decode) function, which is an older function that operates similarly to the `CASE` statement.

**NOTE**

Using a `CASE` statement temporarily updates values for the duration of a query. To save the updated values, you can do so with an [`UPDATE`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch05.html#update\_a\_column\_of\_data) statement.

The following two sections go over two types of `CASE` statements:

* _Simple_ `CASE` statement for a _single column_ of data
* _Searched_ `CASE` statement for _multiple columns_ of data

### Display Values Based on If-Then Logic for a Single Column

To check for equality within a single column of data, use the _simple_ `CASE` statement syntax.

Our goal:

Instead of displaying the values `1`/`0`/`NULL`, display the values `vip`/`reserved seating`/`general admission`:

* If `flag = 1`, then `ticket = vip`
* If `flag = 0`, then `ticket = reserved seating`
* Else, `ticket = general admission`

Here is a sample table:

```
SELECT * FROM concert;

+-------+------+
| name  | flag |
+-------+------+
| anton |    1 |
| julia |    0 |

| maren |    1 |
| sarah | NULL |
+-------+------+
```

Implement the if-else logic with a simple `CASE` statement:

<pre><code>SELECT name, flag,
<strong>   CASE flag WHEN 1 THEN 'vip'
</strong><strong>   WHEN 0 THEN 'reserved seating'
</strong><strong>   ELSE 'general admission' END AS ticket
</strong>FROM concert;

+-------+------+-------------------+
| name  | flag | ticket            |
+-------+------+-------------------+
| anton |    1 | vip               |
| julia |    0 | reserved seating  |
| maren |    1 | vip               |
| sarah | NULL | general admission |
+-------+------+-------------------+
</code></pre>

If no `WHEN` clause is a match and no `ELSE` value is specified, a `NULL` will be returned.

### Display Values Based on If-Then Logic for Multiple Columns

To check for any [condition](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#comparison\_operators) (`=`, `<`, `IN`, `IS NULL`, etc.) within potentially multiple columns of data, use the _searched_ `CASE` statement syntax.

Our goal:

Instead of displaying the values `1`/`0`/`NULL`, display the values `vip`/`reserved seating`/`general admission`:

* If `name = anton`, then `ticket = vip`
* If `flag = 0` or `flag = 1`, then `ticket = reserved seating`
* Else, `ticket = general admission`

Here is a sample table:

```
SELECT * FROM concert;

+-------+------+
| name  | flag |
+-------+------+
| anton |    1 |
| julia |    0 |
| maren |    1 |
| sarah | NULL |
+-------+------+
```

Implement the if-else logic with a searched `CASE` statement:

<pre><code>SELECT name, flag,
<strong>   CASE WHEN name = 'anton' THEN 'vip'
</strong><strong>   WHEN flag IN (0,1) THEN 'reserved seating'
</strong><strong>   ELSE 'general admission' END AS ticket
</strong>FROM concert;

+-------+------+-------------------+
| name  | flag | ticket            |
+-------+------+-------------------+
| anton |    1 | vip               |
| julia |    0 | reserved seating  |
| maren |    1 | reserved seating  |
| sarah | NULL | general admission |
+-------+------+-------------------+
</code></pre>

If multiple conditions are met, the first listed condition takes precedence.

**NOTE**

To replace all `NULL` values in a column with another value, you could use a `CASE` statement, but it is more common to use the `NULL` function [`COALESCE`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#return\_an\_alternative\_value\_if\_there\_is\_a\_null\_value) instead.

## Grouping and Summarizing

SQL allows you to separate rows into groups and summarize the rows within each group in some way, ultimately returning just one row per group.

[Table 8-2](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#grouping\_and\_summarizing\_concepts) lists the concepts associated with grouping and summarizing data.

| Category                                                                                                               | Keyword                                                                                                               | Description                                                                                                                                                                                 |
| ---------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| The main concept                                                                                                       | `GROUP BY`                                                                                                            | Use the `GROUP BY` clause to separate rows of data into groups.                                                                                                                             |
| Ways to summarize rows within each group                                                                               | <p><code>COUNT</code></p><p><code>SUM</code></p><p><code>MIN</code></p><p><code>MAX</code></p><p><code>AVG</code></p> | These [aggregate functions](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#aggregate\_functions) summarize multiple rows of data into _a single value_. |
| <p><code>ARRAY_AGG</code></p><p><code>GROUP_CONCAT</code></p><p><code>LISTAGG</code></p><p><code>STRING_AGG</code></p> | These functions combine multiple rows of data into _a single list_.                                                   |                                                                                                                                                                                             |
| Extensions of the `GROUP BY` clause                                                                                    | `ROLLUP`                                                                                                              | Includes rows for subtotals and the grand total as well.                                                                                                                                    |
| `CUBE`                                                                                                                 | Includes aggregations for all possible combinations of the grouped by columns.                                        |                                                                                                                                                                                             |
| `GROUPING SETS`                                                                                                        | Allows you to specify particular groupings to display.                                                                |                                                                                                                                                                                             |

### GROUP BY Basics

The following table shows the number of calories burned by two people:

```
SELECT * FROM workouts;

+------+----------+
| name | calories |
+------+----------+
| ally |       80 |
| ally |       75 |
| ally |       90 |
| jess |      100 |
| jess |       92 |
+------+----------+
```

To create a summary table, you need to decide how to:

1. Group the data: separate all the `name` values into two groups—`ally` and `jess`.
2. Aggregate the data within the groups: find the total `calories` within each group.

Use the `GROUP BY` clause to create a summary table:

<pre><code>SELECT name,
       SUM(calories) AS total_calories
FROM workouts
<strong>GROUP BY name;
</strong>
+------+----------------+
| name | total_calories |
+------+----------------+
| ally |            245 |
| jess |            192 |
+------+----------------+
</code></pre>

More details on how `GROUP BY` works behind the scenes can be found in [The GROUP BY Clause](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch04.html#the\_group\_by\_clause) section in [Chapter 4](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch04.html#querying\_basics).

#### Grouping by multiple columns

The following table shows the number of calories burned by two people during their daily workouts:

```
SELECT * FROM daily_workouts;
```

```
+------+------+------------+----------+
| id   | name | date       | calories |
+------+------+------------+----------+
|    1 | ally | 2021-03-03 |       80 |
|    1 | ally | 2021-03-04 |       75 |
|    1 | ally | 2021-03-05 |       90 |
|    2 | jess | 2021-03-03 |      100 |
|    2 | jess | 2021-03-05 |       92 |
+------+------+------------+----------+
```

When writing a query with a `GROUP BY` clause that groups by multiple columns and/or includes multiple aggregations:

* The `SELECT` clause should include all _column names_ and _aggregations_ that you want to appear in the output.
* The `GROUP BY` clause should include the same _column names_ that are in the `SELECT` clause.

Use the `GROUP BY` clause to summarize the stats for each person, returning both the `id` and `name` along with two aggregations:

<pre><code><strong>SELECT id, name,
</strong>       COUNT(date) AS workouts,
       SUM(calories) AS calories
FROM daily_workouts
<strong>GROUP BY id, name;
</strong>
+------+------+----------+----------+
| id   | name | workouts | calories |
+------+------+----------+----------+
|    1 | ally |        3 |      245 |
|    2 | jess |        2 |      192 |
+------+------+----------+----------+
</code></pre>

**REDUCE THE GROUP BY LIST FOR EFFICIENCY**

If you know that each `id` is linked to a single `name`, you can exclude the `name` column from the `GROUP BY` clause and get the same results as the previous query:

<pre><code><strong>SELECT id,
</strong>       MAX(name) AS name,
       COUNT(date) AS workouts,
       SUM(calories) AS calories
FROM daily_workouts
<strong>GROUP BY id;
</strong></code></pre>

This runs more efficiently behind the scenes since the `GROUP BY` only has to occur on one column.

To compensate for dropping the `name` from the `GROUP BY` clause, you’ll notice that an arbitrary aggregate function (`MAX`) was applied to the `name` column within the `SELECT` clause. Because there is only one `name` value within each `id` group, `MAX(name)` will simply return the `name` associated with each `id`.

### Aggregate Rows into a Single Value or List

With the `GROUP BY` clause, you must specify how the rows of data within each group should be summarized using either:

* _An_ [_aggregate function_](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#aggregate\_functions) _to summarize rows into a single value_: `COUNT`, `SUM`, `MIN`, `MAX`, and `AVG`
* _A function to summarize rows into a list_ (shown in the sample table): `GROUP_CONCAT` and others listed in [Table 8-3](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#aggregate\_rows\_into\_a\_list\_in\_each\_rdbms)

Here is a sample table:

```
SELECT * FROM workouts;

+------+----------+
| name | calories |
+------+----------+
| ally |       80 |
| ally |       75 |
| ally |       90 |
| jess |      100 |
| jess |       92 |
+------+----------+
```

Use `GROUP_CONCAT` in _MySQL_ to create a list of calories:

<pre><code>SELECT name,
<strong>       GROUP_CONCAT(calories) AS calories_list
</strong>FROM workouts
GROUP BY name;

+------+---------------+
| name | calories_list |
+------+---------------+
| ally | 80,75,90      |
| jess | 100,92        |
+------+---------------+
</code></pre>

The `GROUP_CONCAT` function differs for each RDBMS. [Table 8-3](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#aggregate\_rows\_into\_a\_list\_in\_each\_rdbms) shows the syntax supported by each RDBMS:

| RDBMS      | Code                                                                                               | Default Separator  |
| ---------- | -------------------------------------------------------------------------------------------------- | ------------------ |
| MySQL      | <p><code>GROUP_CONCAT(calories)</code></p><p><code>GROUP_CONCAT(calories SEPARATOR ',')</code></p> | Comma              |
| Oracle     | <p><code>LISTAGG(calories)</code></p><p><code>LISTAGG(calories, ',')</code></p>                    | No value           |
| PostgreSQL | `ARRAY_AGG(calories)`                                                                              | Comma              |
| SQL Server | `STRING_AGG(calories, ',')`                                                                        | Separator required |
| SQLite     | <p><code>GROUP_CONCAT(calories)</code></p><p><code>GROUP_CONCAT(calories, ',')</code></p>          | Comma              |

In _MySQL_, _Oracle_, and _SQLite_, the separator portion (`','`) is optional. _PostgreSQL_ doesn’t accept a separator, and _SQL Server_ requires one.

You can also return a sorted list or a unique list of values. [Table 8-4](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#return\_a\_sorted\_or\_unique\_list\_of\_values\_in\_each\_rdbms) shows the syntax supported by each RDBMS.

| RDBMS      | Sorted List                                                              | Unique List                                |
| ---------- | ------------------------------------------------------------------------ | ------------------------------------------ |
| MySQL      | `GROUP_CONCAT(calories` **`ORDER BY calories)`**                         | `GROUP_CONCAT(` **`DISTINCT`** `calories)` |
| Oracle     | `LISTAGG(calories)` **`WITHIN GROUP`** (**`ORDER BY calories`**)         | `LISTAGG(` **`DISTINCT`** `calories)`      |
| PostgreSQL | `ARRAY_AGG(calories` **`ORDER BY calories`)**                            | `ARRAY_AGG(` **`DISTINCT`** `calories)`    |
| SQL Server | `STRING_AGG(calories, ',')` **`WITHIN GROUP`** **`(ORDER BY calories)`** | Not supported                              |
| SQLite     | Not supported                                                            | `GROUP_CONCAT(` **`DISTINCT`** `calories)` |

### ROLLUP, CUBE, and GROUPING SETS

In addition to `GROUP BY`, you can also add on the `ROLLUP`, `CUBE`, or `GROUPING SETS` keywords to include additional summary information.

The following table lists five purchases over the course of three months:

```
SELECT * FROM spendings;

 YEAR  MONTH  AMOUNT
----- ------ -------
 2019      1      20
 2019      1      30
 2020      1      42
 2020      2      37
 2020      2     100
```

The examples in this section build on the following `GROUP BY` example, which returns the total monthly spendings:

<pre><code>SELECT year, month,
       SUM(amount) AS total
FROM spendings
<strong>GROUP BY year, month
</strong>ORDER BY year, month;

 YEAR  MONTH  TOTAL
----- ------ ------
 2019      1     50
 2020      1     42
 2020      2    137
</code></pre>

#### ROLLUP

_MySQL_, _Oracle_, _PostgreSQL_, and _SQL Server_ support `ROLLUP`, which extends the `GROUP BY` by including additional rows for subtotals and the grand total.

Use `ROLLUP` to display the yearly and total spendings as well. The 2019, 2020, and total spending rows are added with the addition of `ROLLUP`:

<pre><code>SELECT year, month,
       SUM(amount) AS total
FROM spendings
<strong>GROUP BY ROLLUP(year, month)
</strong>ORDER BY year, month;

 YEAR  MONTH  TOTAL
----- ------ ------
 2019      1     50
<strong> 2019            50 -- 2019 spendings
</strong> 2020      1     42
 2020      2    137
<strong> 2020           179 -- 2020 spendings
</strong><strong>                229 -- Total spendings
</strong></code></pre>

The preceding syntax works in _Oracle_, _PostgreSQL_, and _SQL Server_. The _MySQL_ syntax is `GROUP BY year, month WITH ROLLUP`, which also works in _SQL Server_.

#### CUBE

_Oracle_, _PostgreSQL_, and _SQL Server_ support `CUBE`, which extends the `ROLLUP` by including additional rows for all possible combinations of the columns that you are grouping by, as well as the grand total.

Use `CUBE` to display monthly spendings (single month across multiple years) as well. The January and Feburary spending rows are added with the addition of `CUBE`:

<pre><code>SELECT year, month,
       SUM(amount) AS total
FROM spendings
<strong>GROUP BY CUBE(year, month)
</strong>ORDER BY year, month;

 YEAR  MONTH  TOTAL
----- ------ ------
 2019      1     50
 2019            50
 2020      1     42
 2020      2    137
 2020           179
<strong>           1     92 -- January spendings
</strong><strong>           2    137 -- February spendings
</strong>                229
</code></pre>

The preceding syntax works in _Oracle_, _PostgreSQL_, and _SQL Server_. _SQL Server_ also supports the syntax `GROUP BY year, month WITH CUBE`.

#### GROUPING SETS

_Oracle_, _PostgreSQL_, and _SQL Server_ support `GROUPING SETS`, which lets you specify particular groupings that you want to display.

This data is a subset of the results generated by `CUBE`, only including groupings of one column at a time. In this case, only the total yearly and total monthly spendings are returned:

<pre><code>SELECT year, month,
       SUM(amount) AS total
FROM spendings
<strong>GROUP BY GROUPING SETS(year, month)
</strong>ORDER BY year, month;

 YEAR  MONTH  TOTAL
----- ------ ------
 2019            50
 2020           179
           1     92
           2    137
</code></pre>

## Window Functions

A _window function_ (or _analytic function_ in _Oracle_) is similar to an [aggregate function](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch07.html#aggregate\_functions) in that they both perform a calculation on rows of data. The difference is that an aggregate function returns a single value while a window function returns a value for each row of data.

The following table lists employees along with their monthly sales. The following queries use this table to show the difference between an aggregate function and a window function.

```
SELECT * FROM sales;

+-------+-------+-------+
| name  | month | sales |
+-------+-------+-------+
| David |     3 |     2 |
| David |     4 |    11 |
| Laura |     3 |     3 |
| Laura |     4 |    14 |
| Laura |     5 |     7 |
| Laura |     6 |     1 |
+-------+-------+-------+
```

### Aggregate Function

`SUM()` is an aggregate function. The following query sums up the sales for each person and returns each `name` along with its `total_sales` value.

<pre><code>SELECT name,
<strong>       SUM(sales) AS total_sales
</strong>FROM sales
GROUP BY name;

+-------+-------------+
| name  | total_sales |
+-------+-------------+
| David |          13 |
| Laura |          25 |
+-------+-------------+
</code></pre>

### Window Function

`ROW_NUMBER() OVER (PARTITION BY name ORDER BY month)` is a window function. In the bolded portion of the following query, for each person, a row number is generated that represents the first month, second month, etc. that they sold something. The query returns each row along with its `sale_month` value.

<pre><code>SELECT name,
<strong>       ROW_NUMBER() OVER (PARTITION BY name
</strong><strong>       ORDER BY month) AS sale_month
</strong>FROM sales;

+-------+------------+
| name  | sale_month |
+-------+------------+
| David |          1 |
| David |          2 |
| Laura |          1 |
| Laura |          2 |
| Laura |          3 |
| Laura |          4 |
+-------+------------+
</code></pre>

**BREAKING DOWN THE WINDOW FUNCTION**

```
ROW_NUMBER() OVER (PARTITION BY name ORDER BY month)
```

A _window_ is a group of rows. In the preceding example, there were two windows. The name `David` had a window of two rows and the name `Laura` had a window of four rows:

`ROW_NUMBER()`

The function you want to apply to each window. Other common functions include [`RANK()`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#Rank\_the\_rows\_in\_a\_table), [`FIRST_VALUE()`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#return\_the\_first\_value\_in\_each\_group), [`LAG()`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#return\_the\_prior\_row\_value), etc. This is required.

`OVER`

This states that you are specifying a window function. This is required.

`PARTITION BY name`

This states how you want to split your data into windows. It can be split according to one or more columns. This is optional. If excluded, the window is the entire table.

`ORDER BY month`

This states how each window should be sorted before the function is applied. This is optional in _MySQL_, _PostgreSQL_, and _SQLite_. It is required in _Oracle_ and _SQL Server_.

The following sections include examples of how window functions are used in practice.

### Rank the Rows in a Table

Use the `ROW_NUMBER()`, `RANK()`, or `DENSE_RANK()` function to add a row number to each row of a table.

The following table shows the number of babies given popular names:

```
SELECT * FROM baby_names;

+--------+--------+--------+
| gender | name   | babies |
+--------+--------+--------+
| F      | Emma   |     92 |
| F      | Mia    |     88 |
| F      | Olivia |    100 |
| M      | Liam   |    105 |
| M      | Mateo  |     95 |
| M      | Noah   |    110 |
+--------+--------+--------+
```

The two following queries:

* Rank the names by popularity
* Rank the names by popularity for each gender

Rank the names by popularity:

<pre><code>
SELECT gender, name,
<strong>       ROW_NUMBER() OVER (
</strong><strong>       ORDER BY babies DESC) AS popularity
</strong>FROM baby_names;

+--------+--------+------------+
| gender | name   | popularity |
+--------+--------+------------+
| M      | Noah   |          1 |
| M      | Liam   |          2 |
| F      | Olivia |          3 |
| M      | Mateo  |          4 |
| F      | Emma   |          5 |
| F      | Mia    |          6 |
+--------+--------+------------+
</code></pre>

Rank the names by popularity for each gender:

<pre><code>
SELECT gender, name,
<strong>       ROW_NUMBER() OVER (PARTITION BY gender
</strong><strong>       ORDER BY babies DESC) AS popularity
</strong>FROM baby_names;

+--------+--------+------------+
| gender | name   | popularity |
+--------+--------+------------+
| F      | Olivia |          1 |
| F      | Emma   |          2 |
| F      | Mia    |          3 |
| M      | Noah   |          1 |
| M      | Liam   |          2 |
| M      | Mateo  |          3 |
+--------+--------+------------+
</code></pre>

**ROW\_NUMBER VERSUS RANK VERSUS DENSE\_RANK**

There are three approaches to adding row numbers. Each one has a different way of handling ties.

`ROW_NUMBER` breaks the tie:

<pre><code>NAME     BABIES  POPULARITY
------- ------- ------------
Olivia       99            1
<strong>Emma         80            2
</strong><strong>Sophia       80            3 
</strong>Mia          75            4
</code></pre>

`RANK` keeps the tie:

<pre><code>NAME     BABIES  POPULARITY
------- ------- ------------
Olivia       99            1
<strong>Emma         80            2
</strong><strong>Sophia       80            2 
</strong>Mia          75            4
</code></pre>

`DENSE_RANK` keeps the tie and doesn’t skip numbers:

<pre><code>NAME     BABIES  POPULARITY
------- ------- ------------
Olivia       99            1
<strong>Emma         80            2
</strong><strong>Sophia       80            2
</strong><strong>Mia          75            3
</strong></code></pre>

### Return the First Value in Each Group

Use `FIRST_VALUE` and `LAST_VALUE` to return the first and last rows of a window, respectively.

The following queries break down the two-step process to return the most popular name for each gender.

Step 1: Display the most popular name for each gender.

<pre><code>
SELECT gender, name, babies,
<strong>       FIRST_VALUE(name) OVER (PARTITION BY gender
</strong><strong>       ORDER BY babies DESC) AS top_name
</strong>FROM baby_names;

+--------+--------+--------+----------+
| gender | name   | babies | top_name |
+--------+--------+--------+----------+
| F      | Olivia |    100 | Olivia   |
| F      | Emma   |     92 | Olivia   |
| F      | Mia    |     88 | Olivia   |
| M      | Noah   |    110 | Noah     |
| M      | Liam   |    105 | Noah     |
| M      | Mateo  |     95 | Noah     |
+--------+--------+--------+----------+
</code></pre>

Use the output as a subquery for the next step, which filters on the subquery.

Step 2: Return only the two rows containing the most popular names.

<pre><code>
<strong>SELECT * FROM
</strong>
(SELECT gender, name, babies,
       FIRST_VALUE(name) OVER (PARTITION BY gender
       ORDER BY babies DESC) AS top_name
FROM baby_names) AS top_name_table

<strong>WHERE name = top_name;
</strong>
+--------+--------+--------+----------+
| gender | name   | babies | top_name |
+--------+--------+--------+----------+
| F      | Olivia |    100 | Olivia   |
| M      | Noah   |    110 | Noah     |
+--------+--------+--------+----------+
</code></pre>

In _Oracle_, exclude the `AS top_name_table` portion.

### Return the Second Value in Each Group

Use `NTH_VALUE` to return a specific rank number within each window. _SQL Server_ does not support `NTH_VALUE`. Instead, refer to the code in the next section, [Return the first two values in each group](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#return\_the\_first\_two\_values\_in\_each\_group), but only return the second value.

The following queries break down the two-step process to return the second most popular name for each gender.

Step 1: Display the second most popular name for each gender.

<pre><code>
SELECT gender, name, babies,
<strong>       NTH_VALUE(name, 2) OVER (PARTITION BY gender
</strong><strong>       ORDER BY babies DESC) AS second_name
</strong>FROM baby_names;

+--------+--------+--------+-------------+
| gender | name   | babies | second_name |
+--------+--------+--------+-------------+
| F      | Olivia |    100 | NULL        |
| F      | Emma   |     92 | Emma        |
| F      | Mia    |     88 | Emma        |
| M      | Noah   |    110 | NULL        |
| M      | Liam   |    105 | Liam        |
| M      | Mateo  |     95 | Liam        |
+--------+--------+--------+-------------+
</code></pre>

The second parameter in `NTH_VALUE(name, 2)` is what specifies the second value in the window. This can be any positive integer.

Use the output as a subquery for the next step, which filters on the subquery.

Step 2: Return only the two rows containing the second most popular names.

<pre><code>
<strong>SELECT * FROM
</strong>
(SELECT gender, name, babies,
       NTH_VALUE(name, 2) OVER (PARTITION BY gender
       ORDER BY babies DESC) AS second_name
FROM baby_names) AS second_name_table

<strong>WHERE name = second_name;
</strong>
+--------+--------+--------+-------------+
| gender | name   | babies | second_name |
+--------+--------+--------+-------------+
| F      | Emma   |     92 | Emma        |
| M      | Liam   |    105 | Liam        |
+--------+--------+--------+-------------+
</code></pre>

In _Oracle_, exclude the `AS second_name_table` portion.

### Return the First Two Values in Each Group

Use [`ROW_NUMBER`](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#Rank\_the\_rows\_in\_a\_table) within a subquery to return multiple rank numbers within each group.

The following queries break down the two-step process to return the first and second most popular names for each gender.

Step 1: Display the popularity rank for each gender.

<pre><code>
SELECT gender, name, babies,
<strong>       ROW_NUMBER() OVER (PARTITION BY gender
</strong><strong>       ORDER BY babies DESC) AS popularity
</strong>FROM baby_names;

+--------+--------+--------+------------+
| gender | name   | babies | popularity |
+--------+--------+--------+------------+
| F      | Olivia |    100 |          1 |
| F      | Emma   |     92 |          2 |
| F      | Mia    |     88 |          3 |
| M      | Noah   |    110 |          1 |
| M      | Liam   |    105 |          2 |
| M      | Mateo  |     95 |          3 |
+--------+--------+--------+------------+
</code></pre>

Use the output as a subquery for the next step, which filters on the subquery.

Step 2: Filter on the rows that contain ranks 1 and 2.

<pre><code>
<strong>SELECT * FROM
</strong>
(SELECT gender, name, babies,
       ROW_NUMBER() OVER (PARTITION BY gender
       ORDER BY babies DESC) AS popularity
FROM baby_names) AS popularity_table

<strong>WHERE popularity IN (1,2);
</strong>
+--------+--------+--------+------------+
| gender | name   | babies | popularity |
+--------+--------+--------+------------+
| F      | Olivia |    100 |          1 |
| F      | Emma   |     92 |          2 |
| M      | Noah   |    110 |          1 |
| M      | Liam   |    105 |          2 |
+--------+--------+--------+------------+
</code></pre>

In _Oracle_, exclude the `AS popularity_table` portion.

### Return the Prior Row Value

Use `LAG` and `LEAD` to look a certain number of rows behind and ahead, respectively.

Use `LAG` to return the previous row:

<pre><code>SELECT gender, name, babies,
<strong>       LAG(name) OVER (PARTITION BY gender
</strong><strong>       ORDER BY babies DESC) AS prior_name
</strong>FROM baby_names;

+--------+--------+--------+------------+
| gender | name   | babies | prior_name |
+--------+--------+--------+------------+
| F      | Olivia |    100 | NULL       |
| F      | Emma   |     92 | Olivia     |
| F      | Mia    |     88 | Emma       |
| M      | Noah   |    110 | NULL       |
| M      | Liam   |    105 | Noah       |
| M      | Mateo  |     95 | Liam       |
+--------+--------+--------+------------+
</code></pre>

Use `LAG(name, 2, 'No name')` to return the names from two rows prior and replace `NULL` values with `No name`:

<pre><code>SELECT gender, name, babies,
<strong>       LAG(name, 2, 'No name')
</strong><strong>       OVER (PARTITION BY gender
</strong><strong>       ORDER BY babies DESC) AS prior_name_2
</strong>FROM baby_names;

+--------+--------+--------+--------------+
| gender | name   | babies | prior_name_2 |
+--------+--------+--------+--------------+
| F      | Olivia |    100 | No name      |
| F      | Emma   |     92 | No name      |
| F      | Mia    |     88 | Olivia       |
| M      | Noah   |    110 | No name      |
| M      | Liam   |    105 | No name      |
| M      | Mateo  |     95 | Noah         |
+--------+--------+--------+--------------+
</code></pre>

The `LAG` and `LEAD` functions each take three arguments: `LAG(name, 2, 'None')`

* `name` is the value you want to return. It is required.
* `2` is the row offset. It is optional and defaults to 1.
* `'No name'` is the value that will be returned when there is no value. It is optional and defaults to `NULL`.

### Calculate the Moving Average

Use a combination of the `AVG` function and the `ROWS BETWEEN` clause to calculate the moving average.

Here is a sample table:

```
SELECT * FROM sales;
```

```
+-------+-------+-------+
| name  | month | sales |
+-------+-------+-------+
| David |     1 |     2 |
| David |     2 |    11 |
| David |     3 |     6 |
| David |     4 |     8 |
| Laura |     1 |     3 |
| Laura |     2 |    14 |
| Laura |     3 |     7 |
| Laura |     4 |     1 |
| Laura |     5 |    20 |
+-------+-------+-------+
```

For each person, find the three-month moving average of sales, from two months prior to the current month:

<pre><code>SELECT name, month, sales,
<strong>       AVG(sales) OVER (PARTITION BY name
</strong>       ORDER BY month
<strong>       ROWS BETWEEN 2 PRECEDING AND
</strong><strong>       CURRENT ROW) three_month_ma
</strong>FROM sales;

+-------+-------+-------+----------------+
| name  | month | sales | three_month_ma |
+-------+-------+-------+----------------+
| David |     1 |     2 |         2.0000 |
| David |     2 |    11 |         6.5000 |
| David |     3 |     6 |         6.3333 |
| David |     4 |     8 |         8.3333 |
| Laura |     1 |     3 |         3.0000 |
| Laura |     2 |    14 |         8.5000 |
| Laura |     3 |     7 |         8.0000 |
| Laura |     4 |     1 |         7.3333 |
| Laura |     5 |    20 |         9.3333 |
+-------+-------+-------+----------------+
</code></pre>

**NOTE**

The preceding example looks at the two rows prior through the current row:

<pre><code><strong>ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
</strong></code></pre>

You can also look at the next rows using the `FOLLOWING` keyword:

<pre><code><strong>ROWS BETWEEN 2 PRECEDING AND 3 FOLLOWING
</strong></code></pre>

These ranges are sometimes referred to as _sliding windows_.

### Calculate the Running Total

Use a combination of the `SUM` function and the `ROWS BETWEEN UNBOUNDED` clause to calculate the running total.

For each person, find the running total of sales, up to the current month:

<pre><code>SELECT name, month, sales,
<strong>       SUM(sales) OVER (PARTITION BY name
</strong>       ORDER BY month
<strong>       ROWS BETWEEN UNBOUNDED PRECEDING AND
</strong><strong>       CURRENT ROW) running_total
</strong>FROM sales;

+-------+-------+-------+---------------+
| name  | month | sales | running_total |
+-------+-------+-------+---------------+
| David |     1 |     2 |             2 |
| David |     2 |    11 |            13 |
| David |     3 |     6 |            19 |
| David |     4 |     8 |            27 |
| Laura |     1 |     3 |             3 |
| Laura |     2 |    14 |            17 |
| Laura |     3 |     7 |            24 |
| Laura |     4 |     1 |            25 |
| Laura |     5 |    20 |            45 |
+-------+-------+-------+---------------+
</code></pre>

**NOTE**

Here, we calculated the running total for each person. To calculate the running total for the entire table, you can remove the `PARTITION BY name` portion of the code.

**ROWS VERSUS RANGE**

An alternative to `ROWS BETWEEN` is `RANGE BETWEEN`. The following query calculates the running total of sales made by all employees, using both the `ROWS` and `RANGE` keywords:

<pre><code>SELECT month, name,
<strong>  SUM(sales) OVER (ORDER BY month ROWS BETWEEN
</strong>  UNBOUNDED PRECEDING AND CURRENT ROW) rt_rows,
<strong>  SUM(sales) OVER (ORDER BY month RANGE BETWEEN
</strong>  UNBOUNDED PRECEDING AND CURRENT ROW) rt_range
FROM sales;

+-------+-------+----------+------------+
<strong>| month | name  | rt_rows | rt_range |
</strong>+-------+-------+----------+------------+
<strong>|     1 | David |        2 |         5 |
</strong><strong>|     1 | Laura |        5 |         5 |
</strong><strong>|     2 | David |       16 |        30 |
</strong><strong>|     2 | Laura |       30 |        30 |
</strong><strong>|     3 | David |       36 |        43 |
</strong><strong>|     3 | Laura |       43 |        43 |
</strong><strong>|     4 | David |       51 |        52 |
</strong><strong>|     4 | Laura |       52 |        52 |
</strong><strong>|     5 | Laura |       72 |        72 |
</strong>+-------+-------+----------+------------+
</code></pre>

The difference between the two is that `RANGE` will return the same running total value for each `month` (since the data was ordered by `month`), while `ROWS` will have a different running total value for each row.

## Pivoting and Unpivoting

_Oracle_ and _SQL Server_ support the `PIVOT` and `UNPIVOT` operations. `PIVOT` takes a single column and splits it out into multiple columns. `UNPIVOT` takes multiple columns and consolidates them into a single column.

### Break Up the Values of a Column into Multiple Columns

Imagine you have a table where each row is a person followed by a fruit that they ate that day. You want to take the `fruit` column and create a separate column for each fruit.

Here is a sample table:

```
SELECT * FROM fruits;

+------+-------+--------------+
| id   | name  | fruit        |
+------+-------+--------------+
|    1 | Henry | strawberries |
|    2 | Henry | grapefruit   |
|    3 | Henry | watermelon   |
|    4 | Lily  | strawberries |
|    5 | Lily  | watermelon   |
|    6 | Lily  | strawberries |
|    7 | Lily  | watermelon   |
+------+-------+--------------+
```

Expected output:

```
+-------+--------------+------------+------------+
| name  | strawberries | grapefruit | watermelon |
+-------+--------------+------------+------------+
| Henry |            1 |          1 |          1 |
| Lily  |            2 |          0 |          2 |
+-------+--------------+------------+------------+
```

Use the `PIVOT` operation in _Oracle_ and _SQL Server_:

<pre><code>-- Oracle
SELECT *
FROM fruits
<strong>PIVOT
</strong><strong>(COUNT(id) FOR fruit IN ('strawberries',
</strong><strong>                'grapefruit', 'watermelon'));
</strong>
-- SQL Server
SELECT *
FROM fruits
<strong>PIVOT
</strong><strong>(COUNT(id) FOR fruit IN ([strawberries],
</strong><strong>                [grapefruit], [watermelon])
</strong><strong>) AS fruits_pivot;
</strong></code></pre>

Within the `PIVOT` section, the `id` and `fruit` columns are referenced, but the `name` column is not. Therefore, the `name` column will stay as its own column in the final result and each fruit will be turned into a new column.

The values of the table are the count of the number of rows in the original table that contained each particular `name`/`fruit` combination.

**PIVOT ALTERNATIVE: CASE**

A more manual way of doing a `PIVOT` is to use a [CASE statement](https://learning.oreilly.com/library/view/sql-pocket-guide/9781492090397/ch08.html#case\_statements) instead in _MySQL_, _PostgreSQL_, and _SQLite_ since they do not support `PIVOT`.

<pre><code>SELECT name,
<strong>       SUM(CASE WHEN fruit = 'strawberries'
</strong><strong>            THEN 1 ELSE 0 END) AS strawberries,
</strong><strong>       SUM(CASE WHEN fruit = 'grapefruit'
</strong><strong>            THEN 1 ELSE 0 END) AS grapefruit,
</strong><strong>       SUM(CASE WHEN fruit = 'watermelon'
</strong><strong>            THEN 1 ELSE 0 END) AS watermelon
</strong>FROM fruits
GROUP BY name
ORDER BY name;
</code></pre>

### List the Values of Multiple Columns in a Single Column

Imagine you have a table where each row is a person followed by multiple columns that contain their favorite fruits. You want to rearrange the data so that all of the fruits are in one column.

Here is a sample table:

```
SELECT * FROM favorite_fruits;

+----+-------+-----------+-----------+-----------+
| id | name  | fruit_one | fruit_two | fruit_thr |
+----+-------+-----------+-----------+-----------+
|  1 | Anna  | apple     | banana    |           |
|  2 | Barry | raspberry |           |           |
|  3 | Liz   | lemon     | lime      | orange    |
|  4 | Tom   | peach     | pear      | plum      |
+----+-------+-----------+-----------+-----------+
```

Expected output:

```
+----+-------+-----------+------+
| id | name  | fruit     | rank |
+----+-------+-----------+------+
|  1 | Anna  | apple     |    1 |
|  1 | Anna  | banana    |    2 |
|  2 | Barry | raspberry |    1 |
|  3 | Liz   | lemon     |    1 |
|  3 | Liz   | lime      |    2 |
|  3 | Liz   | orange    |    3 |
|  4 | Tom   | peach     |    1 |
|  4 | Tom   | pear      |    2 |
|  4 | Tom   | plum      |    3 |
+----+-------+-----------+------+
```

Use the `UNPIVOT` operation in _Oracle_ and _SQL Server_:

<pre><code>-- Oracle
SELECT *
FROM favorite_fruits
<strong>UNPIVOT
</strong><strong>(fruit FOR rank IN (fruit_one AS 1,
</strong><strong>    fruit_two AS 2,
</strong><strong>    fruit_thr AS 3));
</strong>
-- SQL Server
SELECT *
FROM favorite_fruits
<strong>UNPIVOT
</strong><strong>(fruit FOR rank IN (fruit_one,
</strong><strong>                    fruit_two,
</strong><strong>                    fruit_thr)
</strong><strong>) AS fruit_unpivot
</strong><strong>WHERE fruit &#x3C;> '';
</strong></code></pre>

The `UNPIVOT` section takes the columns `fruit_one`, `fruit_two`, and `fruit_thr` and consolidates them into a single column called `fruit`.

Once that’s done, you can go ahead and use a typical `SELECT` statement to pull the original `id` and `name` columns along with the newly created `fruit` column.

**UNPIVOT ALTERNATIVE: UNION ALL**

A more manual way of doing an `UNPIVOT` is to use `UNION ALL` instead in _MySQL_, _PostgreSQL_, and _SQLite_ since they do not support `UNPIVOT`.

<pre><code>WITH all_fruits AS
(SELECT id, name,
        fruit_one as fruit,
        1 AS rank
FROM favorite_fruits
<strong>UNION ALL
</strong>SELECT id, name,
       fruit_two as fruit,
       2 AS rank
FROM favorite_fruits
<strong>UNION ALL
</strong>SELECT id, name,
       fruit_three as fruit,
       3 AS rank
FROM favorite_fruits)

SELECT *
FROM all_fruits
WHERE fruit &#x3C;> ''
ORDER BY id, name, fruit;
</code></pre>

_MySQL_ does not support inserting a constant into a column within a query (`1 AS rank`, `2 AS rank`, and `3 AS rank`). Remove those lines for the code to run.
