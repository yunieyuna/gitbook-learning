# 16. Using PostgreSQL From The Command Line

### **16** **USING POSTGRESQL FROM THE COMMAND LINE** <a href="#ch16" id="ch16"></a>

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/common01.jpg)

Before computers featured a graphical user interface (GUI), which lets you use menus, icons, and buttons to navigate applications, the main way to issue instructions to them was by entering commands on the _command line_. The command line—also called a command line interface, console, shell, or terminal—is a text-based interface where you enter names of programs or other commands to perform tasks, such as editing files or listing the contents of a file directory.

When I was in college, to edit a file, I had to enter commands into a terminal connected to an IBM mainframe computer. The reams of text that then scrolled onscreen were reminiscent of the green characters that define the virtual world portrayed in _The Matrix_. It felt mysterious and as though I had attained new powers. Even today, movies portray fictional hackers by showing them entering cryptic, text-only commands on a computer.

In this chapter, I’ll show you how to access this text-only world. Here are some advantages of working from the command line instead of a GUI, such as pgAdmin:

* You can often work faster by entering short commands instead of clicking through layers of menu items.
* You gain access to some functions that only the command line provides.
* If command line access is all you have to work with (for example, when you’ve connected to a remote computer), you can still get work done.

We’ll use psql, a command line tool in PostgreSQL that lets you run queries, manage database objects, and interact with the computer’s operating system via text command. You’ll first learn how to set up and access your computer’s command line, and then launch psql.

It takes time to learn how to use the command line, and even experienced experts often resort to documentation to recall the available command line options. But learning to use the command line greatly enhances your work efficiency.

#### Setting Up the Command Line for psql <a href="#lev286" id="lev286"></a>

To start, we’ll access the command line on your operating system and set an _environment variable_ called PATH that tells your system where to find psql. Environment variables hold parameters that specify system or application configurations, such as where to store temporary files, or allow you to enable or disable options. Setting PATH, which stores the names of one or more directories containing executable programs, tells the command line interface the location of psql, avoiding the hassle of having to enter its full directory path each time you launch it.

_**Windows psql Setup**_

On Windows, you’ll run psql within Command Prompt, the application that provides that system’s command line interface. Let’s start by using PATH to tell Command Prompt where to find _psql.exe_, which is the full name of the psql application on Windows, as well as other PostgreSQL command line utilities.

**Adding psql and Utilities to the Windows PATH**

The following steps assume that you installed PostgreSQL according to the instructions described in [“Windows Installation”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/intro.xhtml#introlev3sec1) on page xxix. (If you installed PostgreSQL another way, use the Windows File Explorer to search your C: drive to find the directory that holds _psql.exe_, and then replace _C:\Program Files\PostgreSQL\x.y\bin_ in steps 5 and 6 with your own path.)

1. Open the Windows Control Panel. Enter **Control Panel** in the search box on the Windows taskbar, and then click the **Control Panel** icon.
2. Inside the Control Panel app, enter **Environment** in the search box at the top right. In the list of search results displayed, click **Edit the System Environment Variables**. A System Properties dialog should appear.
3. In the System Properties dialog, on the Advanced tab, click **Environment Variables**. The dialog that opens should have two sections: User variables and System variables. In the User variables section, if you don’t see a PATH variable, continue to step a to create a new one. If you do see an existing PATH variable, continue to step b to modify it.
   1.  If you don’t see PATH in the User variables section, click **New** to open a New User Variable dialog, shown in [Figure 16-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16fig1).

       ![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/f0293-01.jpg)

       _Figure 16-1: Creating a new PATH environment variable in Windows 10_

       In the Variable name box, enter **PATH**. In the Variable value box, enter **C:\Program Files\PostgreSQL\\**_**x**_**.**_**y**_**\bin**, where _**x**_**.**_**y**_ is the version of PostgreSQL you’re using. Click **OK** to close all the dialogs.
   2. If you do see an existing PATH variable in the User variables section, highlight it and click **Edit**. In the list of variables that displays, click **New** and enter **C:\Program Files\PostgreSQL\\**_**x**_**.**_**y**_**\bin**, where _**x**_**.**_**y**_ is the version of PostgreSQL you’re using. It should look like the highlighted line in [Figure 16-2](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16fig2). When you’re finished, click **OK** to close all the dialogs.

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/f0294-01.jpg)

_Figure 16-2: Editing existing PATH environment variables in Windows 10_

Now when you launch Command Prompt, the PATH should include the directory. Note that any time you make changes to the PATH, you must close and reopen Command Prompt for the changes to take effect. Next, let’s set up Command Prompt.

**Launching and Configuring the Windows Command Prompt**

Command Prompt is an executable file named _cmd.exe_. To launch it, select **Start ▸ Windows System ▸ Command Prompt**. When the application opens, you should see a window with a black background that displays version and copyright information along with a prompt showing your current directory. On my Windows 10 system, Command Prompt opens to my default user directory and displays C:\Users\Anthony>, as shown in [Figure 16-3](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16fig3).

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/f0294-02.jpg)

_Figure 16-3: My Command Prompt in Windows 10_

**NOTE**

_For fast access to Command Prompt, you can add it to your Windows taskbar. When Command Prompt is running, right-click its icon on the taskbar and then select **Pin to taskbar**._

The line C:\Users\Anthony> indicates that Command Prompt’s current working directory is my C: drive, which is typically the main hard drive on a Windows system, and the _\Users\Anthony_ directory on that drive. The right arrow (>) indicates the area where you type your commands.

You can customize the font and colors plus access other settings by clicking the Command Prompt icon at the left of its window bar and selecting **Properties** from the menu. To make Command Prompt more suited for query output, I recommend setting the window size (on the Layout tab) to a width of 80 and a height of 25. My preferred font is Lucida Console 14, but experiment to find one you like.

**Entering Instructions on Windows Command Prompt**

Now you’re ready to enter instructions in Command Prompt. Enter **help** at the prompt, and press ENTER on your keyboard to see a list of available commands. You can view information about a particular command by typing its name after **help**. For example, enter **help time** to display information on using the **time** command to set or view the system time.

Exploring the full workings of Command Prompt is beyond the scope of this book; however, you should try some of the commands in [Table 16-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16tab1), which contains frequently used commands you’ll find immediately useful but are not necessary for the exercises in this chapter. Also, check out Command Prompt cheat sheets online for more information.

**Table 16-1:** Useful Windows Commands

| **Command** | **Function**                                             | **Example**                                           | **Action**                                                                                                  |
| ----------- | -------------------------------------------------------- | ----------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| cd          | Change directory                                         | cd C:\my-stuff                                        | Change to the _my-stuff_ directory on the C: drive                                                          |
| copy        | Copy a file                                              | copy C:\my-stuff\song.mp3 C:\Music\song\_favorite.mp3 | Copy the _song.mp3_ file from _my-stuff_ to a new file called _song\_favorite.mp3_ in the _Music_ directory |
| del         | Delete                                                   | del \*.jpg                                            | Delete all files with a _.jpg_ extension in the current directory (asterisk wildcard)                       |
| dir         | List directory contents                                  | dir /p                                                | Show directory contents one screen at a time (using the /p option)                                          |
| findstr     | Find strings in text files matching a regular expression | findstr "peach" \*.txt                                | Search for the text “peach” in all _.txt_ files in the current directory                                    |
| mkdir       | Make a new directory                                     | makedir C:\my-stuff\Salad                             | Create a _Salad_ directory inside the _my-stuff_ directory                                                  |
| move        | Move a file                                              | move C:\my-stuff\song.mp3 C:\Music\\                  | Move the file _song.mp3_ to the _C:\Music_ directory                                                        |

With your Command Prompt open and configured, you’re ready to roll. Skip ahead to [“Working with psql”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#lev290) on [page 299](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#page\_299).

_**macOS psql Setup**_

On macOS, you’ll run psql within Terminal, the application that provides access to that system’s command line via a _shell_ program called bash. Shell programs on Unix- or Linux-based systems, including macOS, provide not only the command prompt where users enter instructions, but also their own programming language for automating tasks. For example, you can use bash commands to write a program to log in to a remote computer, transfer files, and log out. Let’s start by telling bash where to find psql and other PostgreSQL command line utilities by setting the PATH environment variable. Then we’ll launch Terminal.

**Adding psql and Utilities to the macOS PATH**

Before Terminal loads the bash shell, it checks for the presence of several optional text files that can supply configuration information. We’ll place our PATH information inside _.bash\_profile_, which is one of these optional text files. Then, whenever we open Terminal, the startup process should read _.bash\_profile_ and obtain the PATH value.

**NOTE**

_You can also use_ .bash\_profile _to set your command line’s colors, automatically run programs, and create shortcuts, among other tasks. See_ [https://natelandau.com/my-mac-osx-bash\_profile/](https://natelandau.com/my-mac-osx-bash\_profile/) _for a great example of customizing the file_.

On Unix- or Linux-based systems, files that begin with a period are called _dot files_ and are hidden by default. We’ll need to edit _.bash\_profile_ to add PATH. Using the following steps, unhide _.bash\_profile_ so it appears in the macOS Finder:

1. Launch Terminal by navigating to **Applications ▸ Utilities ▸ Terminal**.
2.  At the command prompt, which displays your username and computer name followed by a dollar sign ($), enter the following text and then press RETURN:

    defaults write com.apple.finder AppleShowAllFiles YES
3. Quit Terminal (⌘-Q). Then, while holding down the OPTION key, right-click the Finder icon on your Mac dock, and select **Relaunch**.

Follow these steps to edit or create _.bash\_profile_:

1. Using the macOS Finder, navigate to your user directory by opening the Finder and clicking **Macintosh HD** then **Users**.
2. Open your user directory (it should have a house icon). Because you changed the setting to show hidden files, you should now see grayed-out files and directories, which are normally hidden, along with regular files and directories.
3. Check for an existing _.bash\_profile_ file. If one exists, right-click and open it with your preferred text editor or use the macOS TextEdit app. If _.bash\_profile_ doesn’t exist, open TextEdit to create and save a file with that name to your user directory.

Next, we’ll add a PATH statement to _.bash\_profile_. These instructions assume you installed PostgreSQL using Postgres.app, as outlined in [“macOS Installation”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/intro.xhtml#introlev3sec2) on page xxx. To add to the path, place the following line in _.bash\_profile_:

export PATH="/Applications/Postgres.app/Contents/Versions/latest/bin:$PATH"

Save and close the file. If Terminal is open, close and relaunch it before moving on to the next section.

**Launching and Configuring the macOS Terminal**

Launch Terminal by navigating to **Applications ▸ Utilities ▸ Terminal**. When it opens, you should see a window that displays the date and time of your last login followed by a prompt that includes your computer name, current working directory, and username, ending with a dollar sign ($). On my Mac, the prompt displays ad:\~ anthony$, as shown in [Figure 16-4](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16fig4).

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/f0297-01.jpg)

_Figure 16-4: Terminal command line in macOS_

The tilde (\~) indicates that Terminal is currently working in my home directory, which is /Users/anthony. Terminal doesn’t display the full directory path, but you can see that information at any time by entering the pwd command (short for “print working directory”) and pressing RETURN on your keyboard. The area after the dollar sign is where you type commands.

**NOTE**

_For fast access to Terminal, add it to your macOS Dock. While Terminal is running, right-click its icon and select **Options ▸ Keep in Dock**._

If you’ve never used Terminal, its default black and white color scheme might seem boring. You can change fonts, colors, and other settings by selecting **Terminal ▸ Preferences**. To make Terminal bigger to better fit the query output display, I recommend setting the window size (on the Window tab) to a width of 80 columns and a height of 25 rows. My preferred font (on the Text tab) is Monaco 14, but experiment to find one you like.

Exploring the full workings of Terminal and related commands is beyond the scope of this book, but take some time to try several commands. [Table 16-2](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16tab2) lists commonly used commands you’ll find immediately useful but not necessary for the exercises in this chapter. Enter **man** (short for “manual”) followed by a command name to get help on any command. For example, you can use **man ls** to find out how to use the **ls** command to list directory contents.

**Table 16-2:** Useful Terminal Commands

| **Command** | **Function**                                              | **Example**                      | **Action**                                                                                         |
| ----------- | --------------------------------------------------------- | -------------------------------- | -------------------------------------------------------------------------------------------------- |
| cd          | Change directory                                          | cd /Users/pparker/my-stuff/      | Change to the _my-stuff_ directory                                                                 |
| cp          | Copy files                                                | cp song.mp3 song\_backup.mp3     | Copy the file _song.mp3_ to _song\_backup.mp3_ in the current directory                            |
| grep        | Find strings in a text file matching a regular expression | grep 'us\_counties\_2010' \*.sql | Find all lines in files with a _.sql_ extension that have the text “us\_counties\_2010”            |
| ls          | List directory contents                                   | ls -al                           | List all files and directories (including hidden) in “long” format                                 |
| mkdir       | Make a new directory                                      | mkdir resumes                    | Make a directory named _resumes_ under the current working directory                               |
| mv          | Move a file                                               | mv song.mp3 /Users/pparker/songs | Move the file _song.mp3_ from the current directory to a _/songs_ directory under a user directory |
| rm          | Remove (delete) files                                     | rm \*.jpg                        | Delete all files with a _.jpg_ extension in the current directory (asterisk wildcard)              |

With your Terminal open and configured, you’re ready to roll. Skip ahead to [“Working with psql”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#lev290) on [page 299](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#page\_299).

_**Linux psql Setup**_

Recall from [“Linux Installation”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/intro.xhtml#introlev3sec3) on page xxxi that methods for installing PostgreSQL vary according to your Linux distribution. Nevertheless, psql is part of the standard PostgreSQL install, and you probably already ran psql commands as part of the installation process via your distribution’s command line terminal application. Even if you didn’t, standard Linux installations of PostgreSQL will automatically add psql to your PATH, so you should be able to access it.

Launch a terminal application. On some distributions, such as Ubuntu, you can open a terminal by pressing CTRL-ALT-T. Also note that the macOS Terminal commands in [Table 16-2](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16tab2) apply to Linux as well and may be useful to you.

With your terminal open, you’re ready to roll. Proceed to the next section, “Working with psql.”

#### Working with psql <a href="#lev290" id="lev290"></a>

Now that you’ve identified your command line interface and set it up to recognize the location of psql, let’s launch psql and connect to a database on your local installation of PostgreSQL. Then we’ll explore executing queries and special commands for retrieving database information.

_**Launching psql and Connecting to a Database**_

Regardless of the operating system you’re using, you start psql in the same way. Open your command line interface (Command Prompt on Windows, Terminal on macOS or Linux). To launch psql, we use the following pattern at the command prompt:

psql -d _database\_name_ -U _user\_name_

Following the psql application name, we provide the database name after a -d argument and a username after -U.

For the database name, we’ll use analysis, which is where we created the majority of our tables for the book’s exercises. For username, we’ll use postgres, which is the default user created during installation. For example, to connect your local machine to the analysis database, you would enter this:

psql -d analysis -U postgres

You can connect to a database on a remote server by specifying the -h argument followed by the host name. For example, you would use the following line if you were connecting to a computer on a server called example.com:

psql -d analysis -U postgres -h example.com

If you set a password during installation, you should receive a password prompt when psql launches. If so, enter your password and press ENTER. You should then see a prompt that looks like this:

psql (10.1)\
Type "help" for help.\
\
analysis=#

Here, the first line lists the version number of psql and the server you’re connected to. Your version will vary depending on when you installed PostgreSQL. The prompt where you’ll enter commands is analysis=#, which refers to the name of the database, followed by an equal sign (=) and a hash mark (#). The hash mark indicates that you’re logged in with _superuser_ privileges, which give you unlimited ability to access and create objects and set up accounts and security. If you’re logged in as a user without superuser privileges, the last character of the prompt will be a greater-than sign (>). As you can see, the user account you logged in with here (postgres) is a superuser.

**NOTE**

_PostgreSQL installations create a default superuser account called postgres. If you’re running postgres.app on macOS, that installation created an additional superuser account that has your system username and no password._

_**Getting Help**_

At the psql prompt, you can easily get help with psql commands and SQL commands. [Table 16-3](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16tab3) lists commands you can type at the psql prompt and shows the information they’ll display.

**Table 16-3:** Help Commands Within psql

| **Command**   | **Displays**                                                                                   |
| ------------- | ---------------------------------------------------------------------------------------------- |
| \\?           | Commands available within psql, such as \dt to list tables.                                    |
| \\? options   | Options for use with the psql command, such as -U to specify a username.                       |
| \\? variables | Variables for use with psql, such as VERSION for the current psql version.                     |
| \h            | List of SQL commands. Add a command name to see detailed help for it (for example, \h INSERT). |

Even experienced users often need a refresher on commands and options, and having the details in the psql application is handy. Let’s move on and explore some commands.

_**Changing the User and Database Connection**_

You can use a series of _meta-commands_, which are preceded by a backslash, to issue instructions to psql rather than the database. For example, to connect to a different database or switch the user account you’re connected to, you can use the \c meta-command. To switch to the gis\_analysis database we created in [Chapter 14](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14), enter \c followed by the name of the database at the psql prompt:

analysis=# \c gis\_analysis

The application should respond with the following message:

You are now connected to database "gis\_analysis" as user "postgres".\
gis\_analysis=#

To log in as a different user, for example, using a username the macOS installation created for me, I could add that username after the database name. On my Mac, the syntax looks like this:

analysis-# \c gis\_analysis anthony

The response should be as follows:

You are now connected to database "gis\_analysis" as user "anthony".\
gis\_analysis=#

You might have various reasons to use multiple user accounts like this. For example, you might want to create a user account with limited permissions for colleagues or for a database application. You can learn more about creating and managing user roles by reading the PostgreSQL documentation at [_https://www.postgresql.org/docs/current/static/sql-createrole.html_](https://www.postgresql.org/docs/current/static/sql-createrole.html).

Let’s switch back to the analysis database using the \c command. Next, we’ll enter SQL commands at the psql prompt.

_**Running SQL Queries on psql**_

We’ve configured psql and connected to a database, so now let’s run some SQL queries, starting with a single-line query and then a multiline query.

To enter SQL into psql, you can type it directly at the prompt. For example, to see a few rows from the 2010 Census table we’ve used throughout the book, enter a query at the prompt, as shown in [Listing 16-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list1):

analysis=# SELECT geo\_name FROM us\_counties\_2010 LIMIT 3;

_Listing 16-1: Entering a single-line query in psql_

Press ENTER to execute the query, and psql should display the following results in text including the number of rows returned:

&#x20;   geo\_name\
\----------------\
&#x20;Autauga County\
&#x20;Baldwin County\
&#x20;Barbour County\
(3 rows)\
\
analysis=#

Below the result, you can see the analysis=# prompt again, ready for further input from the user. Press the up and down arrows on your keyboard to you scroll through recent queries to avoid having to retype them. Or you can simply enter a new query.

**Entering a Multiline Query**

You’re not limited to single-line queries. For example, you can press ENTER each time you want to enter a new line. Note that psql won’t execute the query until you provide a line that ends with a semicolon. To see an example, reenter the query in [Listing 16-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list1) using the format shown in [Listing 16-2](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list2):

analysis=# SELECT geo\_name\
analysis-# FROM us\_counties\_2010\
analysis-# LIMIT 3;

_Listing 16-2: Entering a multiline query in psql_

Note that when your query extends past one line, the symbol between the database name and the hash mark changes from an equal sign (=) to a hyphen (-). This multiline query executes only when you press ENTER after the final line, which ends with a semicolon.

**Checking for Open Parentheses in the psql Prompt**

Another helpful feature of psql is that it shows when you haven’t closed a pair of parentheses. [Listing 16-3](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list3) shows this in action:

analysis=# CREATE TABLE wineries (\
analysis(# id bigint,\
analysis(# winery\_name varchar(100)\
analysis(# );\
CREATE TABLE

_Listing 16-3: Showing open parentheses in the psql prompt_

Here, you create a simple table called wineries that has two columns. After entering the first line of the CREATE TABLE statement and an open parenthesis, the prompt then changes from analysis=# to analysis(# to include an open parenthesis that reminds you an open parenthesis needs closing. The prompt maintains that configuration until you add the closing parenthesis.

**NOTE**

_If you have a lengthy query saved in a text file, such as one from this book’s resources, you can copy it to your computer clipboard and paste it into psql (CTRL-V on Windows,_ ⌘_-V on macOS, and SHIFT-CTRL-V on Linux). That saves you from typing the whole query. After you paste the query text into psql, press ENTER to execute it._

**Editing Queries**

If you’re working with a query in psql and want to modify it, you can edit it using the \e or \edit meta-command. Enter \e to open the last-executed query in a text editor. Which editor psql uses by default depends on your operating system.

On Windows, psql defaults to Notepad, a simple GUI text editor. On macOS and Linux, psql uses a command line application called vim, which is a favorite among programmers but can seem inscrutable for beginners. Check out a helpful vim cheat sheet at [_https://vim.rtorr.com/_](https://vim.rtorr.com/). For now, you can use the following steps to make simple edits:

* When vim opens the query in an editing window, press **I** to activate insert mode.
* Make your edits to the query.
* Press ESC and then SHIFT+: to display a colon command prompt at the bottom left of the vim screen, which is where you enter commands to control vim.
* Enter **wq** (for “write, quit”) and press ENTER to save your changes.

Now when you exit to the psql prompt, it should execute your revised query. Press the up arrow key to see the revised text.

_**Navigating and Formatting Results**_

The query you ran in [Listings 16-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list1) and [16-2](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list2) returned only one column and a handful of rows, so its output was contained nicely in your command line interface. But for queries with more columns or rows, the output can take up more than one screen, making it difficult to navigate. Fortunately, you can use formatting options using the \pset meta-command to tailor the output into a format you prefer.

**Setting Paging of Results**

You can adjust the output format by specifying how psql displays lengthy query results. For example, [Listing 16-4](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list4) shows the change in output format when we remove the LIMIT clause from the query in [Listing 16-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list1) and execute it at the psql prompt:

analysis=# SELECT geo\_name FROM us\_counties\_2010;\
&#x20;            geo\_name\
\-----------------------------------\
&#x20;Autauga County\
&#x20;Baldwin County\
&#x20;Barbour County\
&#x20;Bibb County\
&#x20;Blount County\
&#x20;Bullock County\
&#x20;Butler County\
&#x20;Calhoun County\
&#x20;Chambers County\
&#x20;Cherokee County\
&#x20;Chilton County\
&#x20;Choctaw County\
&#x20;Clarke County\
&#x20;Clay County\
&#x20;Cleburne County\
&#x20;Coffee County\
&#x20;Colbert County\
:

[_Listing 16-4_](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list4)_: A query with scrolling results_

Recall that this table has 3,143 rows. [Listing 16-4](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list4) shows only the first 17 on the screen with a colon at the bottom (the number of visible rows depends on your terminal configuration). The colon indicates that there are more results than shown; press the down arrow key to scroll through them. Scrolling through this many rows can take a while. Press Q at any time to exit the scrolling results and return to the psql prompt.

You can have your results immediately scroll to the end by changing the pager setting using the \pset pager meta-command. Run that command at your psql prompt, and it should return the message Pager usage is off. Now when you rerun the query in [Listing 16-3](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list3) with the pager setting turned off, you should see something like this:

_--snip--_\
&#x20;Niobrara County\
&#x20;Park County\
&#x20;Platte County\
&#x20;Sheridan County\
&#x20;Sublette County\
&#x20;Sweetwater County\
&#x20;Teton County\
&#x20;Uinta County\
&#x20;Washakie County\
&#x20;Weston County\
(3143 rows)\
\
analysis=#

You’re immediately taken to the end of the results without having to scroll. To turn paging back on, run \pset pager again.

**Formatting the Results Grid**

You can also use the \pset meta-command with the following options to format how the results look:

border _**int**_ Use this option to specify whether the results grid has no border (0), internal lines dividing columns (1), or lines around all cells (2). For example, \pset border 2 sets lines around all cells.

format unaligned Use the option \pset format unaligned to display the results in lines separated by a delimiter rather than in columns, similar to what you would see in a CSV file. The separator defaults to a pipe symbol (|). You can set a different separator using the fieldsep command. For example, to set a comma as the separator, run \pset fieldsep ','. To revert to a column view, run \pset format aligned. You can use the psql meta-command \a to toggle between aligned and unaligned views.

footer Use this option to toggle the results footer, which displays the result row count, on or off.

null Use this option to set how null values are displayed. By default, they show as blanks. You can run \pset null 'NULL' to replace blanks with all-caps NULL when the column value is NULL.

You can explore additional options in the PostgreSQL documentation at [_https://www.postgresql.org/docs/current/static/app-psql.html_](https://www.postgresql.org/docs/current/static/app-psql.html). In addition, it’s possible to set up a _.psqlrc_ file on macOS or Linux or a _psqlrc.conf_ file on Windows to hold your configuration preferences and load them each time psql starts. A good example is provided at [_https://www.citusdata.com/blog/2017/07/16/customizing-my-postgres-shell-using-psqlrc/_](https://www.citusdata.com/blog/2017/07/16/customizing-my-postgres-shell-using-psqlrc/).

**Viewing Expanded Results**

Sometimes, it’s helpful to view results as a vertical block listing rather than in rows and columns, particularly when data is too big to fit onscreen in the normal horizontal results grid. Also, I often employ this format when I want an easy-to-scan way to review the values in columns on a row-by-row basis. In psql, you can switch to this view using the \x (for expanded) meta-command. The best way to understand the difference between normal and expanded view is by looking at an example. [Listing 16-5](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list5) shows the normal display you see when querying the grades table in [Chapter 15](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15) using psql:

analysis=# SELECT \* FROM grades;\
&#x20;student\_id | course\_id |      course       | grade\
\------------+-----------+-------------------+-------\
&#x20;         1 |         2 | English 11B       | D\
&#x20;         1 |         3 | World History 11B | C\
&#x20;         1 |         4 | Trig 2            | B\
&#x20;         1 |         1 | Biology 2         | C\
(4 rows)

_Listing 16-5: Normal display of the grades table query_

To change to the expanded view, enter \x at the psql prompt, which should display the Expanded display is on message. Then, when you run the same query again, you should see the expanded results, as shown in [Listing 16-6](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list6):

analysis=# SELECT \* FROM grades;\
\-\[ RECORD 1 ]-----------------\
student\_id | 1\
course\_id  | 2\
course     | English 11B\
grade      | D\
\-\[ RECORD 2 ]-----------------\
student\_id | 1\
course\_id  | 3\
course     | World History 11B\
grade      | C\
\-\[ RECORD 3 ]-----------------\
student\_id | 1\
course\_id  | 4\
course     | Trig 2\
grade      | B\
\-\[ RECORD 4 ]-----------------\
student\_id | 1\
course\_id  | 1\
course     | Biology 2\
grade      | C

_Listing 16-6: Expanded display of the grades table query_

The results appear in vertical blocks separated by record numbers. Depending on your needs and the type of data you’re working with, this format might be easier to read. You can revert to column display by entering \x again at the psql prompt. In addition, setting \x auto will make PostgreSQL automatically display the results in a table or expanded view based on the size of the output.

Next, let’s explore how to use psql to dig into database information.

_**Meta-Commands for Database Information**_

In addition to writing queries from the command line, you can also use psql to display details about tables and other objects and functions in your database. To do this, you use a series of meta-commands that start with \d and append a plus sign (+) to expand the output. You can also supply an optional pattern to filter the output.

For example, you can enter \dt+ to list all tables in the database and their size. Here’s a snippet of the output on my system:

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/prog\_page\_306.jpg)

This result lists all tables in the current database alphabetically.

You can filter the output by adding a pattern to match using a regular expression. For example, use \dt+ us\* to show only tables whose names begin with us (the asterisk acts as a wildcard). The results should look like this:

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/prog\_page\_307.jpg)

[Table 16-4](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16tab4) shows several additional \d commands you might find helpful.

**Table 16-4:** Examples of psql \d Commands

| **Command**    | **Displays**                                           |
| -------------- | ------------------------------------------------------ |
| \d \[pattern]  | Columns, data types, plus other information on objects |
| \di \[pattern] | Indexes and their associated tables                    |
| \dt \[pattern] | Tables and the account that owns them                  |
| \du \[pattern] | User accounts and their attributes                     |
| \dv \[pattern] | Views and the account that owns them                   |
| \dx \[pattern] | Installed extensions                                   |

The entire list of \d commands is available in the PostgreSQL documentation at [_https://www.postgresql.org/docs/current/static/app-psql.html_](https://www.postgresql.org/docs/current/static/app-psql.html), or you can see details by using the \\? command noted earlier.

_**Importing, Exporting, and Using Files**_

Now let’s explore how to get data in and out of tables or save information when you’re working on a remote server. The psql command line tool offers one meta-command for importing and exporting data (\copy) and another for copying query output to a file (\o). We’ll start with the \copy command.

**Using \copy for Import and Export**

In [Chapter 4](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch04.xhtml#ch04), you learned how to use the SQL COPY command to import and export data. It’s a straightforward process, but there is one significant limitation: the file you’re importing or exporting must be on the same machine as the PostgreSQL server. That’s fine if you’re working on your local machine, as you’ve been doing with these exercises. But if you’re connecting to a database on a remote computer, you might not have access to the file system to provide a file to import or to fetch a file you’ve exported. You can get around this restriction by using the \copy meta-command in psql.

The \copy meta-command works just like the SQL COPY command except when you execute it at the psql prompt, it can route data from your local machine to a remote server if that’s what you’re connected to. We won’t actually connect to a remote server to try this, but you can still learn the syntax.

In [Listing 16-7](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list7), we use psql to DROP the small state\_regions table you created in [Chapter 9](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch09.xhtml#ch09), and then re-create the table and import data using \copy. You’ll need to change the file path to match the location of the file on your computer.

analysis=# DROP TABLE state\_regions;\
DROP TABLE\
\
analysis=# CREATE TABLE state\_regions (\
analysis(#     st varchar(2) CONSTRAINT st\_key PRIMARY KEY,\
analysis(#     region varchar(20) NOT NULL\
analysis(# );\
\
CREATE TABLE\
\
analysis=# \copy state\_regions FROM '_C:\YourDirectory\\_state\_regions.csv' WITH (FORMAT CSV, HEADER);\
COPY 56

_Listing 16-7: Importing data using \copy_

The DROP TABLE and CREATE TABLE statements in [Listing 16-7](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list7) are straightforward. We first delete the state\_regions table if it exists, and then re-create it. Then, to load the table, we use \copy with the same syntax used with SQL COPY, naming a FROM clause that includes the file path on your machine, and a WITH clause that specifies the file is a CSV and has a header row. When you execute the statement, the server should respond with COPY 56, letting you know the rows have been successfully imported.

If you were connected via psql to a remote server, you would use the same \copy syntax, and the command would just route your local file to the remote server for importing. In this example, we used \copy FROM to import a file. We could also use \copy TO for exporting. Let’s look at another way to export output to a file.

**Saving Query Output to a File**

It’s sometimes helpful to save the query results and messages generated during a psql session to a file, whether to keep a history of your work or to use the output in a spreadsheet or other application. To send query output to a file, you can use the \o meta-command along with the full path and name of the output file.

**NOTE**

_On Windows, file paths for the \o command must either use Linux-style forward slashes, such as_ C:/my-stuff/my-file.txt, _or double backslashes, such as_ C:\\\my-stuff\\\my-file.txt.

For example, one of my favorite tricks is to set the output format to unaligned with a comma as a field separator and no row count in the footer, similar but not identical to a CSV output. (It’s not identical because a true CSV file, as you learned in [Chapter 4](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch04.xhtml#ch04), can include a character to quote values that contain a delimiter. Still, this trick works for simple CSV-like output.) [Listing 16-8](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#ch16list8) shows the sequence of commands at the psql prompt:

➊ analysis=# \a \f , \pset footer\
&#x20; Output format is unaligned.\
&#x20; Field separator is ",".\
&#x20; Default footer is off.\
\
&#x20; analysis=# SELECT \* FROM grades;\
➋ student\_id,course\_id,course,grade\
&#x20; 1,2,English 11B,D\
&#x20; 1,3,World History 11B,C\
&#x20; 1,4,Trig 2,B\
&#x20; 1,1,Biology 2,C\
\
➌ analysis=# \o '_C:/YourDirectory/_query\_output.csv'\
\
&#x20; analysis=# SELECT \* FROM grades;\
➍ analysis=#

_Listing 16-8: Saving query output to a file_

First, set the output format ➊ using the meta-commands \a, \f, and \pset footer for unaligned, comma-separated data with no footer. When you run a simple SELECT query on the grades table, the output ➋ should return as values separated by commas. Next, to send that data to a file the next time you run the query, use the \o meta-command and then provide a complete path to a file called _query\_output.csv_ ➌. When you run the SELECT query again, there should be no output to the screen ➍. Instead, you’ll find a file with the contents of the query in the directory specified at ➌.

Note that every time you run a query from this point, the output is appended to the same file specified after the \o command. To stop saving output to that file, you can either specify a new file or enter \o with no filename to resume having results output to the screen.

**Reading and Executing SQL Stored in a File**

You can run SQL stored in a text file by executing psql on the command line and supplying the file name after an -f argument. This syntax lets you quickly run a query or table update from the command line or in conjunction with a system scheduler to run a job at regular intervals.

Let’s say you saved the SELECT \* FROM grades; query in a file called _display-grades.sql_. To run the saved query, use the following psql syntax at your command line:

psql -d analysis -U postgres -f display-grades.sql

When you press ENTER, psql should launch, run the stored query in the file, display the results, and exit. For repetitive tasks, this workflow can save you considerable time because you avoid launching pgAdmin or rewriting a query. You also can stack multiple queries in the file so they run in succession, which, for example, you might do if you want to run multiple updates on your database.

#### Additional Command Line Utilities to Expedite Tasks <a href="#lev299" id="lev299"></a>

PostgreSQL includes additional command line utilities that come in handy if you’re connected to a remote server or just want to save time by using the command line instead of launching pgAdmin or another GUI. You can enter these commands in your command line interface without launching psql. A listing is available at [_https://www.postgresql.org/docs/current/static/reference-client.html_](https://www.postgresql.org/docs/current/static/reference-client.html), and I’ll explain several in [Chapter 17](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch17.xhtml#ch17) that are specific to database maintenance. But here I’ll cover two that are particularly useful: creating a database at the command line with the createdb utility and loading shapefiles into a PostGIS database via the shp2pgsql utility.

_**Adding a Database with createdb**_

The first SQL statement you learned in [Chapter 1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch01.xhtml#ch01) was CREATE DATABASE, which you used to add the database analysis to your PostgreSQL server. Rather than launching pgAdmin and writing a CREATE DATABASE statement, you can perform a similar action using the createdb command line utility. For example, to create a new database on your server named box\_office, run the following at your command line:

createdb -U postgres -e box\_office

The -U argument tells the command to connect to the PostgreSQL server using the postgres account. The -e argument (for “echo”) tells the command to print the SQL statement to the screen. Running this command generates the response CREATE DATABASE box\_office; in addition to creating the database. You can then connect to the new database via psql using the following line:

psql -d box\_office -U postgres

The createdb command accepts arguments to connect to a remote server (just like psql does) and to set options for the new database. A full list of arguments is available at [_https://www.postgresql.org/docs/current/static/app-createdb.html_](https://www.postgresql.org/docs/current/static/app-createdb.html). Again, the createdb command is a time-saver that comes in handy when you don’t have access to a GUI.

_**Loading Shapefiles with shp2pgsql**_

In [Chapter 14](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14), you learned to import a shapefile into a database with the Shapefile Import/Export Manager included in the PostGIS suite. That tool’s GUI is easy to navigate, but importing a shapefile using the PostGIS command line tool shp2pgsql lets you accomplish the same thing using a single text command.

To import a shapefile into a new table from the command line, use the following syntax:

shp2pgsql -I -s _SRID_ -W _encoding shapefile\_name table\_name_ | psql -d _database_ -U _user_

A lot is happening in this single line. Here’s a breakdown of the arguments (if you skipped [Chapter 14](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14), you might need to review it now):

\-I Adds a GiST index on the new table’s geometry column.

\-s Lets you specify an SRID for the geometric data.

\-W Lets you specify encoding. (Recall that we used Latin1 for census shapefiles.)

shapefile\_name The name (including full path) of the file ending with the _.shp_ extension.

table\_name The name of the table the shapefile is imported to.

Following these arguments, you place a pipe symbol (|) to direct the output of shp2pgsql to psql, which has the arguments for naming the database and user. For example, to load the _tl\_2010\_us\_county10.shp_ shapefile into a us\_counties\_2010\_shp table in the gis\_analysis database, as you did in [Chapter 14](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14), you can simply run the following command. Note that although this command wraps onto two lines here, it should be entered as one line in the command line:

shp2pgsql -I -s 4269 -W Latin1 tl\_2010\_us\_county10.shp us\_counties\_2010\_shp | psql -d\
gis\_analysis -U postgres

The server should respond with a number of SQL INSERT statements before creating the index and returning you to the command line. It might take some time to construct the entire set of arguments the first time around. But after you’ve done one, subsequent imports should take less time because you can simply substitute file and table names into the syntax you already wrote.

#### Wrapping Up <a href="#lev302" id="lev302"></a>

Are you feeling mysterious and powerful yet? Indeed, when you delve into a command line interface and make the computer do your bidding using text commands, you enter a world of computing that resembles a sci-fi movie sequence. Not only does working from the command line save you time, but it also helps you overcome barriers you encounter when you’re working in environments that don’t support graphical tools. In this chapter, you learned the basics of working with the command line plus PostgreSQL specifics. You discovered your operating system’s command line application and set it up to work with psql. Then you connected psql to a database and learned how to run SQL queries via the command line. Many experienced computer users prefer to use the command line for its simplicity and speed once they become familiar with using it. You might, too.

In [Chapter 17](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch17.xhtml#ch17), we’ll review common database maintenance tasks including backing up data, changing server settings, and managing the growth of your database. These tasks will give you more control over your working environment and help you better manage your data analysis projects.

**TRY IT YOURSELF**

To reinforce the techniques in this chapter, choose an example from an earlier chapter and try working through it using only the command line. [Chapter 14](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14) is a good choice because it gives you the opportunity to work with psql and the shapefile loader shp2pgsql. But choose any example that you think you would benefit from reviewing.
