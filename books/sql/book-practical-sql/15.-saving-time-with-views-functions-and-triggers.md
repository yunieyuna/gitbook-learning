# 15. Saving Time With Views, Functions, And Triggers

### **15** **SAVING TIME WITH VIEWS, FUNCTIONS, AND TRIGGERS** <a href="#ch15" id="ch15"></a>

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/common01.jpg)

One of the advantages of using a programming language is that it allows us to automate repetitive, boring tasks. For example, if you have to run the same query every month to update the same table, sooner or later you’ll search for a shortcut to accomplish the task. The good news is that shortcuts exist! In this chapter, you’ll learn techniques to encapsulate queries and logic into reusable PostgreSQL database objects that will speed up your workflow. As you read through this chapter, keep in mind the DRY programming principle: Don’t Repeat Yourself. Avoiding repetition saves time and prevents unnecessary mistakes.

You’ll begin by learning to save queries as reusable database _views_. Next, you’ll explore how to create your own functions to perform operations on your data. You’ve already used functions, such as round() and upper(), to transform data; now, you’ll make functions to perform operations you specify. Then you’ll set up _triggers_ to run functions automatically when certain events occur on a table. Using these techniques, you can reduce repetitive work and help maintain the integrity of your data.

We’ll use tables created from examples in earlier chapters to practice these techniques. If you connected to the gis\_analysis database in pgAdmin while working through [Chapter 14](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14), follow the instructions in that chapter to return to the analysis database. All the code for this chapter is available for download along with the book’s resources at [_https://www.nostarch.com/practicalSQL/_](https://www.nostarch.com/practicalSQL/). Let’s get started.

#### Using Views to Simplify Queries <a href="#lev267" id="lev267"></a>

A _view_ is a virtual table you can create dynamically using a saved query. For example, every time you access the view, the saved query runs automatically and displays the results. Similar to a regular table, you can query a view, join a view to regular tables (or other views), and use the view to update or insert data into the table it’s based on, albeit with some caveats.

In this section, we’ll look at regular views with a PostgreSQL syntax that is largely in line with the ANSI SQL standard. These views execute their underlying query each time you access the view, but they don’t store data the way a table does. A _materialized view_, which is specific to PostgreSQL, Oracle, and a limited number of other database systems, caches data created by the view, and you can later update that cached data. We won’t explore materialized views here, but you can browse to [_https://www.postgresql.org/docs/current/static/sql-creatematerializedview.html_](https://www.postgresql.org/docs/current/static/sql-creatematerializedview.html) to learn more.

Views are especially useful because they allow you to:

* **Avoid duplicate effort** by letting you write a query once and access the results when needed
* **Reduce complexity** for yourself or other database users by showing only columns relevant to your needs
* **Provide security** by limiting access to only certain columns in a table

**NOTE**

_To ensure data security and fully prevent users from seeing sensitive information, such as the underlying salary data in the employees table, you must restrict access by setting account permissions in PostgreSQL. Typically, a database administrator handles this function for an organization, but if you want to explore this issue further, read the PostgreSQL documentation on user roles at_ [https://www.postgresql.org/docs/current/static/sql-createrole.html](https://www.postgresql.org/docs/current/static/sql-createrole.html) _and the GRANT command at_ [https://www.postgresql.org/docs/current/static/sql-grant.html](https://www.postgresql.org/docs/current/static/sql-grant.html).

Views are easy to create and maintain. Let’s work through several examples to see how they work.

_**Creating and Querying Views**_

In this section, we’ll use data in the Decennial U.S. Census us\_counties\_2010 table you imported in [Chapter 4](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch04.xhtml#ch04). [Listing 15-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list1) uses this data to create a view called nevada\_counties\_pop\_2010 that displays only four out of the original 16 columns, showing data on just Nevada counties:

➊ CREATE OR REPLACE VIEW nevada\_counties\_pop\_2010 AS\
&#x20;   ➋ SELECT geo\_name,\
&#x20;            state\_fips,\
&#x20;            county\_fips,\
&#x20;            p0010001 AS pop\_2010\
&#x20;     FROM us\_counties\_2010\
&#x20;     WHERE state\_us\_abbreviation = 'NV'\
&#x20;   ➌ ORDER BY county\_fips;

_Listing 15-1: Creating a view that displays Nevada 2010 counties_

Here, we define the view using the keywords CREATE OR REPLACE VIEW ➊, followed by the view’s name and AS. Next is a standard SQL query SELECT ➋ that fetches the total population (the p0010001 column) for each Nevada county from the us\_counties\_2010 table. Then we order the data by the county’s FIPS (Federal Information Processing Standards) code ➌, which is a standard designator the Census Bureau and other federal agencies use to specify each county and state.

Notice the OR REPLACE keywords after CREATE, which tell the database that if a view with this name already exists, replace it with the definition here. But here’s a caveat according to the PostgreSQL documentation: the query that generates the view ➋ must have the columns with the same names and same data types in the same order as the view it’s replacing. However, you can add columns at the end of the column list.

Run the code in [Listing 15-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list1) using pgAdmin. The database should respond with the message CREATE VIEW. To find the view you created, in pgAdmin’s object browser, right-click the analysis database and choose **Refresh**. Choose **Schemas ▸ public ▸ Views** to see the new view. When you right-click the view and choose **Properties**, you should see the query under the **Code** tab in the dialog that opens.

**NOTE**

_As with other database objects, you can delete a view using the DROP command. In this example, the syntax would be DROP VIEW nevada\_counties\_pop\_2010;._

After creating the view, you can use the view in the FROM clause of a SELECT query the same way you would use an ordinary table. Enter the code in [Listing 15-2](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list2), which retrieves the first five rows from the view:

SELECT \*\
FROM nevada\_counties\_pop\_2010\
LIMIT 5;

_Listing 15-2: Querying the nevada\_counties\_pop\_2010 view_

Aside from the five-row limit, the result should be the same as if you had run the SELECT query used to create the view in [Listing 15-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list1):

geo\_name            state\_fips    county\_fips    pop\_2010\
\----------------    ----------    -----------    --------\
Churchill County    32            001               24877\
Clark County        32            003             1951269\
Douglas County      32            005               46997\
Elko County         32            007               48818\
Esmeralda County    32            009                 783

This simple example isn’t very useful unless quickly listing Nevada county population is a task you’ll perform frequently. So, let’s imagine a question data-minded analysts in a political research organization might ask often: what was the percent change in population for each county in Nevada (or any other state) from 2000 to 2010?

We wrote a query to answer this question in [Listing 6-13](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch06.xhtml#ch06list13) (see [“Performing Math on Joined Table Columns”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch06.xhtml#lev97) on [page 88](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch06.xhtml#page\_88)). It wasn’t onerous to create, but it did require joining tables on two columns and using a percent change formula that involved rounding and type casting. To avoid repeating that work, we can save a query similar to the one in [Listing 6-13](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch06.xhtml#ch06list13) as a view. [Listing 15-3](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list3) does this using a modified version of the earlier code in [Listing 15-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list1):

➊ CREATE OR REPLACE VIEW county\_pop\_change\_2010\_2000 AS\
&#x20;   ➋ SELECT c2010.geo\_name,\
&#x20;            c2010.state\_us\_abbreviation AS st,\
&#x20;            c2010.state\_fips,\
&#x20;            c2010.county\_fips,\
&#x20;            c2010.p0010001 AS pop\_2010,\
&#x20;            c2000.p0010001 AS pop\_2000,\
&#x20;          ➌ round( (CAST(c2010.p0010001 AS numeric(8,1)) - c2000.p0010001)\
&#x20;                / c2000.p0010001 \* 100, 1 ) AS pct\_change\_2010\_2000\
&#x20;   ➍ FROM us\_counties\_2010 c2010 INNER JOIN us\_counties\_2000 c2000\
&#x20;     ON c2010.state\_fips = c2000.state\_fips\
&#x20;        AND c2010.county\_fips = c2000.county\_fips\
&#x20;     ORDER BY c2010.state\_fips, c2010.county\_fips;

_Listing 15-3: Creating a view showing population change for U.S. counties_

We start the view definition with CREATE OR REPLACE VIEW ➊, followed by the name of the view and AS. The SELECT query ➋ names columns from the census tables and includes a column definition with a percent change calculation ➌ that you learned about in [Chapter 5](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch05.xhtml#ch05). Then we join the Census 2010 and 2000 tables ➍ using the state and county FIPS codes. Run the code, and the database should again respond with CREATE VIEW.

Now that we’ve created the view, we can use the code in [Listing 15-4](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list4) to run a simple query against the new view that retrieves data for Nevada counties:

&#x20; SELECT geo\_name,\
&#x20;        st,\
&#x20;        pop\_2010,\
&#x20;      ➊ pct\_change\_2010\_2000\
&#x20; FROM county\_pop\_change\_2010\_2000\
➋ WHERE st = 'NV'\
&#x20; LIMIT 5;

_Listing 15-4: Selecting columns from the county\_pop\_change\_2010\_2000 view_

In [Listing 15-2](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list2), in the query against the first view we created, we retrieved every column in the view by using the asterisk wildcard after the SELECT keyword. [Listing 15-4](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list4) shows that, as with a query on a table, we can name specific columns when querying a view. Here, we specify four of the county\_pop\_change\_2010\_2000 view’s seven columns. One is pct\_change\_2010\_2000 ➊, which returns the result of the percent change calculation we’re looking for. As you can see, it’s much simpler to write the column name like this than the whole formula! We’re also filtering the results using a WHERE clause ➋, similar to how we would filter any query instead of returning all rows.

After querying the four columns from the view, the results should look like this:

geo\_name            st    pop\_2010    pct\_change\_2010\_2000\
\----------------    --    --------    --------------------\
Churchill County    NV       24877                     3.7\
Clark County        NV     1951269                    41.8\
Douglas County      NV       46997                    13.9\
Elko County         NV       48818                     7.8\
Esmeralda County    NV         783                   -19.4

Now we can revisit this view as often as we like to pull data for presentations or to answer questions about the percent change in population for each county in Nevada (or any other state) from 2000 to 2010.

Looking at just these five rows, you can see that a couple of interesting stories emerge: the effect of the 2000s’ housing boom on Clark County, which includes the city of Las Vegas, as well as a sharp drop in population in Esmeralda County, which has one of the lowest population densities in the United States.

_**Inserting, Updating, and Deleting Data Using a View**_

You can update or insert data in the underlying table that a view queries as long as the view meets certain conditions. One requirement is that the view must reference a single table. If the view’s query joins tables, as with the population change view we just built in the previous section, then you can’t perform inserts or updates directly. Also, the view’s query can’t contain DISTINCT, GROUP BY, or other clauses. (See a complete list of restrictions at [_https://www.postgresql.org/docs/current/static/sql-createview.html_](https://www.postgresql.org/docs/current/static/sql-createview.html).)

You already know how to directly insert and update data on a table, so why do it through a view? One reason is that with a view you can exercise more control over which data a user can update. Let’s work through an example to see how this works.

**Creating a View of Employees**

In the [Chapter 6](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch06.xhtml#ch06) lesson on joins, we created and filled departments and employees tables with four rows about people and where they work (if you skipped that section, you can revisit [Listing 6-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch06.xhtml#ch06list1) on [page 75](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch06.xhtml#page\_75)). Running a quick SELECT \* FROM employees; query shows the table’s contents, as you can see here:

emp\_id    first\_name    last\_name    salary    dept\_id\
\------    ----------    ---------    ------    -------\
&#x20;    1    Nancy         Jones         62500          1\
&#x20;    2    Lee           Smith         59300          1\
&#x20;    3    Soo           Nguyen        83000          2\
&#x20;    4    Janet         King          95000          2

Let’s say we want to give users in the Tax Department (its dept\_id is 1) the ability to add, remove, or update their employees’ names without letting them change salary information or data of employees in another department. To do this, we can set up a view using [Listing 15-5](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list5):

CREATE OR REPLACE VIEW employees\_tax\_dept AS\
&#x20;    SELECT emp\_id,\
&#x20;           first\_name,\
&#x20;           last\_name,\
&#x20;           dept\_id\
&#x20;    FROM employees\
&#x20;  ➊ WHERE dept\_id = 1\
&#x20;    ORDER BY emp\_id\
&#x20;  ➋ WITH LOCAL CHECK OPTION;

_Listing 15-5: Creating a view on the employees table_

Similar to the views we’ve created so far, we’re selecting only the columns we want to show from the employees table and using WHERE to filter the results on dept\_id = 1 ➊ to list only Tax Department staff. To restrict inserts or updates to Tax Department employees only, we add the WITH LOCAL CHECK OPTION ➋, which rejects any insert or update that does not meet the criteria of the WHERE clause. For example, the option won’t allow anyone to insert or update a row in the underlying table where the employee’s dept\_id is 3.

Create the employees\_tax\_dept view by running the code in [Listing 15-5](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list5). Then run SELECT \* FROM employees\_tax\_dept;, which should provide these two rows:

emp\_id    first\_name    last\_name    dept\_id\
\------    ----------    ---------    -------\
&#x20;    1    Nancy         Jones              1\
&#x20;    2    Lee           Smith              1

The result shows the employees who work in the Tax Department; they’re two of the four rows in the entire employees table.

Now, let’s look at how inserts and updates work via this view.

**Inserting Rows Using the employees\_tax\_dept View**

We can also use a view to insert or update data, but instead of using the table name in the INSERT or UPDATE statement, we substitute the view name. After we add or change data using a view, the change is applied to the underlying table, which in this case is employees. The view then reflects the change via the query it runs.

[Listing 15-6](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list6) shows two examples that attempt to add new employee records via the employees\_tax\_dept view. The first succeeds, but the second fails.

➊ INSERT INTO employees\_tax\_dept (first\_name, last\_name, dept\_id)\
&#x20; VALUES ('Suzanne', 'Legere', 1);\
\
➋ INSERT INTO employees\_tax\_dept (first\_name, last\_name, dept\_id)\
&#x20; VALUES ('Jamil', 'White', 2);\
\
➌ SELECT \* FROM employees\_tax\_dept;\
\
➍ SELECT \* FROM employees;

_Listing 15-6: Successful and rejected inserts via the employees\_tax\_dept view_

In the first INSERT ➊, which follows the insert format you learned in [Chapter 1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch01.xhtml#ch01), we supply the first and last names of Suzanne Legere plus her dept\_id. Because the dept\_id is 1, the value satisfies the LOCAL CHECK in the view, and the insert succeeds when it executes.

But when we run the second INSERT ➋ to add an employee named Jamil White using a dept\_id of 2, the operation fails with the error message new row violates check option for view "employees\_tax\_dept". The reason is that when we created the view in [Listing 15-5](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list5), we used the WHERE clause to show only rows with dept\_id = 1. The dept\_id of 2 does not pass the LOCAL CHECK in the view, and it’s prevented from being inserted.

Run the SELECT statement ➌ on the view to check that Suzanne Legere was successfully added:

emp\_id    first\_name    last\_name    dept\_id\
\------    ----------    ---------    -------\
&#x20;    1    Nancy         Jones              1\
&#x20;    2    Lee           Smith              1\
&#x20;    5    Suzanne       Legere             1

We can also query the employees table ➍ to see that, in fact, Suzanne Legere was added to the full table. The view queries the employees table each time we access it.

emp\_id    first\_name    last\_name    salary    dept\_id\
\------    ----------    ---------    ------    -------\
&#x20;    1    Nancy         Jones         62500          1\
&#x20;    2    Lee           Smith         59300          1\
&#x20;    3    Soo           Nguyen        83000          2\
&#x20;    4    Janet         King          95000          2\
&#x20;    5    Suzanne       Legere                       1

As you can see from the addition of “Suzanne Legere,” the data we add using a view is also added to the underlying table. However, because the view doesn’t include the salary column, its value in her row is NULL. If you attempt to insert a salary value using this view, you would receive the error message column "salary" of relation "employees\_tax\_dept" does not exist. The reason is that even though the salary column exists in the underlying employees table, it’s not referenced in the view. Again, this is one way to limit access to sensitive data. Check the links I provided in the note on [page 268](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#page\_268) to learn more about granting permissions to users if you plan to take on database administrator responsibilities.

**Updating Rows Using the employees\_tax\_dept View**

The same restrictions on accessing data in an underlying table apply when we make updates on data in the employees\_tax\_dept view. [Listing 15-7](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list7) shows a standard query to update the spelling of Suzanne’s last name using UPDATE (as a person with more than one uppercase letter in his last name, I can confirm misspelling names isn’t unusual).

UPDATE employees\_tax\_dept\
SET last\_name = 'Le Gere'\
WHERE emp\_id = 5;\
\
SELECT \* FROM employees\_tax\_dept;

_Listing 15-7: Updating a row via the employees\_tax\_dept view_

Run the code, and the result from the SELECT query should show the updated last name, which occurs in the underlying employees table:

emp\_id    first\_name    last\_name    dept\_id\
\------    ----------    ---------    -------\
&#x20;    1    Nancy         Jones              1\
&#x20;    2    Lee           Smith              1\
&#x20;    5    Suzanne       Le Gere            1

Suzanne’s last name is now correctly spelled as “Le Gere,” not “Legere.”

However, if we try to update the name of an employee who is not in the Tax Department, the query fails just as it did when we tried to insert Jamil White in [Listing 15-6](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list6). In addition, trying to use this view to update the salary of an employee—even one in the Tax Department—will fail with the same error I noted in the previous section. If the view doesn’t reference a column in the underlying table, you cannot access that column through the view. Again, the fact that updates on views are restricted in this way offers ways to ensure privacy and security for certain pieces of data.

**Deleting Rows Using the employees\_tax\_dept View**

Now, let’s explore how to delete rows using a view. The restrictions on which data you can affect apply here as well. For example, if Suzanne Le Gere in the Tax Department gets a better offer from another firm and decides to join the other company, you could remove her from the employees table through the employees\_tax\_dept view. [Listing 15-8](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list8) shows the query in the standard DELETE syntax:

DELETE FROM employees\_tax\_dept\
WHERE emp\_id = 5;

_Listing 15-8: Deleting a row via the employees\_tax\_dept view_

Run the query, and PostgreSQL should respond with DELETE 1. However, when you try to delete a row for an employee in a department other than the Tax Department, PostgreSQL won’t allow it and will report DELETE 0.

In summary, views not only give you control over access to data, but also shortcuts for working with data. Next, let’s explore how to use functions to save more time.

#### Programming Your Own Functions <a href="#lev274" id="lev274"></a>

You’ve used plenty of functions throughout the book, whether to capitalize letters with upper() or add numbers with sum(). Behind these functions is a significant amount of (sometimes complex) programming that takes an input, transforms it or initiates an action, and returns a response. You saw that extent of code in [Listing 5-14](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch05.xhtml#ch05list14) on [page 69](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch05.xhtml#page\_69) when you created a median() function, which uses 30 lines of code to find the middle value in a group of numbers. PostgreSQL’s built-in functions and other functions database programmers develop to automate processes can use even more lines of code, including links to external code written in another language, such as C.

We won’t write complicated code here, but we’ll work through some examples of building functions that you can use as a launching pad for your own ideas. Even simple, user-created functions can help you avoid repeating code when you’re analyzing data.

The code in this section is specific to PostgreSQL and is not part of the ANSI SQL standard. In some databases, notably Microsoft SQL Server and MySQL, implementing reusable code happens in a _stored procedure_. If you’re using another database management system, check its documentation for specifics.

_**Creating the percent\_change() Function**_

To learn the syntax for creating a function, let’s write a function to simplify calculating the percent change of two values, which is a staple of data analysis. In [Chapter 5](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch05.xhtml#ch05), you learned that the percent change formula can be expressed this way:

percent change = (_New Number_ – _Old Number_) / _Old Number_

Rather than writing that formula each time we need it, we can create a function called percent\_change() that takes the new and old numbers as inputs and returns the result rounded to a user-specified number of decimal places. Let’s walk through the code in [Listing 15-9](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list9) to see how to declare a simple SQL function:

➊ CREATE OR REPLACE FUNCTION\
➋ percent\_change(new\_value numeric,\
&#x20;                old\_value numeric,\
&#x20;                decimal\_places integer ➌DEFAULT 1)\
➍ RETURNS numeric AS\
➎ 'SELECT round(\
&#x20;         ((new\_value - old\_value) / old\_value) \* 100, decimal\_places\
&#x20; );'\
➏ LANGUAGE SQL\
➐ IMMUTABLE\
➑ RETURNS NULL ON NULL INPUT;

_Listing 15-9: Creating a percent\_change() function_

A lot is happening in this code, but it’s not as complicated as it looks. We start with the command CREATE OR REPLACE FUNCTION ➊, followed by the name of the function ➋ and, in parentheses, a list of _arguments_ that are the function’s inputs. Each argument has a name and data type. For example, we specify that new\_value and old\_value are numeric, whereas decimal\_places (which specifies the number of places to round results) is integer. For decimal\_places, we specify 1 as the DEFAULT ➌ value to indicate that we want the results to display only one decimal place. Because we set a default value, the argument will be optional when we call the function later.

We then use the keywords RETURNS numeric AS ➍ to tell the function to return its calculation as type numeric. If this were a function to concatenate strings, we might return text.

Next, we write the meat of the function that performs the calculation. Inside single quotes, we place a SELECT query ➎ that includes the percent change calculation nested inside a round() function. In the formula, we use the function’s argument names instead of numbers.

We then supply a series of keywords that define the function’s attributes and behavior. The LANGUAGE ➏ keyword specifies that we’ve written this function using plain SQL, which is one of several languages PostgreSQL supports in functions. Another common option is a PostgreSQL-specific _procedural language_ called PL/pgSQL that, in addition to providing the means to create functions, adds features not found in standard SQL, such as logical control structures (IF ... THEN ... ELSE). PL/pgSQL is the default procedural language installed with PostgreSQL, but you can install others, such as PL/Perl and PL/Python, to use the Perl and Python programming languages in your database. Later in this chapter, I’ll show examples of PL/pgSQL and Python.

Next, the IMMUTABLE keyword ➐ indicates that the function won’t be making any changes to the database, which can improve performance. The line RETURNS NULL ON NULL INPUT ➑ guarantees that the function will supply a NULL response if any input that is not supplied by default is a NULL.

Run the code using pgAdmin to create the percent\_change() function. The server should respond with the message CREATE FUNCTION.

_**Using the percent\_change() Function**_

To test the new percent\_change() function, run it by itself using SELECT, as shown in [Listing 15-10](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list10):

SELECT percent\_change(110, 108, 2);

_Listing 15-10: Testing the percent\_change() function_

This example uses a value of 110 for the new number, 108 for the old number, and 2 as the desired number of decimal places to round the result.

Run the code; the result should look like this:

percent\_change\
\--------------\
&#x20;         1.85

The result indicates that there is a 1.85 percent increase between 108 and 110. You can experiment with other numbers to see how the results change. Also, try changing the decimal\_places argument to values including 0, or omit it, to see how that affects the output. You should see results that have more or fewer numbers after the decimal point, based on your input.

Of course, we created this function to avoid having to write the full percent change formula in queries. Now let’s use it to calculate the percent change using a version of the Decennial Census population change query we wrote in [Chapter 6](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch06.xhtml#ch06), as shown in [Listing 15-11](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list11):

SELECT c2010.geo\_name,\
&#x20;      c2010.state\_us\_abbreviation AS st,\
&#x20;      c2010.p0010001 AS pop\_2010,\
&#x20;    ➊ percent\_change(c2010.p0010001, c2000.p0010001) AS pct\_chg\_func,\
&#x20;    ➋ round( (CAST(c2010.p0010001 AS numeric(8,1)) - c2000.p0010001)\
&#x20;          / c2000.p0010001 \* 100, 1 ) AS pct\_chg\_formula\
FROM us\_counties\_2010 c2010 INNER JOIN us\_counties\_2000 c2000\
ON c2010.state\_fips = c2000.state\_fips\
&#x20;  AND c2010.county\_fips = c2000.county\_fips\
ORDER BY pct\_chg\_func DESC\
LIMIT 5;

_Listing 15-11: Testing percent\_change() on census data_

[Listing 15-11](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list11) uses the original query in [Listing 6-13](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch06.xhtml#ch06list13) and adds the percent\_change() function ➊ as a column before the formula ➋ so we can compare results. As inputs, we use the 2010 total population column (c2010.p0010001) as the new number and the 2000 total population as the old (c2000.p0010001).

When you run the query, the results should display the five counties with the greatest percent change in population, and the results from the function should match the results from the formula entered directly into the query ➋.

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/prog\_page\_278.jpg)

Each result displays one decimal place, the function’s default value, because we didn’t provide the optional third argument when we called the function. Now that we know the function works as intended, we can use percent\_change() any time we need to solve that calculation. Using a function is much faster than having to write a formula each time we need to use it!

_**Updating Data with a Function**_

We can also use a function to simplify routine updates to data. In this section, we’ll write a function that assigns the correct number of personal days available to a teacher (in addition to vacation) based on their hire date. We’ll use the teachers table from the first lesson in [Chapter 1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch01.xhtml#ch01), [“Creating a Table”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch01.xhtml#lev13) on [page 5](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch01.xhtml#page\_5). If you skipped that section, you can return to it to create the table and insert the data using the example code in [Listing 1-2](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch01.xhtml#ch01list2) on [page 6](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch01.xhtml#page\_6) and [Listing 1-3](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch01.xhtml#ch01list3) on [page 8](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch01.xhtml#page\_8).

Let’s start by adding a column to teachers to hold the personal days using the code in [Listing 15-12](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list12):

ALTER TABLE teachers ADD COLUMN personal\_days integer;\
SELECT first\_name,\
&#x20;      last\_name,\
&#x20;      hire\_date,\
&#x20;      personal\_days\
FROM teachers;

_Listing 15-12: Adding a column to the teachers table and seeing the data_

[Listing 15-12](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list12) updates the teachers table using ALTER and adds the personal\_days column using the keywords ADD COLUMN. Run the SELECT statement to view the data. When both queries finish, you should see the following six rows:

first\_name    last\_name    hire\_date     personal\_days\
\----------    ---------    ----------    -------------\
Janet         Smith        2011-10-30\
Lee           Reynolds     1993-05-22\
Samuel        Cole         2005-08-01\
Samantha      Bush         2011-10-30\
Betty         Diaz         2005-08-30\
Kathleen      Roush        2010-10-22     &#x20;

The personal\_days column holds NULL values because we haven’t provided any values yet.

Now, let’s create a function called update\_personal\_days() that updates the personal\_days column with the correct personal days based on the teacher’s hire date. We’ll use the following rules to update the data in the personal\_days column:

* Less than five years since hire: 3 personal days
* Between five and 10 years since hire: 4 personal days
* More than 10 years since hire: 5 personal days

The code in [Listing 15-13](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list13) is similar to the code we used to create the percent\_change() function, but this time we’ll use the PL/pgSQL language instead of plain SQL. Let’s walk through some differences.

&#x20; CREATE OR REPLACE FUNCTION update\_personal\_days()\
➊ RETURNS void AS ➋\$$\
➌ BEGIN\
&#x20;     UPDATE teachers\
&#x20;     SET personal\_days =\
&#x20;       ➍ CASE WHEN (now() - hire\_date) BETWEEN '5 years'::interval\
&#x20;                                       AND '10 years'::interval THEN 4\
&#x20;              WHEN (now() - hire\_date) > '10 years'::interval THEN 5\
&#x20;              ELSE 3\
&#x20;         END;\
&#x20;  ➎ RAISE NOTICE 'personal\_days updated!';\
&#x20; END;\
➏ \$$ LANGUAGE plpgsql;

_Listing 15-13: Creating an update\_personal\_days() function_

We begin with CREATE OR REPLACE FUNCTION, followed by the function’s name. This time, we provide no arguments because no user input is required. The function operates on predetermined columns with set rules for calculating intervals. Also, we use RETURNS void ➊ to note that the function returns no data; it simply updates the personal\_days column.

Often, when writing PL/pgSQL-based functions, the PostgreSQL convention is to use the non-ANSI SQL standard dollar-quote (\$$) ➋ to mark the start and end of the string that contains all the function’s commands. (As with the percent\_change() function earlier, you could use single quote marks to enclose the string, but then any single quotes in the string would need to be doubled, and that looks messy.) So, everything between the pairs of \$$ is the code that does the work. You can also add some text between the dollar signs, like $namestring$, to create a unique pair of beginning and ending quotes. This is useful, for example, if you need to quote a query inside the function.

Right after the first \$$ we start a BEGIN ... END; ➌ block to denote the function; inside it we place an UPDATE statement that uses a CASE statement ➍ to determine the number of days each teacher gets. We subtract the hire\_date from the current date, which is retrieved from the server by the now() function. Depending on which range now() - hire\_date falls into, the CASE statement returns the correct number of days off corresponding to the range. We use RAISE NOTICE ➎ to display a message in pgAdmin that the function is done. At the end, we use the LANGUAGE ➏ keyword to specify that we’ve written this function using PL/pgSQL.

Run the code in [Listing 15-13](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list13) to create the update\_personal\_days() function. Then use the following line to run it in pgAdmin:

SELECT update\_personal\_days();

Now when you rerun the SELECT statement in [Listing 15-12](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list12), you should see that each row of the personal\_days column is filled with the appropriate values. Note that your results may vary depending on when you run this function, because the result of now() is constantly updated with the passage of time.

first\_name    last\_name    hire\_date     personal\_days\
\----------    ---------    ----------    -------------\
Janet         Smith        2011-10-30                4\
Lee           Reynolds     1993-05-22                5\
Samuel        Cole         2005-08-01                5\
Samantha      Bush         2011-10-30                4\
Betty         Diaz         2005-08-30                5\
Kathleen      Roush        2010-10-22                4

You could use the update\_personal\_days() function to regularly update data manually after performing certain tasks, or you could use a task scheduler such as pgAgent (a separate open source tool) to run it automatically. You can learn about pgAgent and other tools in [“PostgreSQL Utilities, Tools, and Extensions”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/appendix.xhtml#lev330) on [page 334](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/appendix.xhtml#page\_334).

_**Using the Python Language in a Function**_

Previously, I mentioned that PL/pgSQL is the default procedural language within PostgreSQL, but the database also supports creating functions using open source languages, such as Perl and Python. This support allows you to take advantage of those languages’ features as well as related modules within functions you create. For example, with Python, you can use the pandas library for data analysis. The documentation at [_https://www.postgresql.org/docs/current/static/server-programming.html_](https://www.postgresql.org/docs/current/static/server-programming.html) provides a comprehensive review of the available languages, but here I’ll show you a very simple function using Python.

To enable PL/Python, you must add the extension using the code in [Listing 15-14](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list14). If you get an error, such as could not access file "$libdir/plpython2", that means PL/Python wasn’t included when you installed PostgreSQL. Refer back to the troubleshooting links for each operating system in [“Installing PostgreSQL”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/intro.xhtml#lev6) on page xxviii.

CREATE EXTENSION plpythonu;

_Listing 15-14: Enabling the PL/Python procedural language_

**NOTE**

_The extension plpythonu currently installs Python version 2._x. _If you want to use Python 3._x, _install the extension plpython3u instead. However, available versions might vary based on PostgreSQL distribution._

After enabling the extension, create a function following the same syntax you just learned in [Listing 15-9](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list9) and [Listing 15-13](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list13), but use Python for the body of the function. [Listing 15-15](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list15) shows how to use PL/Python to create a function called trim\_county() that removes the word “County” from the end of a string. We’ll use this function to clean up names of counties in the census data.

&#x20; CREATE OR REPLACE FUNCTION trim\_county(input\_string text)\
➊ RETURNS text AS \$$\
&#x20;   ➋ import re\
&#x20;   ➌ cleaned = re.sub(r' County', '', input\_string)\
&#x20;     return cleaned\
➍ \$$ LANGUAGE plpythonu;

_Listing 15-15: Using PL/Python to create the trim\_county() function_

The structure should look familiar with some exceptions. Unlike the example in [Listing 15-13](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list13), we don’t follow the \$$ ➊ with a BEGIN ... END; block. That is a PL/pgSQL–specific requirement that we don’t need in PL/Python. Instead, we get straight to the Python code by starting with a statement to import the Python regular expressions module, re ➋. Even if you don’t know much about Python, you can probably deduce that the next two lines of code ➌ set a variable called cleaned to the results of a Python regular expression function called sub(). That function looks for a space followed by the word _County_ in the input\_string passed into the function and substitutes an empty string, which is denoted by two apostrophes. Then the function returns the content of the variable cleaned. To end, we specify LANGUAGE plpythonu ➍ to note we’re writing the function with PL/Python.

Run the code to create the function, and then execute the SELECT statement in [Listing 15-16](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list16) to see it in action.

SELECT geo\_name,\
&#x20;      trim\_county(geo\_name)\
FROM us\_counties\_2010\
ORDER BY state\_fips, county\_fips\
LIMIT 5;

_Listing 15-16: Testing the trim\_county() function_

We use the geo\_name column in the us\_counties\_2010 table as input to trim\_county(). That should return these results:

geo\_name          trim\_county\
\--------------    -----------\
Autauga County    Autauga\
Baldwin County    Baldwin\
Barbour County    Barbour\
Bibb County       Bibb\
Blount County     Blount

As you can see, the trim\_county() function evaluated each value in the geo\_name column and removed a space and the word _County_ when present. Although this is a trivial example, it shows how easy it is to use Python—or one of the other supported procedural languages—inside a function.

Next, you’ll learn how to use triggers to automate your database.

#### Automating Database Actions with Triggers <a href="#lev279" id="lev279"></a>

A database _trigger_ executes a function whenever a specified event, such as an INSERT, UPDATE, or DELETE, occurs on a table or a view. You can set a trigger to fire before, after, or instead of the event, and you can also set it to fire once for each row affected by the event or just once per operation. For example, let’s say you delete 20 rows from a table. You could set the trigger to fire once for each of the 20 rows deleted or just one time.

We’ll work through two examples. The first example keeps a log of changes made to grades at a school. The second automatically classifies temperatures each time we collect a reading.

_**Logging Grade Updates to a Table**_

Let’s say we want to automatically track changes made to a student grades table in our school’s database. Every time a row is updated, we want to record the old and new grade plus the time the change occurred (search for “David Lightman and grades” and you’ll see why this might be worth tracking). To handle this task automatically, we’ll need three items:

* A grades\_history table to record the changes to grades in a grades table
* A trigger to run a function every time a change occurs in the grades table, which we’ll name grades\_update
* The function the trigger will execute; we’ll call this function record\_if\_grade\_changed()

**Creating Tables to Track Grades and Updates**

Let’s start by making the tables we need. [Listing 15-17](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list17) includes the code to first create and fill grades and then create grades\_history:

➊ CREATE TABLE grades (\
&#x20;     student\_id bigint,\
&#x20;     course\_id bigint,\
&#x20;     course varchar(30) NOT NULL,\
&#x20;     grade varchar(5) NOT NULL,\
&#x20; PRIMARY KEY (student\_id, course\_id)\
&#x20; );\
\
➋ INSERT INTO grades\
&#x20; VALUES\
&#x20;     (1, 1, 'Biology 2', 'F'),\
&#x20;     (1, 2, 'English 11B', 'D'),\
&#x20;     (1, 3, 'World History 11B', 'C'),\
&#x20;     (1, 4, 'Trig 2', 'B');\
\
➌ CREATE TABLE grades\_history (\
&#x20;     student\_id bigint NOT NULL,\
&#x20;     course\_id bigint NOT NULL,\
&#x20;     change\_time timestamp with time zone NOT NULL,\
&#x20;     course varchar(30) NOT NULL,\
&#x20;     old\_grade varchar(5) NOT NULL,\
&#x20;     new\_grade varchar(5) NOT NULL,\
&#x20; PRIMARY KEY (student\_id, course\_id, change\_time)\
&#x20; );

_Listing 15-17: Creating the grades and grades\_history tables_

These commands are straightforward. We use CREATE to make a grades table ➊ and add four rows using INSERT ➋, where each row represents a student’s grade in a class. Then we use CREATE TABLE to make the grades\_history table ➌ to hold the data we log each time an existing grade is altered. The grades\_history table has columns for the new grade, old grade, and the time of the change. Run the code to create the tables and fill the grades table. We insert no data into grades\_history here because the trigger process will handle that task.

**Creating the Function and Trigger**

Next, let’s write the record\_if\_grade\_changed() function the trigger will execute. We must write the function before naming it in the trigger. Let’s go through the code in [Listing 15-18](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list18):

CREATE OR REPLACE FUNCTION record\_if\_grade\_changed()\
➊ RETURNS trigger AS\
\$$\
BEGIN\
&#x20; ➋ IF NEW.grade <> OLD.grade THEN\
&#x20;   INSERT INTO grades\_history (\
&#x20;       student\_id,\
&#x20;       course\_id,\
&#x20;       change\_time,\
&#x20;       course,\
&#x20;       old\_grade,\
&#x20;       new\_grade)\
&#x20;   VALUES\
&#x20;       (OLD.student\_id,\
&#x20;        OLD.course\_id,\
&#x20;        now(),\
&#x20;        OLD.course,\
&#x20;      ➌ OLD.grade,\
&#x20;      ➍ NEW.grade);\
&#x20;   END IF;\
&#x20; ➎ RETURN NEW;\
END;\
\$$ LANGUAGE plpgsql;

_Listing 15-18: Creating the record\_if\_grade\_changed() function_

The record\_if\_grade\_changed() function follows the pattern of earlier examples in the chapter but with exceptions specific to working with triggers. First, we specify RETURNS trigger ➊ instead of a data type or void. Because record\_if\_grade\_changed() is a PL/pgSQL function, we place the procedure inside the BEGIN ... END; block. We start the procedure using an IF ... THEN statement ➋, which is one of the control structures PL/pgSQL provides. We use it here to run the INSERT statement only if the updated grade is different from the old grade, which we check using the <> operator.

When a change occurs to the grades table, the trigger (which we’ll create next) will execute. For each row that is changed, the trigger will pass two collections of data into record\_if\_grade\_changed(). The first is the row values _before_ they were changed, noted with the prefix OLD. The second is the row values _after_ they were changed, noted with the prefix NEW. The function can access the original row values and the updated row values, which it will use for a comparison. If the IF ... THEN statement evaluates as true, which means that the old and new grade values are different, we use INSERT to add a row to grades\_history that contains both OLD.grade ➌ and NEW.grade ➍.

A trigger must have a RETURN statement ➎, although the PostgreSQL documentation at [_https://www.postgresql.org/docs/current/static/plpgsql-trigger.html_](https://www.postgresql.org/docs/current/static/plpgsql-trigger.html) details the scenarios in which a trigger return value actually matters (sometimes it is ignored). The documentation also explains that you can use statements to return a NULL or raise an exception in case of error.

Run the code in [Listing 15-18](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list18) to create the function. Next, add the grades\_update trigger to the grades table using [Listing 15-19](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list19):

➊ CREATE TRIGGER grades\_update\
➋  AFTER UPDATE\
&#x20;   ON grades\
➌  FOR EACH ROW\
➍  EXECUTE PROCEDURE record\_if\_grade\_changed();

_Listing 15-19: Creating the grades\_update trigger_

In PostgreSQL, the syntax for creating a trigger follows the ANSI SQL standard (although the contents of the trigger function do not). The code begins with a CREATE TRIGGER ➊ statement, followed by clauses that control when the trigger runs and how it behaves. We use AFTER UPDATE ➋ to specify that we want the trigger to fire after the update occurs on the grades row. We could also use the keywords BEFORE or INSTEAD OF depending on the situation.

We write FOR EACH ROW ➌ to tell the trigger to execute the procedure once for each row updated in the table. For example, if someone ran an update that affected three rows, the procedure would run three times. The alternate (and default) is FOR EACH STATEMENT, which runs the procedure once. If we didn’t care about capturing changes to each row and simply wanted to record that grades were changed at a certain time, we could use that option. Finally, we use EXECUTE PROCEDURE ➍ to name record\_if\_grade\_changed() as the function the trigger should run.

Create the trigger by running the code in [Listing 15-19](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list19) in pgAdmin. The database should respond with the message CREATE TRIGGER.

**Testing the Trigger**

Now that we’ve created the trigger and the function it should run, let’s make sure they work. First, when you run SELECT \* FROM grades\_history;, you’ll see that the table is empty because we haven’t made any changes to the grades table yet and there’s nothing to track. Next, when you run SELECT \* FROM grades; you should see the grade data, as shown here:

student\_id    course\_id    course               grade\
\----------    ---------    -----------------    -----\
&#x20;        1            1    Biology 2            F\
&#x20;        1            2    English 11B          D\
&#x20;        1            3    World History 11B    C\
&#x20;        1            4    Trig 2               B

That Biology 2 grade doesn’t look very good. Let’s update it using the code in [Listing 15-20](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list20):

UPDATE grades\
SET grade = 'C'\
WHERE student\_id = 1 AND course\_id = 1;

_Listing 15-20: Testing the grades\_update trigger_

When you run the UPDATE, pgAdmin doesn’t display anything to let you know that the trigger executed in the background. It just reports UPDATE 1, meaning the row with grade F was updated. But our trigger did run, which we can confirm by examining columns in grades\_history using this SELECT query:

SELECT student\_id,\
&#x20;      change\_time,\
&#x20;      course,\
&#x20;      old\_grade,\
&#x20;      new\_grade\
FROM grades\_history;

When you run this query, you should see that the grades\_history table, which contains all changes to grades, now has one row:

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/prog\_page\_286.jpg)

This row displays the old Biology 2 grade of F, the new value C, and change\_time, showing the time of the change made (your result should reflect your date and time). Note that the addition of this row to grades\_history happened in the background without the knowledge of the person making the update. But the UPDATE event on the table caused the trigger to fire, which executed the record\_if\_grade\_changed() function.

If you’ve used a content management system, such as WordPress or Drupal, this sort of revision tracking might be familiar. It provides a helpful record of changes made to content for reference and auditing purposes, and, unfortunately, can lead to occasional finger-pointing. Regardless, the ability to trigger actions on a database automatically gives you more control over your data.

_**Automatically Classifying Temperatures**_

In [Chapter 12](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch12.xhtml#ch12), we used the SQL CASE statement to reclassify temperature readings into descriptive categories. The CASE statement (with a slightly different syntax) is also part of the PL/pgSQL procedural language, and we can use its capability to assign values to variables to automatically store those category names in a table each time we add a temperature reading. If we’re routinely collecting temperature readings, using this technique to automate the classification spares us from having to handle the task manually.

We’ll follow the same steps we used for logging the grade changes: we first create a function to classify the temperatures, and then create a trigger to run the function each time the table is updated. Use [Listing 15-21](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list21) to create a temperature\_test table for the exercise:

CREATE TABLE temperature\_test (\
&#x20;   station\_name varchar(50),\
&#x20;   observation\_date date,\
&#x20;   max\_temp integer,\
&#x20;   min\_temp integer,\
&#x20;   max\_temp\_group varchar(40),\
PRIMARY KEY (station\_name, observation\_date)\
);

_Listing 15-21: Creating a temperature\_test table_

In [Listing 15-21](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list21), the temperature\_test table contains columns to hold the name of the station and date of the temperature observation. Let’s imagine that we have some process to insert a row once a day that provides the maximum and minimum temperature for that location, and we need to fill the max\_temp\_group column with a descriptive classification of the day’s high reading to provide text to a weather forecast we’re distributing.

To do this, we first make a function called classify\_max\_temp(), as shown in [Listing 15-22](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list22):

CREATE OR REPLACE FUNCTION classify\_max\_temp()\
&#x20;   RETURNS trigger AS\
\$$\
BEGIN\
&#x20; ➊ CASE\
&#x20;      WHEN NEW.max\_temp >= 90 THEN\
&#x20;          NEW.max\_temp\_group := 'Hot';➋\
&#x20;      WHEN NEW.max\_temp BETWEEN 70 AND 89 THEN\
&#x20;          NEW.max\_temp\_group := 'Warm';\
&#x20;      WHEN NEW.max\_temp BETWEEN 50 AND 69 THEN\
&#x20;          NEW.max\_temp\_group := 'Pleasant';\
&#x20;      WHEN NEW.max\_temp BETWEEN 33 AND 49 THEN\
&#x20;          NEW.max\_temp\_group :=  'Cold';\
&#x20;      WHEN NEW.max\_temp BETWEEN 20 AND 32 THEN\
&#x20;          NEW.max\_temp\_group :=  'Freezing';\
&#x20;      ELSE NEW.max\_temp\_group :=  'Inhumane';\
&#x20;   END CASE;\
&#x20;   RETURN NEW;\
END;\
\$$ LANGUAGE plpgsql;

_Listing 15-22: Creating the classify\_max\_temp() function_

By now, these functions should look familiar. What is new here is the PL/pgSQL version of the CASE syntax ➊, which differs slightly from the SQL syntax in that the PL/pgSQL syntax includes a semicolon after each WHEN ... THEN clause ➋. Also new is the _assignment operator_ (:=), which we use to assign the descriptive name to the NEW.max\_temp\_group column based on the outcome of the CASE function. For example, the statement NEW.max\_temp\_group := 'Cold' assigns the string 'Cold' to NEW.max\_temp\_group when the temperature value is between 33 and 49 degrees Fahrenheit, and when the function returns the NEW row to be inserted in the table, it will include the string value Cold. Run the code to create the function.

Next, using the code in [Listing 15-23](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list23), create a trigger to execute the function each time a row is added to temperature\_test:

CREATE TRIGGER temperature\_insert\
&#x20; ➊ BEFORE INSERT\
&#x20;   ON temperature\_test\
&#x20; ➋ FOR EACH ROW\
&#x20; ➌ EXECUTE PROCEDURE classify\_max\_temp();

_Listing 15-23: Creating the temperature\_insert trigger_

In this example, we classify max\_temp and create a value for max\_temp\_group prior to inserting the row into the table. Doing so is more efficient than performing a separate update after the row is inserted. To specify that behavior, we set the temperature\_insert trigger to fire BEFORE INSERT ➊.

We also want the trigger to fire FOR EACH ROW inserted ➋ because we want each max\_temp recorded in the table to get a descriptive classification. The final EXECUTE PROCEDURE statement names the classify\_max\_temp() function ➌ we just created. Run the CREATE TRIGGER statement in pgAdmin, and then test the setup using [Listing 15-24](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch15.xhtml#ch15list24):

INSERT INTO temperature\_test (station\_name, observation\_date, max\_temp, min\_temp)\
VALUES\
&#x20;   ('North Station', '1/19/2019', 10, -3),\
&#x20;   ('North Station', '3/20/2019', 28, 19),\
&#x20;   ('North Station', '5/2/2019', 65, 42),\
&#x20;   ('North Station', '8/9/2019', 93, 74);\
\
SELECT \* FROM temperature\_test;

_Listing 15-24: Inserting rows to test the temperature\_insert trigger_

Here we insert four rows into temperature\_test, and we expect the temperature\_insert trigger to fire for each row—and it does! The SELECT statement in the listing should display these results:

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/prog\_page\_288.jpg)

Due to the trigger and function we created, each max\_temp inserted automatically receives the appropriate classification in the max\_temp\_group column.

This temperature example and the earlier grade-change auditing example are rudimentary, but they give you a glimpse of how useful triggers and functions can be in simplifying data maintenance.

#### Wrapping Up <a href="#lev285" id="lev285"></a>

Although the techniques you learned in this chapter begin to merge with those of a database administrator, you can apply the concepts to reduce the amount of time you spend repeating certain tasks. I hope these approaches will help you free up more time to find interesting stories in your data.

This chapter concludes our discussion of analysis techniques and the SQL language. The next two chapters offer workflow tips to help you increase your command of PostgreSQL. They include how to connect to a database and run queries from your computer’s command line, and how to maintain your database.

**TRY IT YOURSELF**

Review the concepts in the chapter with these exercises:

1. Create a view that displays the number of New York City taxi trips per hour. Use the taxi data in [Chapter 11](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch11.xhtml#ch11) and the query in [Listing 11-8](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch11.xhtml#ch11list8) on [page 182](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch11.xhtml#page\_182).
2. In [Chapter 10](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch10.xhtml#ch10), you learned how to calculate rates per thousand. Turn that formula into a rates\_per\_thousand() function that takes three arguments to calculate the result: observed\_number, base\_number, and decimal\_places.
3. In [Chapter 9](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch09.xhtml#ch09), you worked with the meat\_poultry\_egg\_inspect table that listed food processing facilities. Write a trigger that automatically adds an inspection date each time you insert a new facility into the table. Use the inspection\_date column added in [Listing 9-19](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch09.xhtml#ch09list19) on [page 146](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch09.xhtml#page\_146), and set the date to be six months from the current date. You should be able to describe the steps needed to implement a trigger and how the steps relate to each other.
