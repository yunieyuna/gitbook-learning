# 14. Analyzing Spatial Data With PostGIS

### **14** **ANALYZING SPATIAL DATA WITH POSTGIS** <a href="#ch14" id="ch14"></a>

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/common01.jpg)

These days, mobile apps can provide a list of coffee shops near you within seconds. They can do that because they’re powered by a _geographic information system (GIS)_, which is any system that allows for storing, editing, analyzing, and displaying spatial data. As you can imagine, GIS has many practical applications today, from helping city planners decide where to build schools based on population patterns to finding the best detour around a traffic jam.

_Spatial data_ refers to information about the location and shape of objects, which can be two and three dimensional. For example, the spatial data we’ll use in this chapter contains coordinates describing geometric shapes, such as points, lines, and polygons. These shapes in turn represent features you would find on a map, such as roads, lakes, or countries.

Conveniently, you can use PostgreSQL to store and analyze spatial data, which allows you to calculate the distance between points, compute the size of areas, and identify whether two objects intersect. However, to enable spatial analysis and store spatial data types in PostgreSQL, you need to install an open source extension called PostGIS. The PostGIS extension also provides additional functions and operators that work specifically with spatial data.

In this chapter, you’ll learn to use PostGIS to analyze roadways in Santa Fe, New Mexico as well as the location of farmers’ markets across the United States. You’ll learn how to construct and query spatial data types and how to work with different geographic data formats you might encounter when you obtain data from public and private data sources. You’ll also learn about map projections and grid systems. The goal is to give you tools to glean information from spatial data, similar to how you’ve analyzed numbers and text.

We’ll begin by setting up PostGIS so we can explore different types of spatial data. All code and data for the exercises are available with the book’s resources at [_https://www.nostarch.com/practicalSQL/_](https://www.nostarch.com/practicalSQL/).

#### Installing PostGIS and Creating a Spatial Database <a href="#lev235" id="lev235"></a>

PostGIS is a free, open source project created by the Canadian geospatial company Refractions Research and maintained by an international team of developers under the Open Source Geospatial Foundation. You’ll find documentation and updates at [_http://postgis.net/_](http://postgis.net/). If you’re using Windows or macOS and have installed PostgreSQL following the steps in the book’s Introduction, PostGIS should be on your machine. It’s also often installed on PostgreSQL on cloud providers, such as Amazon Web Services. But if you’re using Linux or if you installed PostgreSQL some other way on Windows or macOS, follow the installation instructions at [_http://postgis.net/install/_](http://postgis.net/install/).

Let’s create a database and enable PostGIS. The process is similar to the one you used to create your first database in [Chapter 1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch01.xhtml#ch01) but with a few extra steps. Follow these steps in pgAdmin to make a database called gis\_analysis:

1. In the pgAdmin object browser (left pane), connect to your server and expand the **Databases** node by clicking the plus sign.
2. Click once on the analysis database you’ve used for past exercises.
3. Choose **Tools ▸ Query Tool**.
4. In the Query Tool, run the code in [Listing 14-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list1).

CREATE DATABASE gis\_analysis;

_Listing 14-1: Creating a gis\_analysis database_

PostgreSQL will create the gis\_analysis database, which is no different than others you’ve made. To enable PostGIS extensions on it, follow these steps:

1. Close the Query Tool tab.
2. In the object browser, right-click **Databases** and select **Refresh**.
3. Click the new gis\_analysis database in the list to highlight it.
4. Open a new Query Tool tab by selecting **Tools ▸ Query Tool**. The gis\_analysis database should be listed at the top of the editing pane.
5. In the Query Tool, run the code in [Listing 14-2](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list2).

CREATE EXTENSION postgis;

_Listing 14-2: Loading the PostGIS extension_

You’ll see the message CREATE EXTENSION. Your database has now been updated to include spatial data types and dozens of spatial analysis functions. Run **SELECT postgis\_full\_version();** to display the version number of PostGIS along with its installed components. The version won’t match the PostgreSQL version installed, but that’s okay.

#### The Building Blocks of Spatial Data <a href="#lev236" id="lev236"></a>

Before you learn to query spatial data, let’s look at how it’s described in GIS and related data formats (although if you want to dive straight into queries, you can skip to [“Analyzing Farmers’ Markets Data”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#lev248) on [page 250](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#page\_250) and return here later).

A point on a grid is the smallest building block of spatial data. The grid might be marked with x- and y-axes, or longitude and latitude if we’re using a map. A grid could be flat, with two dimensions, or it could describe a three-dimensional space such as a cube. In some data formats, such as the JavaScript-based _GeoJSON_, a point might have a location on the grid as well as attributes providing additional information. For example, a grocery store could be described by a point containing its longitude and latitude as well as attributes showing the store’s name and hours of operation.

#### Two-Dimensional Geometries <a href="#lev237" id="lev237"></a>

To create more complex spatial data, you connect multiple points using lines. The International Organization for Standardization (ISO) and the Open Geospatial Consortium (OGC) have created a _simple feature_ standard for building and accessing two- and three-dimensional shapes, sometimes referred to as _geometries_. PostGIS supports the standard.

The most commonly used simple features you’ll encounter when querying or creating spatial data with PostGIS include the following:

**Point** A single location in a two- or three-dimensional plane. On maps, a Point is usually represented by a dot marking a longitude and latitude.

**LineString** Two or more points connected by a straight line. With LineStrings, you can represent features such as a road, hiking trail, or stream.

**Polygon** A two-dimensional shape, like a triangle or a square, that has three or more straight sides, each constructed from a LineString. In geographic analysis, Polygons represent objects such as nations, states, buildings, and bodies of water. A Polygon also can have one or more interior Polygons that act as holes inside the larger Polygon.

**MultiPoint** A set of Points. For example, you can represent multiple locations of a retailer with a single MultiPoint object that contains each store’s latitude and longitude.

**MultiLineString** A set of LineStrings. You can represent, for example, an object such as a road with several noncontinuous segments.

**MultiPolygon** A set of Polygons. For example, you can represent a parcel of land that is divided into two parts by a road: you can group them in one MultiPolygon object rather than using separate polygons.

[Figure 14-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14fig1) shows an example of each feature.

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/f0244-01.jpg)

_Figure 14-1: Visual examples of geometries_

Using PostGIS functions, you can create your own spatial data by constructing these objects using points or other geometries. Or, you can use PostGIS functions to perform calculations on existing spatial data. Generally, to create a spatial object, the functions require input of a _well-known text (WKT)_ string, which is text that represents a geometry, plus an optional _Spatial Reference System Identifier (SRID)_ that specifies the grid on which to place the objects. I’ll explain the SRID shortly, but first, let’s look at examples of WKT strings and then build some geometries using them.

_**Well-Known Text Formats**_

The OGC standard’s WKT format includes the geometry type and its coordinates inside one or more sets of parentheses. The number of coordinates and parentheses varies depending on the geometry you want to create. [Table 14-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14tab1) shows examples of the more frequently used geometry types and their WKT formats. Here, I show longitude/latitude pairs for the coordinates, but you might encounter grid systems that use other measures.

**NOTE**

_WKT accepts coordinates in the order of longitude, latitude, which is backward from Google Maps and some other software. Tom MacWright, formerly of the Mapbox software company, notes at_ [https://macwright.org/lonlat/](https://macwright.org/lonlat/) _that neither order is “right” and catalogs the “frustrating inconsistency” in which mapping-related code handles the order of coordinates._

**Table 14-1:** Well-Known Text Formats for Geometries

| **Geometry**    | **Format**                                                                                                                                   | **Notes**                                                                                                                                                |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Point           | POINT (-74.9 42.7)                                                                                                                           | A coordinate pair marking a point at −74.9 longitude and 42.7 latitude.                                                                                  |
| LineString      | LINESTRING (-74.9 42.7, -75.1 42.7)                                                                                                          | A straight line with endpoints marked by two coordinate pairs.                                                                                           |
| Polygon         | <p>POLYGON ((-74.9 42.7, -75.1 42.7,<br>-75.1 42.6, -74.9 42.7))</p>                                                                         | A triangle outlined by three different pairs of coordinates. Although listed twice, the first and last pair are the same coordinates, closing the shape. |
| MultiPoint      | MULTIPOINT (-74.9 42.7, -75.1 42.7)                                                                                                          | Two Points, one for each pair of coordinates.                                                                                                            |
| MultiLineString | MULTILINESTRING ((-76.27 43.1, -76.06 43.08), (-76.2 43.3, -76.2 43.4, -76.4 43.1))                                                          | Two LineStrings. The first has two points; the second has three.                                                                                         |
| MultiPolygon    | MULTIPOLYGON (((-74.92 42.7, -75.06 42.71, -75.07 42.64, -74.92 42.7), (-75.0 42.66, -75.0 42.64, -74.98 42.64, -74.98 42.66, -75.0 42.66))) | Two Polygons. The first is a triangle, and the second is a rectangle.                                                                                    |

Although these examples create simple shapes, in practice, complex geometries could comprise thousands of coordinates.

_**A Note on Coordinate Systems**_

Representing the Earth’s spherical surface on a two-dimensional map is not easy. Imagine peeling the outer layer of the Earth from the globe and trying to spread it on a table while keeping all pieces of the continents and oceans connected. Inevitably, some areas of the map would stretch. This is what occurs when cartographers create a map _projection_ with its own _projected coordinate system_ that flattens the Earth’s round surface to a two-dimensional plane.

Some projections represent the entire world; others are specific to regions or purposes. For example, the _Mercator projection_ is commonly used for navigation in apps, such as Google Maps. The math behind its transformation distorts land areas close to the North and South Poles, making them appear much larger than reality. The _Albers projection_ is the one you would most likely see displayed on TV screens in the United States as votes are tallied on election night. It’s also used by the U.S. Census Bureau.

Projections are derived from _geographic coordinate systems_, which define the grid of latitude, longitude, and height of any point on the globe along with factors including the Earth’s shape. Whenever you obtain geographic data, it’s critical to know the coordinate systems it references to check whether your calculations are accurate. Often, the coordinate system or projection is named in user documentation.

_**Spatial Reference System Identifier**_

When using PostGIS (and many GIS applications), you need to specify the coordinate system you’re using via its SRID. When you enabled the PostGIS extension at the beginning of this chapter, the process created the table spatial\_ref\_sys, which contains SRIDs as its primary key. The table also contains the column srtext, which includes a WKT representation of the spatial reference system as well as other metadata.

In this chapter, we’ll frequently use SRID 4326, the ID for the geographic coordinate system WGS 84. It’s the most recent World Geodetic System (WGS) standard used by GPS, and you’ll encounter it often if you acquire spatial data. You can see the WKT representation for WGS 84 by running the code in [Listing 14-3](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list3) that looks for its SRID, 4326:

SELECT srtext\
FROM spatial\_ref\_sys\
WHERE srid = 4326;

_Listing 14-3: Retrieving the WKT for SRID 4326_

Run the query and you should get the following result, which I’ve indented for readability:

GEOGCS\["WGS 84",\
&#x20;   DATUM\["WGS\_1984",\
&#x20;       SPHEROID\["WGS 84",6378137,298.257223563,\
&#x20;           AUTHORITY\["EPSG","7030"]],\
&#x20;       AUTHORITY\["EPSG","6326"]],\
&#x20;   PRIMEM\["Greenwich",0,\
&#x20;       AUTHORITY\["EPSG","8901"]],\
&#x20;   UNIT\["degree",0.0174532925199433,\
&#x20;       AUTHORITY\["EPSG","9122"]],\
&#x20;   AUTHORITY\["EPSG","4326"]]

You don’t need to use this information for any of this chapter’s exercises, but it’s helpful to know some of the variables and how they define the projection. The GEOGCS keyword provides the geographic coordinate system in use. Keyword PRIMEM specifies the location of the _Prime Meridian_, or longitude 0. To see definitions of all the variables, check the reference at [_http://docs.geotools.org/stable/javadocs/org/opengis/referencing/doc-files/WKT.html_](http://docs.geotools.org/stable/javadocs/org/opengis/referencing/doc-files/WKT.html).

Conversely, if you ever need to find the SRID associated with a coordinate system, you can query the srtext column in spatial\_ref\_sys to find it.

#### PostGIS Data Types <a href="#lev241" id="lev241"></a>

Installing PostGIS adds five data types to your database. The two data types we’ll use in the exercises are geography and geometry. Both types can store spatial data, such as the points, lines, polygons, SRIDs, and so on you just learned about, but they have important distinctions:

geography A data type based on a sphere, using the round-earth coordinate system (longitude and latitude). All calculations occur on the globe, taking its curvature into account. That makes the math complicated and limits the number of functions available to work with the geography type. But because the Earth’s curvature is factored in, calculations for distance are more precise; you should use the geography data type when handling data that spans large areas. Also, the results from calculations on the geography type will be expressed in meters.

geometry A data type based on a plane, using the Euclidean coordinate system. Calculations occur on straight lines as opposed to along the curvature of a sphere, making calculations for geographical distance less precise than with the geography data type; the results of calculations are expressed in units of whichever coordinate system you’ve designated.

The PostGIS documentation at [_https://postgis.net/docs/using\_postgis\_dbmanagement.html_](https://postgis.net/docs/using\_postgis\_dbmanagement.html) offers guidance on when to use one or the other type. In short, if you’re working strictly with longitude/latitude data or if your data covers a large area, such as a continent or the globe, use the geography type, even though it limits the functions you can use. If your data covers a smaller area, the geometry type provides more functions and better performance. You can also change one type to the other using CAST.

With the background you have now, we can start working with spatial objects.

#### Creating Spatial Objects with PostGIS Functions <a href="#lev242" id="lev242"></a>

PostGIS has more than three dozen constructor functions that build spatial objects using WKT or coordinates. You can find a list at [_https://postgis.net/docs/reference.html#Geometry\_Constructors_](https://postgis.net/docs/reference.html#Geometry\_Constructors), but the following sections explain several that you’ll use in the exercises. Most PostGIS functions begin with the letters ST, which is an ISO naming standard that means _spatial type_.

_**Creating a Geometry Type from Well-Known Text**_

The ST\_GeomFromText(WKT, SRID) function creates a geometry data type from an input of a WKT string and an optional SRID. [Listing 14-4](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list4) shows simple SELECT statements that generate geometry data types for each of the simple features described in [Table 14-1](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14tab1). Running these SELECT statements is optional, but it’s important to know how to construct each simple feature.

SELECT ST\_GeomFromText(➊'POINT(-74.9233606 42.699992)', ➋4326);\
SELECT ST\_GeomFromText('LINESTRING(-74.9 42.7, -75.1 42.7)', 4326);\
SELECT ST\_GeomFromText('POLYGON((-74.9 42.7, -75.1 42.7,\
&#x20;                                \-75.1 42.6, -74.9 42.7))', 4326);\
SELECT ST\_GeomFromText('MULTIPOINT (-74.9 42.7, -75.1 42.7)', 4326);\
SELECT ST\_GeomFromText('MULTILINESTRING((-76.27 43.1, -76.06 43.08),\
&#x20;                                       (-76.2 43.3, -76.2 43.4,\
&#x20;                                        \-76.4 43.1))', 4326);\
SELECT ST\_GeomFromText('MULTIPOLYGON➌((\
&#x20;                                      (-74.92 42.7, -75.06 42.71,\
&#x20;                                       \-75.07 42.64, -74.92 42.7)➍,\
&#x20;                                      (-75.0 42.66, -75.0 42.64,\
&#x20;                                       \-74.98 42.64, -74.98 42.66,\
&#x20;                                       \-75.0 42.66)))', 4326);

_Listing 14-4: Using ST\_GeomFromText() to create spatial objects_

For each example, we give coordinates as the first input and the SRID 4326 as the second. In the first example, we create a point by inserting the WKT POINT string ➊ as the first argument to ST\_GeomFromText() with the SRID ➋ as the optional second argument. We use the same format in the rest of the examples. Note that we don’t have to indent the coordinates. I only do so here to make the coordinate pairs more readable.

Be sure to keep track of the number of parentheses that segregate objects, particularly in complex structures, such as the MultiPolygon. For example, we need to use two opening parentheses ➌ and enclose each polygon’s coordinates within another set of parentheses ➍.

Executing each statement should return the geometry data type encoded in a string of characters that looks something like this truncated example:

0101000020E61000008EDA0E5718BB52C017BB7D5699594540 ...

This result shows how the data is stored in a table. Typically, you won’t be reading that string of code. Instead, you’ll use geometry (or geography) columns as inputs to functions.

_**Creating a Geography Type from Well-Known Text**_

To create a geography data type, you can use ST\_GeogFromText(WKT) to convert a WKT or ST\_GeogFromText(EWKT) to convert a PostGIS-specific variation called _extended WKT_ that includes the SRID. [Listing 14-5](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list5) shows how to pass in the SRID as part of the extended WKT string to create a MultiPoint geography object with three points:

SELECT\
ST\_GeogFromText('SRID=4326;MULTIPOINT(-74.9 42.7, -75.1 42.7, -74.924 42.6)')

_Listing 14-5: Using ST\_GeogFromText() to create spatial objects_

Along with the all-purpose ST\_GeomFromText() and ST\_GeogFromText() functions, PostGIS includes several that are specific to creating certain spatial objects. I’ll cover those briefly next.

_**Point Functions**_

The ST\_PointFromText() and ST\_MakePoint() functions will turn a WKT POINT into a geometry data type. Points mark coordinates, such as longitude and latitude, which you would use to identify locations or use as building blocks of other objects, such as LineStrings.

[Listing 14-6](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list6) shows how these functions work:

SELECT ➊ST\_PointFromText('POINT(-74.9233606 42.699992)', 4326);\
\
SELECT ➋ST\_MakePoint(-74.9233606, 42.699992);\
SELECT ➌ST\_SetSRID(ST\_MakePoint(-74.9233606, 42.699992), 4326);

_Listing 14-6: Functions specific to making Points_

The ST\_PointFromText(WKT, SRID) ➊ function creates a point geometry type from a WKT POINT and an optional SRID as the second input. The PostGIS docs note that the function includes validation of coordinates that makes it slower than the ST\_GeomFromText() function.

The ST\_MakePoint(x, y, z, m) ➋ function creates a point geometry type on a two-, three-, and four-dimensional grid. The first two parameters, x and y in the example, represent longitude and latitude coordinates. You can use the optional z to represent altitude and m to represent a fourth-dimensional measure, such as time. That would allow you to mark a location at a certain time, for example. The ST\_MakePoint() function is faster than ST\_GeomFromText() and ST\_PointFromText(), but if you want to specify an SRID, you’ll need to designate one by wrapping it inside the ST\_SetSRID() ➌ function.

_**LineString Functions**_

Now let’s examine some functions we use specifically for creating LineString geometry data types. [Listing 14-7](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list7) shows how they work:

SELECT ➊ST\_LineFromText('LINESTRING(-105.90 35.67,-105.91 35.67)', 4326);\
SELECT ➋ST\_MakeLine(ST\_MakePoint(-74.9, 42.7), ST\_MakePoint(-74.1, 42.4));

_Listing 14-7: Functions specific to making LineStrings_

The ST\_LineFromText(WKT, SRID) ➊ function creates a LineString from a WKT LINESTRING and an optional SRID as its second input. Like ST\_PointFromText() earlier, this function includes validation of coordinates that makes it slower than ST\_GeomFromText().

The ST\_MakeLine(geom, geom) ➋ function creates a LineString from inputs that must be of the geometry data type. In [Listing 14-7](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list7), the example uses two ST\_MakePoint() functions as inputs to create the start and endpoint of the line. You can also pass in an ARRAY object with multiple points, perhaps generated by a subquery, to generate a more complex line.

_**Polygon Functions**_

Let’s look at three Polygon functions: ST\_PolygonFromText(), ST\_MakePolygon(), and ST\_MPolyFromText(). All create geometry data types. [Listing 14-8](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list8) shows how you can create Polygons with each:

SELECT ➊ST\_PolygonFromText('POLYGON((-74.9 42.7, -75.1 42.7,\
&#x20;                                     \-75.1 42.6, -74.9 42.7))', 4326);\
\
SELECT ➋ST\_MakePolygon(\
&#x20;            ST\_GeomFromText('LINESTRING(-74.92 42.7, -75.06 42.71,\
&#x20;                                        \-75.07 42.64, -74.92 42.7)', 4326));\
\
SELECT ➌ST\_MPolyFromText('MULTIPOLYGON((\
&#x20;                                        (-74.92 42.7, -75.06 42.71,\
&#x20;                                         \-75.07 42.64, -74.92 42.7),\
&#x20;                                        (-75.0 42.66, -75.0 42.64,\
&#x20;                                         \-74.98 42.64, -74.98 42.66,\
&#x20;                                         \-75.0 42.66)\
&#x20;                                       ))', 4326);

_Listing 14-8: Functions specific to making Polygons_

The ST\_PolygonFromText(WKT, SRID) ➊ function creates a Polygon from a WKT POLYGON and an optional SRID. As with the similarly named functions for creating points and lines, it includes a validation step that makes it slower than ST\_GeomFromText().

The ST\_MakePolygon(linestring) ➋ function creates a Polygon from a LineString that must open and close with the same coordinates, ensuring the object is closed. This example uses ST\_GeomFromText() to create the LineString geometry using a WKT LINESTRING.

The ST\_MPolyFromText(WKT, SRID) ➌ function creates a MultiPolygon from a WKT and an optional SRID.

Now you have the building blocks to analyze spatial data. Next, we’ll use them to explore a set of data.

#### Analyzing Farmers’ Markets Data <a href="#lev248" id="lev248"></a>

The National Farmers’ Market Directory from the U.S. Department of Agriculture catalogs the location and offerings of more than 8,600 “markets that feature two or more farm vendors selling agricultural products directly to customers at a common, recurrent physical location,” according to [_https://www.ams.usda.gov/local-food-directories/farmersmarkets/_](https://www.ams.usda.gov/local-food-directories/farmersmarkets/). Attending these markets makes for an enjoyable weekend activity, so it would help to find those within a reasonable traveling distance. We can use SQL spatial queries to find the closest markets.

The _farmers\_markets.csv_ file contains a portion of the USDA data on each market, and it’s available along with the book’s resources at [_https://www.nostarch.com/practicalSQL/_](https://www.nostarch.com/practicalSQL/). Save the file to your computer and run the code in [Listing 14-9](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list9) to create and load a farmers\_markets table. Make sure you’re connected to the gis\_analysis database you made earlier in this chapter, and change the COPY statement file path to match your file’s location.

CREATE TABLE farmers\_markets (\
&#x20;   fmid bigint PRIMARY KEY,\
&#x20;   market\_name varchar(100) NOT NULL,\
&#x20;   street varchar(180),\
&#x20;   city varchar(60),\
&#x20;   county varchar(25),\
&#x20;   st varchar(20) NOT NULL,\
&#x20;   zip varchar(10),\
&#x20;   longitude numeric(10,7),\
&#x20;   latitude numeric(10,7),\
&#x20;   organic varchar(1) NOT NULL\
);\
\
COPY farmers\_markets\
FROM '_C:\YourDirectory\\_farmers\_markets.csv'\
WITH (FORMAT CSV, HEADER);

_Listing 14-9: Creating and loading the farmers\_markets table_

The table contains routine address data plus the longitude and latitude for most markets. Twenty-nine of the markets were missing those values when I downloaded the file from the USDA. An organic column indicates whether the market offers organic products; a hyphen (-) in that column indicates an unknown value. After you import the data, count the rows using SELECT count(\*) FROM farmers\_markets;. If everything imported correctly, you should have 8,681 rows.

_**Creating and Filling a Geography Column**_

To perform spatial queries on the markets’ longitude and latitude, we need to convert those coordinates into a single column of a spatial data type. Because we’re working with locations spanning the entire United States and an accurate measurement of a large spherical distance is important, we’ll use the geography type. After creating the column, we can update it using Points derived from the coordinates, and then apply an index to speed up queries. [Listing 14-10](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list10) contains the statements for doing these tasks:

➊ ALTER TABLE farmers\_markets ADD COLUMN geog\_point geography(POINT,4326);\
\
&#x20; UPDATE farmers\_markets\
&#x20; SET geog\_point =\
&#x20;     ➋ST\_SetSRID(\
&#x20;               ➌ST\_MakePoint(longitude,latitude),4326\
&#x20;               )➍::geography;\
\
➎ CREATE INDEX market\_pts\_idx ON farmers\_markets USING GIST (geog\_point);\
\
&#x20; SELECT longitude,\
&#x20;        latitude,\
&#x20;        geog\_point,\
&#x20;      ➏ ST\_AsText(geog\_point)\
&#x20; FROM farmers\_markets\
&#x20; WHERE longitude IS NOT NULL\
&#x20; LIMIT 5;

_Listing 14-10: Creating and indexing a geography column_

The ALTER TABLE statement ➊ you learned in [Chapter 9](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch09.xhtml#ch09) with the ADD COLUMN option creates a column of the geography type called geog\_point that will hold points and reference the WSG 84 coordinate system, which we denote using SRID 4326.

Next, we run a standard UPDATE statement to fill the geog\_point column. Nested inside a ST\_SetSRID() ➋ function, the ST\_MakePoint() ➌ function takes as input the longitude and latitude columns from the table. The output, which is the geometry type by default, must be cast to geography to match the geog\_point column type. To do this, we use the PostgreSQL-specific double-colon syntax (::) ➍ for casting data types.

_**Adding a GiST Index**_

Before you start analysis, it’s wise to add an index to the new column to speed up calculations. In [Chapter 7](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch07.xhtml#ch07), you learned about PostgreSQL’s default index, the B-Tree. A B-Tree index is useful for data that you can order and search using equality and range operators, but it’s less useful for spatial objects. The reason is that you cannot easily sort GIS data along one axis. For example, the application has no way to determine which of these coordinate pairs is greatest: (0,0), (0,1), or (1,0).

Instead, for spatial data, the makers of PostGIS recommend using the Generalized Search Tree (GiST) index. PostgreSQL core team member Bruce Momjian describes GiST as “a general indexing framework designed to allow indexing of complex data types,” including geometries.

The CREATE INDEX statement ➎ in [Listing 14-10](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list10) adds a GiST index to geog\_point. We can then use the SELECT statement to view the geography data to show the newly encoded geog\_points column. To view the WKT version of geog\_point, we wrap it in a ST\_AsText() function ➏. The results should look similar to this, with geog\_point truncated for brevity:

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/prog\_page\_253.jpg)

Now we’re ready to perform calculations on the points.

_**Finding Geographies Within a Given Distance**_

While in Iowa in 2014 to report a story on farming, I visited the massive Downtown Farmers’ Market in Des Moines. With hundreds of vendors, the market spans several city blocks in the Iowa capital. Farming is big business in Iowa, and even though the downtown market is huge, it’s not the only one in the area. Let’s use PostGIS to find more farmers’ markets within a short distance from the downtown Des Moines market.

The PostGIS function ST\_DWithin() returns a Boolean value of true if one spatial object is within a specified distance of another object. If you’re working with the geography data type, as we are here, you need to use meters as the distance unit. If you’re using the geometry type, use the distance unit specified by the SRID.

**NOTE**

_PostGIS distance measurements are on a straight line for geometry data, whereas for geography data, they’re on a sphere. Be careful not to confuse either with driving distance along roadways, which is usually farther from point to point. To perform calculations related to driving distances, check out the extension pgRouting at_ [http://pgrouting.org/](http://pgrouting.org/).

[Listing 14-11](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list11) uses the ST\_DWithin() function to filter farmers\_markets to show markets within 10 kilometers of the Downtown Farmers’ Market in Des Moines:

SELECT market\_name,\
&#x20;      city,\
&#x20;      st\
FROM farmers\_markets\
WHERE ST\_DWithin(➊geog\_point,\
&#x20;                ➋ST\_GeogFromText('POINT(-93.6204386 41.5853202)'),\
&#x20;                ➌10000)\
ORDER BY market\_name;

_Listing 14-11: Using ST\_DWithin() to locate farmers’ markets within 10 kilometers of a point_

The first input for ST\_DWithin() is geog\_point ➊, which holds the location of each row’s market in the geography data type. The second input is the ST\_GeogFromText() function ➋ that returns a point geography from WKT. The coordinates -93.6204386 and 41.5853202 represent the longitude and latitude of the Downtown Farmers’ Market in Des Moines. The final input is 10000 ➌, which is the number of meters in 10 kilometers. The database calculates the distance between each market in the table and the downtown market. If a market is within 10 kilometers, it is included in the results.

We’re using points here, but this function works with any geography or geometry type. If you’re working with objects such as polygons, you can use the related ST\_DFullyWithin() function to find objects that are completely within a specified distance.

Run the query; it should return nine rows:

market\_name                                city               st\
\---------------------------------------    ---------------    ----\
Beaverdale Farmers Market                  Des Moines         Iowa\
Capitol Hill Farmers Market                Des Moines         Iowa\
Downtown Farmers' Market - Des Moines      Des Moines         Iowa\
Drake Neighborhood Farmers Market          Des Moines         Iowa\
Eastside Farmers Market                    Des Moines         Iowa\
Highland Park Farmers Market               Des Moines         Iowa\
Historic Valley Junction Farmers Market    West Des Moines    Iowa\
LSI Global Greens Farmers' Market          Des Moines         Iowa\
Valley Junction Farmers Market             West Des Moines    Iowa

One of these nine markets is the Downtown Farmers’ Market in Des Moines, which makes sense because its location is at the point used for comparison. The rest are other markets in Des Moines or in nearby West Des Moines. This operation should be familiar because it’s a standard feature on many online maps and product apps that let you locate stores or points of interest near you.

Although this list of nearby markets is helpful, it would be even more helpful to know the exact distance of markets from downtown. We’ll use another function to report that.

_**Finding the Distance Between Geographies**_

The ST\_Distance() function returns the minimum distance between two spatial objects. It also returns meters for geographies and SRID units for geometries. For example, [Listing 14-12](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list12) calculates the distance in miles from Yankee Stadium in New York City’s Bronx borough to Citi Field in Queens, home of the New York Mets:

SELECT ST\_Distance(\
&#x20;                  ST\_GeogFromText('POINT(-73.9283685 40.8296466)'),\
&#x20;                  ST\_GeogFromText('POINT(-73.8480153 40.7570917)')\
&#x20;                  ) / 1609.344 AS mets\_to\_yanks;

_Listing 14-12: Using ST\_Distance() to calculate the miles between Yankee Stadium and Citi Field (Mets)_

In this example, to see the result in miles, we divide the result of the ST\_Distance() function by 1609.344 (the number of meters in a mile) to convert the unit of distance from meters to miles. The result is about 6.5 miles:

mets\_to\_yanks\
\----------------\
6.54386182787521

Let’s apply this technique for finding distance between points to the farmers’ market data using the code in [Listing 14-13](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list13). We’ll display all farmers’ markets within 10 kilometers of the Downtown Farmers’ Market in Des Moines and show the distance in miles:

&#x20; SELECT market\_name,\
&#x20;        city,\
&#x20;       ➊round(\
&#x20;             (ST\_Distance(geog\_point,\
&#x20;                          ST\_GeogFromText('POINT(-93.6204386 41.5853202)')\
&#x20;                          ) / 1609.344)➋::numeric(8,5), 2\
&#x20;             ) AS miles\_from\_dt\
&#x20; FROM farmers\_markets\
➌ WHERE ST\_DWithin(geog\_point,\
&#x20;                  ST\_GeogFromText('POINT(-93.6204386 41.5853202)'),\
&#x20;                  10000\)\
&#x20; ORDER BY miles\_from\_dt ASC;

_Listing 14-13: Using ST\_Distance() for each row in farmers\_markets_

The query is similar to [Listing 14-11](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list11), which used ST\_DWithin() to find markets 10 kilometers or closer to downtown, but adds the ST\_Distance() function as a column to calculate and display the distance from downtown. I’ve wrapped the function inside round() ➊ to trim the output.

We provide ST\_Distance() with the same two inputs we gave ST\_DWithin() in [Listing 14-11](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list11): geog\_point and the ST\_GeogFromText() function. The ST\_Distance() function then calculates the distance between the points specified by both inputs, returning the result in meters. To convert to miles, we divide by 1609.344 ➋, which is the approximate number of meters in a mile. Then, to provide the round() function with the correct input data type, we cast the column result to type numeric.

The WHERE clause ➌ uses the same ST\_DWithin() function and inputs as in [Listing 14-11](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list11). You should see the following results, ordered by distance in ascending order:

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/prog\_page\_255.jpg)

Again, this is the type of list you see every day on your phone or computer when you’re searching online for a nearby store or address. You might also find it helpful for many other analysis scenarios, such as finding all the schools within a certain distance of a known source of pollution or all the houses within five miles of an airport.

**NOTE**

_Another type of distance measurement supported by PostGIS,_ K-Nearest Neighbor, _provides the ability to quickly find the closest point or shape to one you specify. For an overview of how it works, see_ [https://postgis.net/workshops/postgis-intro/knn.html](https://postgis.net/workshops/postgis-intro/knn.html).

So far, you’ve learned how to build spatial objects from WKT. Next, I’ll show you a common data format used in GIS called the _shapefile_ and how to bring it into PostGIS for analysis.

#### Working with Census Shapefiles <a href="#lev253" id="lev253"></a>

A _shapefile_ is a GIS data format developed by Esri, a U.S. company known for its ArcGIS mapping visualization and analysis platform. In addition to serving as the standard file format for GIS platforms—such as ArcGIS and the open source QGIS—governments, corporations, nonprofits, and technical organizations use shapefiles to display, analyze, and distribute data that includes a variety of geographic features, such as buildings, roads, and territorial boundaries.

Shapefiles contain the information describing the shape of a feature (such as a county, a road, or a lake) as well as a database containing attributes about them. Those attributes might include their name and other descriptors. A single shapefile can contain only one type of shape, such as polygons or points, and when you load a shapefile into a GIS platform that supports visualization, you can view the shapes and query their attributes. PostgreSQL, with the PostGIS extension, doesn’t visualize the shapefile data, but it does allow you to run complex queries on the spatial data in the shapefile, which we’ll do in [“Exploring the Census 2010 Counties Shapefile”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#lev259) on [page 259](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#page\_259) and [“Performing Spatial Joins”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#lev262) on [page 262](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#page\_262).

First, let’s examine the structure and contents of shapefiles.

_**Contents of a Shapefile**_

A shapefile refers to a collection of files with different extensions, and each serves a different purpose. Usually, when you download a shapefile from a source, it comes in a compressed archive, such as _.zip_. You’ll need to unzip it to access the individual files.

Per ArcGIS documentation, these are the most common extensions you’ll encounter:

**.shp** Main file that stores the feature geometry.

**.shx** Index file that stores the index of the feature geometry.

**.dbf** Database table (in dBASE format) that stores the attribute information of features.

**.xml** XML-format file that stores metadata about the shapefile.

**.prj** Projection file that stores the coordinate system information. You can open this file with a text editor to view the geographic coordinate system and projection.

According to the documentation, files with the first three extensions include necessary data required for working with a shapefile. The other file types are optional. You can load a shapefile into PostGIS to access its spatial objects and the attributes for each. Let’s do that next and explore some additional analysis functions.

_**Loading Shapefiles via the GUI Tool**_

There are two ways to load shapefiles into your database. The PostGIS suite includes a Shapefile Import/Export Manager with a simple _graphical user interface (GUI)_, which users may prefer. Alternately, you can use the command line application shp2pgsql, which is described in [“Loading Shapefiles with shp2pgsql”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#lev301) on [page 311](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#page\_311).

Let’s start with a look at how to work with the GUI tool.

**Windows Shapefile Importer/Exporter**

On Windows, if you followed the installation steps in the book’s Introduction, you should find the Shapefile Import/Export Manager by selecting **Start ▸ PostGIS Bundle** **x.y for PostgreSQL x64** **x.y ▸ PostGIS 2.0 Shapefile and DBF Loader Exporter**.

Whatever you see in place of _x.y_ should match the version of the software you downloaded. You can skip ahead to [“Connecting to the Database and Loading a Shapefile”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#lev258) on [page 258](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#page\_258).

**macOS and Linux Shapefile Importer/Exporter**

On macOS, the _postgres.app_ installation outlined in the book’s Introduction doesn’t include the GUI tool, and as of this writing there is no macOS version of the GUI tool available—unless you have the ability to compile it yourself from source code. I’ll update the status at the book’s resources at [_https://www.nostarch.com/practicalSQL/_](https://www.nostarch.com/practicalSQL/) if that changes. In the meantime, follow the instructions found in [“Loading Shapefiles with shp2pgsql”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#lev301) on [page 311](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch16.xhtml#page\_311). Then move on to [“Exploring the Census 2010 Counties Shapefile”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#lev259) on [page 259](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#page\_259).

For Linux users, pgShapeLoader is available as the application _shp2pgsql-gui_. Visit [_http://postgis.net/install/_](http://postgis.net/install/) and follow the instructions for your Linux distribution.

Now, you can connect to the database and load a shapefile.

**Connecting to the Database and Loading a Shapefile**

Let’s connect the Shapefile Import/Export Manager to your database and then load a shapefile. I’ve included several shapefiles with the resources for this chapter at [_https://www.nostarch.com/practicalSQL/_](https://www.nostarch.com/practicalSQL/). We’ll start with TIGER/Line Shapefiles from the U.S. Census that contain the boundaries for each county or county equivalent, such as parish or borough, as of the 2010 Decennial Census. You can learn more about this series of shapefiles at [_https://www.census.gov/geo/maps-data/data/tiger-line.html_](https://www.census.gov/geo/maps-data/data/tiger-line.html).

**NOTE**

_Many organizations provide data in shapefile format. Start with your national or local government agencies or check the Wikipedia entry “List of GIS data sources.”_

Save _tl\_2010\_us\_county10.zip_ to your computer and unzip it; the archive should contain five files with the extensions I listed earlier on [page 257](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#page\_257). Then open the Shapefile and DBF Loader Exporter app.

First, you need to establish a connection between the app and your gis\_analysis database. To do that, follow these steps:

1. Click **View connection details**.
2. In the dialog that opens, enter postgres for the **Username**, and enter a password if you added one for the server during initial setup.
3. Ensure that **Server Host** has localhost and 5432 by default. Leave those as is unless you’re on a different server or port.
4. Enter gis\_analysis for the **Database** name. [Figure 14-2](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14fig2) shows a screenshot of what the connection should look like.
5. Click **OK**. You should see the message Connection Succeeded in the log window.

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/f0258-01.jpg)

_Figure 14-2: Establishing the PostGIS connection in the shapefile loader_

Now that you’ve successfully established the PostGIS connection, you can load your shapefile:

1. Under **Options**, change **DBF file character encoding** to Latin1—we do this because the shapefile attributes include county names with characters that require this encoding. Keep the default checked boxes, including the one to create an index on the spatial column. Click **OK**.
2.  Click **Add File** and select _tl\_2010\_us\_county10.shp_ from the location you saved it. Click **Open**. The file should appear in the Shapefile list in the loader, as shown in [Figure 14-3](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14fig3).

    ![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/f0259-01.jpg)

    _Figure 14-3: Specifying upload details in the shapefile loader_
3. In the **Table** column, double-click to select the table name. Replace it with us\_counties\_2010\_shp.
4. In the **SRID** column, double-click and enter **4269**. That’s the ID for the North American Datum 1983 coordinate system, which is often used by U.S. federal agencies including the Census Bureau.
5. Click **Import**.

In the log window, you should see a message that ends with the following message:

Shapefile type: Polygon\
PostGIS type: MULTIPOLYGON\[2]\
Shapefile import completed.

Switch to pgAdmin, and in the object browser, expand the gis\_analysis node and continue expanding by selecting **Schemas ▸ public ▸ Tables**. Refresh your tables by right-clicking **Tables** and selecting **Refresh** from the pop-up menu. You should see us\_counties\_2010\_shp listed. Congrats! You’ve loaded your shapefile into a table. As part of the import, the shapefile loader also indexed the geom column.

_**Exploring the Census 2010 Counties Shapefile**_

The us\_counties\_2010\_shp table contains columns including each county’s name as well as the _Federal Information Processing Standards (FIPS)_ codes uniquely assigned to each state and county. The geom column contains the spatial data on each county’s boundary. To start, let’s check what kind of spatial object geom contains using the ST\_AsText() function. Use the code in [Listing 14-14](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list14) to show the WKT representation of the first geom value in the table.

SELECT ST\_AsText(geom)\
FROM us\_counties\_2010\_shp\
LIMIT 1;

_Listing 14-14: Checking the geom column’s WKT representation_

The result is a MultiPolygon with hundreds of coordinate pairs that outline the boundary of the county. Here’s a portion of the output:

MULTIPOLYGON(((-162.637688 54.801121,-162.641178 54.795317,-162.644046\
54.789099,-162.653751 54.780339,-162.666629 54.770215,-162.677799 54.762716,-\
162.692356 54.758771,-162.70676 54.754987,-162.722965 54.753155,-162.740178\
54.753102,-162.76206 54.757968,-162.783454 54.765285,-162.797004 54.772181,\
\-162.802591 54.775817,-162.807411 54.779871,-162.811898 54.786852, _--snip--_ )))

Each coordinate pair marks a point on the boundary of the county. Now, you’re ready to analyze the data.

**Finding the Largest Counties in Square Miles**

The census data leads us to a natural question: which county has the largest area? To calculate the county area, [Listing 14-15](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list15) uses the ST\_Area() function, which returns the area of a Polygon or MultiPolygon object. If you’re working with a geography data type, ST\_Area() returns the result in square meters. With a geometry data type, the function returns the area in SRID units. Typically, the units are not useful for practical analysis, but you can cast the geometry data to geography to obtain square meters. That’s what we’ll do here. This is a more intensive calculation than others we’ve done so far, so if you’re using an older computer, expect extra time for the query to complete.

SELECT name10,\
&#x20;      statefp10 AS st,\
&#x20;      round(\
&#x20;            ( ST\_Area(➊geom::geography) / ➋2589988.110336 )::numeric, 2\
&#x20;           )  AS ➌square\_miles\
FROM us\_counties\_2010\_shp\
ORDER BY square\_miles ➍DESC\
LIMIT 5;

_Listing 14-15: Finding the largest counties by area using ST\_Area()_

The geom column is data type geometry, so to find the area in square meters, we cast the geom column as a geography data type using the double-colon syntax ➊. Then, to get square miles, we divide the area by 2589988.110336, which is the number of square meters in a square mile ➋. To make the result easier to read, I’ve wrapped it in a round() function and named the resulting column square\_miles ➌. Finally, we list the results in descending order from the largest area to the smallest ➍ and use LIMIT 5 to show only the first five results, which should look like this:

name10              st    square\_miles\
\----------------    --    ------------\
Yukon-Koyukuk       02       147805.08\
North Slope         02        94796.21\
Bethel              02        45504.36\
Northwest Arctic    02        40748.95\
Valdez-Cordova      02        40340.08

The five counties with the largest areas are all in Alaska, denoted by the state FIPS code 02. Yukon-Koyukuk, located in the heart of Alaska, is more than 147,800 square miles. (Keep that information in mind for the “Try It Yourself” exercise at the end of the chapter.)

**Finding a County by Longitude and Latitude**

If you’ve ever wondered how website ads seem to know where you live (“You won’t believe what this Boston man did with his old shoes!”), it’s thanks to _geolocation services_ that use various means, such as your phone’s GPS, to find your longitude and latitude. Once your coordinates are known, they can be used in a spatial query to find which geography contains that point.

You can do the same using your census shapefile and the ST\_Within() function, which returns true if one geometry is inside another. [Listing 14-16](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list16) shows an example using the longitude and latitude of downtown Hollywood:

SELECT name10,\
&#x20;      statefp10\
FROM us\_counties\_2010\_shp\
WHERE ST\_Within('SRID=4269;POINT(-118.3419063 34.0977076)'::geometry, geom);

_Listing 14-16: Using ST\_Within() to find the county belonging to a pair of coordinates_

The ST\_Within() function inside the WHERE clause requires two geometry inputs and checks whether the first is inside the second. For the function to work properly, both geometry inputs must have the same SRID. In this example, the first input is an extended WKT representation of a Point that includes the SRID 4269 (same as the census data), which is then cast as a geometry type. The ST\_Within() function doesn’t accept a separate SRID input, so to set it for the supplied WKT, you must prefix it to the string like this: 'SRID=4269;POINT(-118.3419063 34.0977076)'. The second input is the geom column from the table. Run the query; you should see the following result:

name10         statefp10\
\-----------    ---------\
Los Angeles    06

The query shows that the Point you supplied is within Los Angeles county in California (state FIPS 06). This information is very handy, because by joining additional data to this table you can tell a person about demographics or points of interest near them. Try supplying other longitude and latitude pairs to see which U.S. county they fall in. If you provide coordinates outside the United States, the query should return no results because the shapefile only contains U.S. areas.

#### Performing Spatial Joins <a href="#lev262" id="lev262"></a>

In [Chapter 6](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch06.xhtml#ch06), you learned about SQL joins, which involved linking related tables via columns where values match or where an expression is true. You can perform joins using spatial data columns too, which opens up interesting opportunities for analysis. For example, you could join a table of coffee shops (which includes their longitude and latitude) to the counties table to find out how many shops exist in each county based on their location. Or, you can use a spatial join to append data from one table to another for analysis, again based on location. In this section, we’ll explore spatial joins with a detailed look at roads and waterways using census data.

_**Exploring Roads and Waterways Data**_

Much of the year, the Santa Fe River, which cuts through the New Mexico state capital, is a dry riverbed better described as an _intermittent stream_. According to the Santa Fe city website, the river is susceptible to flash flooding and was named the nation’s most endangered river in 2007. If you were an urban planner, it would help to know where the river crosses roadways so you could plan for emergency response when it floods.

You can determine these locations using another set of U.S. Census TIGER/Line shapefiles, which has details on roads and waterways in Santa Fe County. These shapefiles are also included with the book’s resources. Download and unzip _tl\_2016\_35049\_linearwater.zip_ and _tl\_2016\_35049\_roads.zip_, and then launch the Shapefile and DBF Loader Exporter. Following the same steps in [“Loading Shapefiles via the GUI Tool”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#lev255) on [page 257](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#page\_257), import both shapefiles to gis\_analysis. Name the water table santafe\_linearwater\_2016 and the roads table santafe\_roads\_2016.

Next, refresh your database and run a quick SELECT \* FROM query on both tables to view the data. You should have 12,926 rows in the roads table and 1,198 in the linear water table.

As with the counties shapefile you imported via the loader GUI, both tables have an indexed geom column of type geometry. It’s helpful to check the type of spatial object in the column so you know the type of spatial feature you’re querying. You can do that using the ST\_AsText() function you learned in [Listing 14-14](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list14) or using ST\_GeometryType(), as shown in [Listing 14-17](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list17):

SELECT ST\_GeometryType(geom)\
FROM santafe\_linearwater\_2016\
LIMIT 1;\
\
SELECT ST\_GeometryType(geom)\
FROM santafe\_roads\_2016\
LIMIT 1;

_Listing 14-17: Using ST\_GeometryType() to determine geometry_

Both queries should return one row with the same value: ST\_MultiLineString. That value indicates that waterways and roads are stored as MultiLineString objects, which are a series of points connected by straight lines.

_**Joining the Census Roads and Water Tables**_

To find all the roads in Santa Fe that cross the Santa Fe River, we’ll join the tables using the JOIN ... ON syntax you learned in [Chapter 6](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch06.xhtml#ch06). Rather than looking for values that match in columns in both tables as usual, we’ll write a query that tells us where objects overlap. We’ll do this using the ST\_Intersects() function, which returns a Boolean true if two spatial objects contact each other. Inputs can be either geometry or geography types. [Listing 14-18](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list18) joins the tables:

➊ SELECT water.fullname AS waterway,\
&#x20;        roads.rttyp,\
&#x20;        roads.fullname AS road\
➋ FROM santafe\_linearwater\_2016 water JOIN santafe\_roads\_2016 roads\
&#x20;    ➌ ON ST\_Intersects(water.geom, roads.geom)\
&#x20; WHERE water.fullname = ➍'Santa Fe Riv'\
&#x20; ORDER BY roads.fullname;

_Listing 14-18: Spatial join with ST\_Intersects() to find roads crossing the Santa Fe River_

The SELECT column list ➊ includes the fullname column from the santafe\_linearwater\_2016 table, which gets water as its alias in the FROM ➋ clause. The column list includes the rttyp code, which represents the route type, and fullname columns from the santafe\_roads\_2016 table, aliased as roads.

In the ON portion ➌ of the JOIN clause, we use the ST\_Intersects() function with the geom columns from both tables as inputs. This is an example of using the ON clause with an expression that evaluates to a Boolean result, as noted in [“Linking Tables Using JOIN”](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch06.xhtml#lev81) on [page 74](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch06.xhtml#page\_74). Then we use fullname to filter the results to show only those that have the full string 'Santa Fe Riv' ➍, which is how the Santa Fe River is listed in the water table. The query should return 54 rows; here are the first five:

waterway        rttyp    road\
\------------    -----    ----------------\
Santa Fe Riv    M        Baca Ranch Ln\
Santa Fe Riv    M        Cam Alire\
Santa Fe Riv    M        Cam Carlos Rael\
Santa Fe Riv    M        Cam Dos Antonios\
Santa Fe Riv    M        Cerro Gordo Rd\
_--snip--_

Each road in the results intersects with a portion of the Santa Fe River. The route type code for each of the first results is M, which indicates that the road name shown is its _common_ name as opposed to a county or state recognized name, for example. Other road names in the complete results carry route types of C, S, or U (for unknown). The full route type code list is available at [_https://www.census.gov/geo/reference/rttyp.html_](https://www.census.gov/geo/reference/rttyp.html).

_**Finding the Location Where Objects Intersect**_

We successfully identified all the roads that intersect the Santa Fe River. This is a good start, but it would help our survey of flood-danger areas more to know precisely where each intersection occurs. We can modify the query to include the ST\_Intersection() function, which returns the location of the place where objects cross. I’ve added it as a column in [Listing 14-19](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch14.xhtml#ch14list19):

SELECT water.fullname AS waterway,\
&#x20;      roads.rttyp,\
&#x20;      roads.fullname AS road,\
&#x20;     ➊ST\_AsText(ST\_Intersection(➋water.geom, roads.geom))\
FROM santafe\_linearwater\_2016 water JOIN santafe\_roads\_2016 roads\
&#x20;   ON ST\_Intersects(water.geom, roads.geom)\
WHERE water.fullname = 'Santa Fe Riv'\
ORDER BY roads.fullname;

_Listing 14-19: Using ST\_Intersection() to show where roads cross the river_

The function returns a geometry object, so to get its WKT representation, we must wrap it in ST\_AsText() ➊. The ST\_Intersection() function takes two inputs: the geom columns ➋ from both the water and roads tables. Run the query, and the results should now include the exact coordinate location, or locations, where the river crosses the roads:

![image](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492067580/files/images/prog\_page\_264.jpg)

You can probably think of more ideas for analyzing spatial data. For example, if you obtained a shapefile showing buildings, you could find those close to the river and in danger of flooding during heavy rains. Governments and private organizations regularly use these techniques as part of their planning process.

**Wrapping Up**

Mapping features is a powerful analysis tool, and the techniques you learned in this chapter provide you with a strong start toward exploring more with PostGIS. You might also want to look at the open source mapping application QGIS ([_http://www.qgis.org/_](http://www.qgis.org/)), which provides tools for visualizing geographic data and working in depth with shapefiles. QGIS also works quite well with PostGIS, letting you add data from your tables directly onto a map.

You’ve now added working with geographic data to your analysis skills. In the remaining chapters, I’ll give you additional tools and tips for working with PostgreSQL and related tools to continue to increase your skills.

**TRY IT YOURSELF**

Use the spatial data you’ve imported in this chapter to try additional analysis:

1. Earlier, you found which U.S. county has the largest area. Now, aggregate the county data to find the area of each state in square miles. (Use the statefp10 column in the us\_counties\_2010\_shp table.) How many states are bigger than the Yukon-Koyukuk area?
2. Using ST\_Distance(), determine how many miles separate these two farmers’ markets: the Oakleaf Greenmarket (9700 Argyle Forest Blvd, Jacksonville, Florida) and Columbia Farmers Market (1701 West Ash Street, Columbia, Missouri). You’ll need to first find the coordinates for both in the farmers\_markets table. (Hint: You can also write this query using the Common Table Expression syntax you learned in [Chapter 12](https://learning.oreilly.com/library/view/practical-sql/9781492067580/xhtml/ch12.xhtml#ch12).)
3. More than 500 rows in the farmers\_markets table are missing a value in the county column, which is an example of dirty government data. Using the us\_counties\_2010\_shp table and the ST\_Intersects() function, perform a spatial join to find the missing county names based on the longitude and latitude of each market. Because geog\_point in farmers\_markets is of the geography type and its SRID is 4326, you’ll need to cast geom in the census table to the geography type and change its SRID using ST\_SetSRID().
