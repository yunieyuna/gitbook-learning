# 10. Automating Trading Operations

## Chapter 10. Automating Trading Operations

> People worry that computers will get too smart and take over the world, but the real problem is that they’re too stupid and they’ve already taken over the world.
>
> Pedro Domingos

“Now what?” you might think. The trading platform that allows one to retrieve historical data and streaming data is available. It allows one to place buy and sell orders and to check the account status. A number of different methods have been introduced in this book to derive algorithmic trading strategies by predicting the direction of market price movements. You may ask, “How, after all, can this all be put together to work in automated fashion?” This cannot be answered in any generality. However, this chapter addresses a number of topics that are important in this context. The chapter assumes that a single automated, algorithmic trading strategy is to be deployed. This simplifies, for example, aspects like capital and risk management.

The chapter covers the following topics. [“Capital Management”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_capital) discusses the _Kelly criterion_. Depending on the strategy characteristics and the trading capital available, the Kelly criterion helps with sizing the trades. To gain confidence in an algorithmic trading strategy, the strategy needs to be backtested thoroughly with regard to both performance and risk characteristics. [“ML-Based Trading Strategy”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_strat) backtests an example strategy based on a classification algorithm from machine learning (ML), as introduced in [“Trading Strategies”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch01.html#trading\_strategies). To deploy the algorithmic trading strategy for automated trading, it needs to be translated into an online algorithm that works with incoming streaming data in real time. [“Online Algorithm”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_online) covers the transformation of an _offline_ algorithm into an _online_ algorithm.

[“Infrastructure and Deployment”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_infra\_deploy) then sets out to make sure that the automated, algorithmic trading strategy runs robustly and reliably in the cloud. Not all topics of relevance can be covered in detail, but _cloud deployment_ seems to be the only viable option from an availability, performance, and security point of view in this context. [“Logging and Monitoring”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_logg\_monit) covers logging and monitoring. Logging is important in order to be able to analyze the history and certain events during the deployment of an automated trading strategy. Monitoring via socket communication, as introduced in [Chapter 7](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#realtime\_sockets), allows one to observe events remotely in real time. The chapter concludes with [“Visual Step-by-Step Overview”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#viz\_summary), which provides a visual summary of the core steps for the automated deployment of algorithmic trading strategies in the cloud.

## Capital Management

A central question in algorithmic trading is how much capital to deploy to a given algorithmic trading strategy given the total available capital. The answer to this question depends on the main goal one is trying to achieve by algorithmic trading. Most individuals and financial institutions will agree that the _maximization of long-term wealth_ is a good candidate objective. This is what Edward Thorp had in mind when he derived the _Kelly criterion_ to investing, as described in Rotando and Thorp (1992). Simply speaking, the Kelly criterion allows for an explicit calculation of the fraction of the available capital a trader should deploy to a strategy, given its statistical return characteristics.

### Kelly Criterion in Binomial Setting

The common way of introducing the theory of the Kelly criterion to investing is on the basis of a coin tossing game or, more generally, a binomial setting (only two outcomes are possible). This section follows that path. Assume a gambler is playing a coin tossing game against an infinitely rich bank or casino. Assume further that the probability for heads is some value � for which the following holds:

12<�<1

Probability for tails is defined by the following:

�=1-�<12

The gambler can place bets �>0 of arbitrary size, whereby the gambler wins the same amount if right and loses it all if wrong. Given the assumptions about the probabilities, the gambler would of course want to bet on heads.

Therefore, the expected value for this betting game � (that is, the random variable representing this game) in a one-shot setting is as follows:

𝐄(�)=�·�-�·�=(�-�)·�>0

A risk-neutral gambler with unlimited funds would like to bet as large an amount as possible since this would maximize the expected payoff. However, trading in financial markets is not a one-shot game in general. It is a repeated game. Therefore, assume that �� represents the amount that is bet on day � and that �0 represents the initial capital. The capital �1 at the end of day one depends on the betting success on that day and might be either �0+�1 or �0-�1. The expected value for a gamble that is repeated � times then is as follows:

𝐄(��)=�0+∑�=1�(�-�)·��

In classical economic theory, with risk-neutral, expected utility-maximizing agents, a gambler would try to maximize the preceding expression. It is easily seen that it is maximized by betting all available funds, ��=��-1, like in the one-shot scenario. However, this in turn implies that a single loss will wipe out all available funds and will lead to ruin (unless unlimited borrowing is possible). Therefore, this strategy does not lead to a maximization of long-term wealth.

While betting the maximum capital available might lead to sudden ruin, betting nothing at all avoids any kind of loss but does not benefit from the advantageous gamble either. This is where the Kelly criterion comes into play since it derives the _optimal fraction_ �\* of the available capital to bet per round of betting. Assume that �=ℎ+� where ℎ stands for the number of heads observed during � rounds of betting and where � stands for the number of tails. With these definitions, the available capital after � rounds is the following:

��=�0·(1+�)ℎ·(1-�)�

In such a context, long-term wealth maximization boils down to maximizing the average geometric growth rate per bet which is given as follows:

��=log���01/�=log�0·(1+�)ℎ·(1-�)��01/�=log(1+�)ℎ·(1-�)�1/�=ℎ�log(1+�)+��log(1-�)

The problem then formally is to maximize the _expected_ average rate of growth by choosing � optimally. With 𝐄(ℎ)=�·� and 𝐄(�)=�·�, one gets:

𝐄(��)=𝐄ℎ�log(1+�)+��log(1-�)=𝐄(�log(1+�)+�log(1-�))=�log(1+�)+�log(1-�)≡�(�)

One can now maximize the term by choosing the optimal fraction �\* according to the first order condition. The first derivative is given by the following:

�'(�)=�1+�-�1-�=�-��-�-��(1+�)(1-�)=�-�-�(1+�)(1-�)

From the first order condition, one gets the following:

�'(�)=!0⇒�\*=�-�

If one trusts this to be the maximum (and not the minimum), this result implies that it is optimal to invest a fraction �\*=�-� per round of betting. With, for example, �= 0.55, one has �\*= 0.55 - 0.45 = 0.1, or that the optimal fraction is 10%.

The following Python code formalizes these concepts and results through simulation. First, some imports and configurations:

```
In [1]: import math
        import time
        import numpy as np
        import pandas as pd
        import datetime as dt
        from pylab import plt, mpl

In [2]: np.random.seed(1000)
        plt.style.use('seaborn')
        mpl.rcParams['savefig.dpi'] = 300
        mpl.rcParams['font.family'] = 'serif'
```

The idea is to simulate, for example, 50 series with 100 coin tosses per series. The Python code for this is straightforward:

```
In [3]: p = 0.55  

In [4]: f = p - (1 - p)  

In [5]: f  
Out[5]: 0.10000000000000009

In [6]: I = 50  

In [7]: n = 100  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO1-1)

Fixes the probability for heads.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO1-2)

Calculates the optimal fraction according to the Kelly criterion.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO1-4)

The number of series to be simulated.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO1-5)

The number of trials per series.

The major part is the Python function `run_simulation()`, which achieves the simulation according to the preceding assumptions. [Figure 10-1](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_plot\_01) shows the simulation results:

```
In [8]: def run_simulation(f):
            c = np.zeros((n, I))  
            c[0] = 100  
            for i in range(I):  
                for t in range(1, n):  
                    o = np.random.binomial(1, p)  
                    if o > 0:  
                        c[t, i] = (1 + f) * c[t - 1, i]  
                    else:  
                        c[t, i] = (1 - f) * c[t - 1, i]  
            return c

In [9]: c_1 = run_simulation(f)  

In [10]: c_1.round(2)
Out[10]: array([[100.  , 100.  , 100.  , ..., 100.  , 100.  , 100.  ],
                [ 90.  , 110.  ,  90.  , ..., 110.  ,  90.  , 110.  ],
                [ 99.  , 121.  ,  99.  , ..., 121.  ,  81.  , 121.  ],
                ...,
                [226.35, 338.13, 413.27, ..., 123.97, 123.97, 123.97],
                [248.99, 371.94, 454.6 , ..., 136.37, 136.37, 136.37],
                [273.89, 409.14, 409.14, ..., 122.73, 150.01, 122.73]])

In [11]: plt.figure(figsize=(10, 6))
         plt.plot(c_1, 'b', lw=0.5)  
         plt.plot(c_1.mean(axis=1), 'r', lw=2.5);  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO2-1)

Instantiates an `ndarray` object to store the simulation results.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO2-2)

Initializes the starting capital with 100.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO2-3)

Outer loop for the series simulations.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO2-4)

Inner loop for the series itself.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO2-5)

Simulates the tossing of a coin.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO2-6)

If `1` or heads…

[![7](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/7.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO2-7)

…then add the win to the capital.

[![8](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/8.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO2-8)

If `0` or tails…

[![9](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/9.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO2-9)

…subtract the loss from the capital.

[![10](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/10.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO2-10)

This runs the simulation.

[![11](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/11.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO2-11)

Plots all 50 series.

[![12](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/12.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO2-12)

Plots the average over all 50 series.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1001.png" alt="pfat 1001" height="1421" width="2455"><figcaption></figcaption></figure>

**Figure 10-1. 50 simulated series with 100 trials each (red line = average)**

The following code repeats the simulation for different values of �. As shown in [Figure 10-2](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_plot\_02), a lower fraction leads to a lower growth rate on average. Higher values might lead both to a higher average capital at the end of the simulation (�=0.25) or lead to a much lower average capital (�=0.5]). In both cases where the fraction � is higher, the volatility increases considerably:

```
In [12]: c_2 = run_simulation(0.05)  

In [13]: c_3 = run_simulation(0.25)  

In [14]: c_4 = run_simulation(0.5)  

In [15]: plt.figure(figsize=(10, 6))
         plt.plot(c_1.mean(axis=1), 'r', label='$f^*=0.1$')
         plt.plot(c_2.mean(axis=1), 'b', label='$f=0.05$')
         plt.plot(c_3.mean(axis=1), 'y', label='$f=0.25$')
         plt.plot(c_4.mean(axis=1), 'm', label='$f=0.5$')
         plt.legend(loc=0);
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO3-1)

Simulation with �= 0.05.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO3-2)

Simulation with �= 0.25.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO3-3)

Simulation with �= 0.5.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1002.png" alt="pfat 1002" height="1421" width="2433"><figcaption></figcaption></figure>

**Figure 10-2. Average capital over time for different values of �**

### Kelly Criterion for Stocks and Indices

Assume now a stock market setting in which the relevant stock (index) can take on only two values after a period of one year from today, given its known value today. The setting is again binomial but this time a bit closer on the modeling side to stock market realities.[1](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#idm45785342245112) Specifically, assume the following holds true:

���=�+�=���=�-�=12

Here, 𝐄(��)=�>0 is the the expected return of the stock over one year, and �>0 is the standard deviation of returns (volatility). In a one-period setting, one gets the following for the available capital after one year (with �0 and � defined as before):

�(�)=�0·1+(1-�)·�+�·��

Here, � is the constant short rate earned on cash not invested in the stock. Maximizing the geometric growth rate means maximizing the term:

�(�)=𝐄log�(�)�0

Assume now that there are � relevant trading days in the year so that for each such trading day � the following holds true:

����=��+��=����=��-��=12

Note that volatility scales with the square root of the number of trading days. Under these assumptions, the daily values scale up to the yearly ones from before and one gets the following:

��(�)=�0·∏�=1�1+(1-�)·��+�·���

One now has to maximize the following quantity to achieve maximum long-term wealth when investing in the stock:

��(�)=𝐄log��(�)�0=𝐄∑�=1�log1+(1-�)·��+�·���=12∑�=1�log1+(1-�)·��+�·��+��+log1+(1-�)·��+�·��-��=�2log1+(1-�)·��+�·��2-�2�2�

Using a [Taylor series expansion](https://oreil.ly/xX4tA), one finally arrives at the following:

��(�)=�+(�-�)·�-�22·�2+𝒪1�

Or for infinitely many trading points in time (that is, for continuous trading), one arrives at the following:

�∞(�)=�+(�-�)·�-�22·�2

The optimal fraction �\* then is given through the first order condition by the following expression:

�\*=�-��2

This represents the expected excess return of the stock over the risk-free rate divided by the variance of the returns. This expression looks similar to the Sharpe ratio but is different.

A real-world example shall illustrate the application of the preceding formula and its role in leveraging equity deployed to trading strategies. The trading strategy under consideration is simply a _passive long position in the S\&P 500 index_. To this end, base data is quickly retrieved and required statistics are easily derived:

```
In [16]: raw = pd.read_csv('http://hilpisch.com/pyalgo_eikon_eod_data.csv',
                           index_col=0, parse_dates=True)

In [17]: symbol = '.SPX'

In [18]: data = pd.DataFrame(raw[symbol])

In [19]: data['return'] = np.log(data / data.shift(1))

In [20]: data.dropna(inplace=True)

In [21]: data.tail()
Out[21]:                .SPX    return
         Date
         2019-12-23  3224.01  0.000866
         2019-12-24  3223.38 -0.000195
         2019-12-27  3240.02  0.000034
         2019-12-30  3221.29 -0.005798
         2019-12-31  3230.78  0.002942
```

The statistical properties of the S\&P 500 index over the period covered suggest an optimal fraction of about 4.5 to be invested in the long position in the index. In other words, for every dollar available, 4.5 dollars shall be invested, implying a _leverage ratio_ of 4.5 in accordance with the optimal Kelly fraction or, in this case, the optimal Kelly _factor_.

Everything being equal, the Kelly criterion implies a higher leverage when the expected return is higher and the volatility (variance) is lower:

```
In [22]: mu = data['return'].mean() * 252  

In [23]: mu  
Out[23]: 0.09992181916534204

In [24]: sigma = data['return'].std() * 252 ** 0.5  

In [25]: sigma  
Out[25]: 0.14761569775486563

In [26]: r = 0.0  

In [27]: f = (mu - r) / sigma ** 2 

In [28]: f  
Out[28]: 4.585590244019818
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO4-1)

Calculates the annualized return.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO4-3)

Calculates the annualized volatility.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO4-5)

Sets the risk-free rate to 0 (for simplicity).

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO4-6)

Calculates the optimal Kelly fraction to be invested in the strategy.

The following Python code simulates the application of the Kelly criterion and the optimal leverage ratio. For simplicity and comparison reasons, the initial equity is set to 1 while the initially invested total capital is set to 1·�\*. Depending on the performance of the capital deployed to the strategy, the total capital itself is adjusted daily according to the available equity. After a loss, the capital is reduced; after a profit, the capital is increased. The evolution of the equity position compared to the index itself is shown in [Figure 10-3](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_plot\_03):

```
In [29]: equs = []

In [30]: def kelly_strategy(f):
             global equs
             equ = 'equity_{:.2f}'.format(f)
             equs.append(equ)
             cap = 'capital_{:.2f}'.format(f)
             data[equ] = 1  
             data[cap] = data[equ] * f  
             for i, t in enumerate(data.index[1:]):
                 t_1 = data.index[i]  
                 data.loc[t, cap] = data[cap].loc[t_1] * \
                                     math.exp(data['return'].loc[t])  
                 data.loc[t, equ] = data[cap].loc[t] - \
                                     data[cap].loc[t_1] + \
                                     data[equ].loc[t_1]  
                 data.loc[t, cap] = data[equ].loc[t] * f  

In [31]: kelly_strategy(f * 0.5)  

In [32]: kelly_strategy(f * 0.66)  

In [33]: kelly_strategy(f)  

In [34]: print(data[equs].tail())
                     equity_2.29  equity_3.03  equity_4.59
         Date
         2019-12-23     6.628865     9.585294    14.205748
         2019-12-24     6.625895     9.579626    14.193019
         2019-12-27     6.626410     9.580610    14.195229
         2019-12-30     6.538582     9.412991    13.818934
         2019-12-31     6.582748     9.496919    14.005618

In [35]: ax = data['return'].cumsum().apply(np.exp).plot(figsize=(10, 6))
         data[equs].plot(ax=ax, legend=True);
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO5-1)

Generates a new column for `equity` and sets the initial value to 1.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO5-2)

Generates a new column for `capital` and sets the initial value to 1·�\*.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO5-3)

Picks the right `DatetimeIndex` value for the previous values.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO5-4)

Calculates the new capital position given the return.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO5-5)

Adjusts the equity value according to the capital position performance.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO5-6)

Adjusts the capital position given the new equity position and the fixed leverage ratio.

[![7](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/7.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO5-7)

Simulates the Kelly criterion based strategy for half of �…

[![8](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/8.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO5-8)

…for two thirds of �…

[![9](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/9.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO5-9)

…and � itself.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1003.png" alt="pfat 1003" height="1395" width="2402"><figcaption></figcaption></figure>

**Figure 10-3. Gross performance of S\&P 500 compared to equity position given different values of �**

As [Figure 10-3](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_plot\_03) illustrates, applying the optimal Kelly leverage leads to a rather erratic evolution of the equity position (high volatility), which is intuitively plausible, given the leverage ratio of 4.59. One would expect the volatility of the equity position to increase with increasing leverage. Therefore, practitioners often do not use “full Kelly” (4.6), but rather “half Kelly” (2.3). In the current example, this is reduced to:

12•�\*≈2.3

Against this background, [Figure 10-3](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_plot\_03) also shows the evolution of the equity position for values lower than “full Kelly.” The risk indeed reduces with lower values of latexmath:\[$f$].

## ML-Based Trading Strategy

[Chapter 8](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#trading\_oanda) introduces the Oanda trading platform, its RESTful API and the Python wrapper package `tpqoa`. This section combines an ML-based approach for predicting the direction of market price movements with historical data from the Oanda v20 RESTful API to backtest an algorithmic trading strategy for the EUR/USD currency pair. It uses vectorized backtesting, taking into account this time the bid-ask spread as proportional transactions costs. It also adds, compared to the plain vectorized backtesting approach introduced in [Chapter 4](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch04.html#vectorized\_backtesting), a more in-depth analysis of the risk characteristics of the trading strategy tested.

### Vectorized Backtesting

The backtest is based on intraday data, more specifically on bars of 10 minutes in length. The following code connects to the Oanda v20 API and retrieves 10-minute bar data for one week. [Figure 10-4](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_plot\_04) visualizes the mid close prices over the period for which data is retrieved:

```
In [36]: import tpqoa

In [37]: %time api = tpqoa.tpqoa('../pyalgo.cfg')  
         CPU times: user 893 µs, sys: 198 µs, total: 1.09 ms
         Wall time: 1.04 ms

In [38]: instrument = 'EUR_USD'  

In [39]: raw = api.get_history(instrument,
                                start='2020-06-08',
                                end='2020-06-13',
                                granularity='M10',
                                price='M')  

In [40]: raw.tail()
Out[40]:                            o        h        l        c  volume  complete
         time
         2020-06-12 20:10:00  1.12572  1.12593  1.12532  1.12568     221      True
         2020-06-12 20:20:00  1.12569  1.12578  1.12532  1.12558     163      True
         2020-06-12 20:30:00  1.12560  1.12573  1.12534  1.12543     192      True
         2020-06-12 20:40:00  1.12544  1.12594  1.12528  1.12542     219      True
         2020-06-12 20:50:00  1.12544  1.12624  1.12541  1.12554     296      True

In [41]: raw.info()
         <class 'pandas.core.frame.DataFrame'>
         DatetimeIndex: 701 entries, 2020-06-08 00:00:00 to 2020-06-12 20:50:00
         Data columns (total 6 columns):
          #   Column    Non-Null Count  Dtype
         ---  ------    --------------  -----
          0   o         701 non-null    float64
          1   h         701 non-null    float64
          2   l         701 non-null    float64
          3   c         701 non-null    float64
          4   volume    701 non-null    int64
          5   complete  701 non-null    bool
         dtypes: bool(1), float64(4), int64(1)
         memory usage: 33.5 KB

In [42]: spread = 0.00012  

In [43]: mean = raw['c'].mean()  

In [44]: ptc = spread / mean  
         ptc  
Out[44]: 0.00010599557439495706

In [45]: raw['c'].plot(figsize=(10, 6), legend=True);
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO6-1)

Connects to the API and retrieves the data.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO6-4)

Specifies the average bid-ask spread.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO6-5)

Calculates the mean closing price for the data set.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO6-6)

Calculates the average proportional transactions costs given the average spread and the average mid closing price.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1004.png" alt="pfat 1004" height="1461" width="2495"><figcaption></figcaption></figure>

**Figure 10-4. EUR/USD exchange rate (10-minute bars)**

The ML-based strategy uses a number of time series features, such as the log return and the minimum and the maximum of the closing price. In addition, the features data is lagged. In other words, the ML algorithm shall learn from historical patterns as embodied by the lagged features data:

```
In [46]: data = pd.DataFrame(raw['c'])

In [47]: data.columns = [instrument,]

In [48]: window = 20  
         data['return'] = np.log(data / data.shift(1))  
         data['vol'] = data['return'].rolling(window).std()  
         data['mom'] = np.sign(data['return'].rolling(window).mean())  
         data['sma'] = data[instrument].rolling(window).mean()  
         data['min'] = data[instrument].rolling(window).min()  
         data['max'] = data[instrument].rolling(window).max()  

In [49]: data.dropna(inplace=True)

In [50]: lags = 6  

In [51]: features = ['return', 'vol', 'mom', 'sma', 'min', 'max']  

In [52]: cols = []
         for f in features:
             for lag in range(1, lags + 1):
                 col = f'{f}_lag_{lag}'
                 data[col] = data[f].shift(lag)  
                 cols.append(col)

In [53]: data.dropna(inplace=True)

In [54]: data['direction'] = np.where(data['return'] > 0, 1, -1)  

In [55]: data[cols].iloc[:lags, :lags]  
Out[55]:
                          return_lag_1  return_lag_2  return_lag_3  return_lag_4 \
     time
     2020-06-08 04:20:00      0.000097      0.000018     -0.000452      0.000035
     2020-06-08 04:30:00     -0.000115      0.000097      0.000018     -0.000452
     2020-06-08 04:40:00      0.000027     -0.000115      0.000097      0.000018
     2020-06-08 04:50:00     -0.000142      0.000027     -0.000115      0.000097
     2020-06-08 05:00:00      0.000035     -0.000142      0.000027     -0.000115
     2020-06-08 05:10:00     -0.000159      0.000035     -0.000142      0.000027

                          return_lag_5  return_lag_6
     time
     2020-06-08 04:20:00      0.000000      0.000009
     2020-06-08 04:30:00      0.000035      0.000000
     2020-06-08 04:40:00     -0.000452      0.000035
     2020-06-08 04:50:00      0.000018     -0.000452
     2020-06-08 05:00:00      0.000097      0.000018
     2020-06-08 05:10:00     -0.000115      0.000097
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO7-1)

Specifies the window length for certain features.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO7-2)

Calculates the log returns from the closing prices.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO7-3)

Calculates the rolling volatility.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO7-4)

Derives the time series momentum as the mean of the recent log returns.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO7-5)

Calculates the simple moving average.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO7-6)

Calculates the rolling maximum value.

[![7](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/7.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO7-7)

Calculates the rolling minimum value.

[![8](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/8.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO7-8)

Adds the lagged features data to the `DataFrame` object.

[![9](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/9.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO7-11)

Defines the labels data as the market direction (`+1` or _up_ and `-1` or _down_).

[![10](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/10.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO7-12)

Shows a small sub-set from the resulting lagged features data.

Given the features and label data, different supervised learning algorithms could now be applied. In what follows, a so-called _AdaBoost algorithm_ for classification is used from the `scikit-learn` ML package (see [`AdaBoostClassifier`](https://oreil.ly/WIANy)). The idea of boosting in the context of classification is to use an _ensemble_ of base classifiers to arrive at a superior predictor that is supposed to be less prone to overfitting (see [“Data Snooping and Overfitting”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch04.html#data\_snooping)). As the base classifier, a _decision tree classification algorithm_ from `scikit-learn` is used (see [`DecisionTreeClassifier`](https://oreil.ly/wb-wh)).

The code trains and tests the algorithmic trading strategy based on a sequential train-test split. The accuracy scores of the model for the training and test data are both significantly above 50%. Instead of accuracy scores, one would also speak in a financial trading context of the _hit ratio_ of the trading strategy (that is, the number of winning trades compared to all trades). Since the hit ratio is significantly greater than 50%, this might indicate—in the context of the Kelly criterion—a statistical edge compared to a random walk setting:

```
In [56]: from sklearn.metrics import accuracy_score
         from sklearn.tree import DecisionTreeClassifier
         from sklearn.ensemble import AdaBoostClassifier

In [57]: n_estimators=15  
         random_state=100  
         max_depth=2  
         min_samples_leaf=15  
         subsample=0.33  

In [58]: dtc = DecisionTreeClassifier(random_state=random_state,
                                      max_depth=max_depth,
                                      min_samples_leaf=min_samples_leaf)  

In [59]: model = AdaBoostClassifier(base_estimator=dtc,
                                   n_estimators=n_estimators,
                                   random_state=random_state)  

In [60]: split = int(len(data) * 0.7)

In [61]: train = data.iloc[:split].copy()

In [62]: mu, std = train.mean(), train.std()  

In [63]: train_ = (train - mu) / std  

In [64]: model.fit(train_[cols], train['direction'])  
Out[64]: AdaBoostClassifier(algorithm='SAMME.R',
         base_estimator=DecisionTreeClassifier(ccp_alpha=0.0,
         class_weight=None,
         criterion='gini',
         max_depth=2,
         max_features=None,
         max_leaf_nodes=None,
         min_impurity_decrease=0.0,
         min_impurity_split=None,
         min_samples_leaf=15,
         min_samples_split=2,
         min_weight_fraction_leaf=0.0,
         presort='deprecated',
         random_state=100,
         splitter='best'),
         learning_rate=1.0, n_estimators=15, random_state=100)

In [65]: accuracy_score(train['direction'], model.predict(train_[cols]))  
Out[65]: 0.8050847457627118

In [66]: test = data.iloc[split:].copy()  

In [67]: test_ = (test - mu) / std  

In [68]: test['position'] = model.predict(test_[cols])  

In [69]: accuracy_score(test['direction'], test['position'])  
Out[69]: 0.5665024630541872
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO8-1)

Specifies major parameters for the ML algorithm (see the references for the model classes provided previously).

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO8-6)

Instantiates the base classification algorithm (decision tree).

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO8-7)

Instantiates the AdaBoost classification algorithm.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO8-8)

Applies Gaussian normalization to the _training_ features data set.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO8-10)

Fits the model based on the training data set.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO8-11)

Shows the accuracy of the predictions from the trained model _in-sample_ (training data set).

[![7](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/7.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO8-12)

Applies Gaussian normalization to the _testing_ features data set (using the parameters from the training features data set).

[![8](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/8.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO8-14)

Generates the predictions for the test data set.

[![9](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/9.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO8-15)

Shows the accuracy of the predictions from the trained model _out-of-sample_ (test data set).

It is well known that the hit ratio is only one side of the coin of success in financial trading. The other side comprises, among other things, getting the important trades right, as well as the transactions costs implied by the trading strategy.[2](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#idm45785339950712) To this end, only a formal vectorized backtesting approach allows one to judge the quality of the trading strategy. The following code takes into account the proportional transaction costs based on the average bid-ask spread. [Figure 10-5](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_plot\_05) compares the performance of the algorithmic trading strategy (without and with proportional transaction costs) to the performance of the passive benchmark investment:

```
In [70]: test['strategy'] = test['position'] * test['return']  

In [71]: sum(test['position'].diff() != 0)  
Out[71]: 77

In [72]: test['strategy_tc'] = np.where(test['position'].diff() != 0,
                                        test['strategy'] - ptc,  
                                        test['strategy'])

In [73]: test[['return', 'strategy', 'strategy_tc']].sum(
                 ).apply(np.exp)
Out[73]: return         0.990182
         strategy       1.015827
         strategy_tc    1.007570
         dtype: float64

In [74]: test[['return', 'strategy', 'strategy_tc']].cumsum(
                 ).apply(np.exp).plot(figsize=(10, 6));
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO9-1)

Derives the log returns for the ML-based algorithmic trading strategy.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO9-2)

Calculates the number of trades implied by the trading strategy based on changes in the position.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO9-3)

Whenever a trade takes place, the proportional transaction costs are subtracted from the strategy’s log return on that day.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1005.png" alt="pfat 1005" height="1573" width="2470"><figcaption></figcaption></figure>

**Figure 10-5. Gross performance of EUR/USD exchange rate and algorithmic trading strategy (before and after transaction costs)**

Vectorized backtesting has its limits with regard to how close to market realities strategies can be tested. For example, it does not allow one to include fixed transaction costs per trade directly. One could, as an approximation, take a multiple of the average proportional transaction costs (based on average position sizes) to account indirectly for fixed transactions costs. However, this would not be precise in general. If a higher degree of precision is required, other approaches, such as _event-based backtesting_ (see [Chapter 6](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch06.html#event\_based\_backtesting)) with explicit loops over every bar of the price data, need to be applied.

### Optimal Leverage

Equipped with the trading strategy’s log returns data, the mean and variance values can be calculated in order to derive the optimal leverage according to the Kelly criterion. The code that follows scales the numbers to annualized values, although this does not change the optimal leverage values according to the Kelly criterion since the mean return and the variance scale with the same factor:

```
In [75]: mean = test[['return', 'strategy_tc']].mean() * len(data) * 52  
         mean
Out[75]: return        -1.705965
         strategy_tc    1.304023
         dtype: float64

In [76]: var = test[['return', 'strategy_tc']].var() * len(data) * 52  
         var
Out[76]: return         0.011306
         strategy_tc    0.011370
         dtype: float64

In [77]: vol = var ** 0.5  
         vol
Out[77]: return         0.106332
         strategy_tc    0.106631
         dtype: float64

In [78]: mean / var  
Out[78]: return        -150.884961
         strategy_tc    114.687875
         dtype: float64

In [79]: mean / var * 0.5  
Out[79]: return        -75.442481
         strategy_tc    57.343938
         dtype: float64
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO10-1)

Annualized mean returns.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO10-2)

Annualized variances.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO10-3)

Annualized volatilities.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO10-4)

Optimal leverage according to the Kelly criterion (“full Kelly”).

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO10-5)

Optimal leverage according to the Kelly criterion (“half Kelly”).

Using the “half Kelly” criterion, the optimal leverage for the trading strategy is above 50. With a number of brokers, such as Oanda, and certain financial instruments, such as foreign exchange pairs and contracts for difference (CFDs), such leverage ratios are feasible, even for retail traders. [Figure 10-6](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_plot\_06) shows, in comparison, the performance of the trading strategy with transaction costs for different leverage values:

```
In [80]: to_plot = ['return', 'strategy_tc']

In [81]: for lev in [10, 20, 30, 40, 50]:
             label = 'lstrategy_tc_%d' % lev
             test[label] = test['strategy_tc'] * lev  
             to_plot.append(label)

In [82]: test[to_plot].cumsum().apply(np.exp).plot(figsize=(10, 6));
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO11-1)

Scales the strategy returns for different leverage values.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1006.png" alt="pfat 1006" height="1573" width="2417"><figcaption></figcaption></figure>

**Figure 10-6. Gross performance of the algorithmic trading strategy for different leverage values**

Leverage increases risks associated with trading strategies significantly. Traders should read the risk disclaimers and regulations carefully. A positive backtesting performance is also no guarantee whatsoever for future performances. All results shown are illustrative only and are meant to demonstrate the application of programming and analytics approaches. In some jurisdictions, such as in Germany, leverage ratios are capped for retail traders based on different groups of financial instruments.

### Risk Analysis

Since leverage increases the risk associated with a certain trading strategy considerably, a more in-depth risk analysis seems in order. The risk analysis that follows assumes a leverage ratio of 30. First, the maximum drawdown and the longest drawdown period shall be calculated. _Maximum drawdown_ is the largest loss (dip) after a recent high. Accordingly, the _longest drawdown period_ is the longest period that the trading strategy needs to get back to a recent high. The analysis assumes that the initial equity position is 3,333 EUR leading to an initial position size of 100,000 EUR for a leverage ratio of 30. It also assumes that there are no adjustments with regard to the equity over time, no matter what the performance is:

```
In [83]: equity = 3333  

In [84]: risk = pd.DataFrame(test['lstrategy_tc_30'])  

In [85]: risk['equity'] = risk['lstrategy_tc_30'].cumsum(
                                   ).apply(np.exp) * equity  

In [86]: risk['cummax'] = risk['equity'].cummax()  

In [87]: risk['drawdown'] = risk['cummax'] - risk['equity']  

In [88]: risk['drawdown'].max()  
Out[88]: 511.38321383258017

In [89]: t_max = risk['drawdown'].idxmax()  
         t_max  
Out[89]: Timestamp('2020-06-12 10:30:00')
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO12-1)

The initial equity.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO12-2)

The relevant log returns time series…

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO12-3)

…scaled by the initial equity.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO12-4)

The cumulative maximum values over time.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO12-5)

The drawdown values over time.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO12-6)

The maximum drawdown value.

[![7](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/7.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO12-7)

The point in time when it happens.

Technically, a new high is characterized by a drawdown value of 0. The drawdown period is the time between two such highs. [Figure 10-7](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_plot\_07) visualizes both the maximum drawdown and the drawdown periods:

```
In [90]: temp = risk['drawdown'][risk['drawdown'] == 0]  

In [91]: periods = (temp.index[1:].to_pydatetime() -
                    temp.index[:-1].to_pydatetime())  

In [92]: periods[20:30]  
Out[92]: array([datetime.timedelta(seconds=600),
          datetime.timedelta(seconds=1200),
         datetime.timedelta(seconds=1200), datetime.timedelta(seconds=1200)],
               dtype=object)

In [93]: t_per = periods.max()  

In [94]: t_per  
Out[94]: datetime.timedelta(seconds=26400)

In [95]: t_per.seconds / 60 / 60  
Out[95]: 7.333333333333333

In [96]: risk[['equity', 'cummax']].plot(figsize=(10, 6))
         plt.axvline(t_max, c='r', alpha=0.5);
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO13-1)

Identifies highs for which the drawdown must be 0.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO13-2)

Calculates the `timedelta` values between all highs.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO13-4)

The longest drawdown period in _seconds_…

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO13-6)

…transformed to _hours_.

Another important risk measure is _value-at-risk_ (VaR). It is quoted as a currency amount and represents the maximum loss to be expected given both a certain time horizon and a confidence level.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1007.png" alt="pfat 1007" height="1573" width="2459"><figcaption></figcaption></figure>

**Figure 10-7. Maximum drawdown (vertical line) and drawdown periods (horizontal lines)**

The following code derives VaR values based on the log returns of the equity position for the leveraged trading strategy over time for different confidence levels. The time interval is fixed to the bar length of ten minutes:

```
In [97]: import scipy.stats as scs

In [98]: percs = [0.01, 0.1, 1., 2.5, 5.0, 10.0]  

In [99]: risk['return'] = np.log(risk['equity'] /
                                  risk['equity'].shift(1))

In [100]: VaR = scs.scoreatpercentile(equity * risk['return'], percs)  

In [101]: def print_var():
              print('{}    {}'.format('Confidence Level', 'Value-at-Risk'))
              print(33 * '-')
              for pair in zip(percs, VaR):
                  print('{:16.2f} {:16.3f}'.format(100 - pair[0], -pair[1]))  

In [102]: print_var()  
          Confidence Level    Value-at-Risk
          ---------------------------------
                     99.99          162.570
                     99.90          161.348
                     99.00          132.382
                     97.50          122.913
                     95.00          100.950
                     90.00           62.622
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO14-1)

Defines the percentile values to be used.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO14-2)

Calculates the VaR values given the percentile values.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO14-3)

Translates the percentile values into confidence levels and the VaR values (negative values) to positive values for printing.

Finally, the following code calculates the VaR values for a time horizon of _one hour_ by resampling the original `DataFrame` object. In effect, the VaR values are increased for all confidence levels:

```
In [103]: hourly = risk.resample('1H', label='right').last()  

In [104]: hourly['return'] = np.log(hourly['equity'] /
                                   hourly['equity'].shift(1))

In [105]: VaR = scs.scoreatpercentile(equity * hourly['return'], percs)  

In [106]: print_var()
          Confidence Level    Value-at-Risk
          ---------------------------------
                     99.99          252.460
                     99.90          251.744
                     99.00          244.593
                     97.50          232.674
                     95.00          125.498
                     90.00           61.701
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO15-1)

Resamples the data from 10-minute to 1-hour bars.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO15-2)

Calculates the VaR values given the percentile values.

### Persisting the Model Object

Once the algorithmic trading strategy is accepted based on the backtesting, leveraging, and risk analysis results, the model object and other relevant algorithm components might be persisted for later use in deployment. It embodies now the ML-based trading strategy or the trading algorithm.

```
In [107]: import pickle

In [108]: algorithm = {'model': model, 'mu': mu, 'std': std}

In [109]: pickle.dump(algorithm, open('algorithm.pkl', 'wb'))
```

## Online Algorithm

The trading algorithm tested so far is an _offline algorithm_. Such algorithms use a complete data set to solve a problem at hand. The problem has been to train an AdaBoost classification algorithm based on a decision tree as the base classifier, a number of different time series features, and directional label data. In practice, when deploying the trading algorithm in financial markets, it must consume data piece by piece as it arrives to predict the direction of the market movement for the next time interval (bar). This section makes use of the persisted model object from the previous section and embeds it into a streaming data context.

The code that transforms the _offline_ trading algorithm into an _online_ trading algorithm mainly addresses the following issues:

Tick data

Tick data arrives in real time and is to be processed in real time, such as to be collected in a `DataFrame` object.

Resampling

The tick data is to be resampled to the appropriate bar length given the trading algorithm. For illustration, a shorter bar length is used for resampling than for the training and backtesting.

Prediction

The trading algorithm generates a prediction for the direction of the market movement over the relevant time interval that by nature lies in the future.

Orders

Given the current position and the prediction (“signal”) generated by the algorithm, an order is placed or the position is kept unchanged.

[Chapter 8](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#trading\_oanda), and in particular [“Working with Streaming Data”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_streaming), shows how to retrieve tick data from the Oanda API in real time. The basic approach is to redefine the `.on_success()` method of the `tpqoa.tpqoa` class to implement the trading logic.

First, the persisted trading algorithm is loaded; it represents the trading logic to be followed. It consists of the trained model itself and the parameters for the normalization of the features data, which are integral parts of the algorithm:

```
In [110]: algorithm = pickle.load(open('algorithm.pkl', 'rb'))

In [111]: algorithm['model']
Out[111]: AdaBoostClassifier(algorithm='SAMME.R',
          base_estimator=DecisionTreeClassifier(ccp_alpha=0.0,
          class_weight=None,
          criterion='gini',
          max_depth=2,
          max_features=None,
          max_leaf_nodes=None,
          min_impurity_decrease=0.0,
          min_impurity_split=None,
          min_samples_leaf=15,
          min_samples_split=2,
          min_weight_fraction_leaf=0.0,
          presort='deprecated',
          random_state=100,
          splitter='best'),
          learning_rate=1.0, n_estimators=15, random_state=100)
```

In the following code, the new class `MLTrader`, which inherits from `tpqoa.tpqoa` and which, via the `.on_success()` and additional helper methods, transforms the trading algorithm into a real-time context. It is the transformation of the _offline algorithm_ to a so-called _online algorithm_:

```
In [112]: class MLTrader(tpqoa.tpqoa):
              def __init__(self, config_file, algorithm):
                  super(MLTrader, self).__init__(config_file)
                  self.model = algorithm['model']  
                  self.mu = algorithm['mu']  
                  self.std = algorithm['std']  
                  self.units = 100000  
                  self.position = 0  
                  self.bar = '5s'  
                  self.window = 2  
                  self.lags = 6  
                  self.min_length = self.lags + self.window + 1
                  self.features = ['return', 'sma', 'min', 'max', 'vol', 'mom']
                  self.raw_data = pd.DataFrame()
              def prepare_features(self):  
                  self.data['return'] = np.log(self.data['mid'] /
                                               self.data['mid'].shift(1))
                  self.data['sma'] = self.data['mid'].rolling(self.window).mean()
                  self.data['min'] = self.data['mid'].rolling(self.window).min()
                  self.data['mom'] = np.sign(
                      self.data['return'].rolling(self.window).mean())
                  self.data['max'] = self.data['mid'].rolling(self.window).max()
                  self.data['vol'] = self.data['return'].rolling(
                      self.window).std()
                  self.data.dropna(inplace=True)
                  self.data[self.features] -= self.mu
                  self.data[self.features] /= self.std
                  self.cols = []
                  for f in self.features:
                      for lag in range(1, self.lags + 1):
                          col = f'{f}_lag_{lag}'
                          self.data[col] = self.data[f].shift(lag)
                          self.cols.append(col)
              def on_success(self, time, bid, ask):  
                  df = pd.DataFrame({'bid': float(bid), 'ask': float(ask)},
                                   index=[pd.Timestamp(time).tz_localize(None)])
                  self.raw_data = self.raw_data.append(df)
                  self.data = self.raw_data.resample(self.bar,
                                          label='right').last().ffill()
                  self.data = self.data.iloc[:-1]
                  if len(self.data) > self.min_length:
                      self.min_length +=1
                      self.data['mid'] = (self.data['bid'] +
                                          self.data['ask']) / 2
                      self.prepare_features()
                      features = self.data[
                          self.cols].iloc[-1].values.reshape(1, -1)
                      signal = self.model.predict(features)[0]
                      print(f'NEW SIGNAL: {signal}', end='\r')
                      if self.position in [0, -1] and signal == 1:  
                          print('*** GOING LONG ***')
                          self.create_order(self.stream_instrument,
                                      units=(1 - self.position) * self.units)
                          self.position = 1
                      elif self.position in [0, 1] and signal == -1:  
                          print('*** GOING SHORT ***')
                          self.create_order(self.stream_instrument,
                                      units=-(1 + self.position) * self.units)
                          self.position = -1
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO16-1)

The trained AdaBoost model object and the normalization parameters.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO16-4)

The number of units traded.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO16-5)

The initial, neutral position.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO16-6)

The bar length on which the algorithm is implemented.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO16-7)

The length of the window for selected features.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO16-8)

The number of lags (must be in line with algorithm training).

[![7](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/7.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO16-9)

The method that generates the lagged features data.

[![8](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/8.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO16-10)

The redefined method that embodies the trading logic.

[![9](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/9.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO16-11)

Check for a long signal and long trade.

[![10](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/10.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO16-12)

Check for a short signal and short trade.

With the new class `MLTrader`, automated trading is made simple. A few lines of code are enough in an interactive context. The parameters are set such that the first order is placed after a short while. In reality, however, all parameters must, of course, be in line with original ones from the research and backtesting phase. They could, for example, also be persisted on disk and be read with the algorithm:

```
In [113]: mlt = MLTrader('../pyalgo.cfg', algorithm)  

In [114]: mlt.stream_data(instrument, stop=500)  
          print('*** CLOSING OUT ***')
          mlt.create_order(mlt.stream_instrument,
                            units=-mlt.position * mlt.units)  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO17-1)

Instantiates the trading object.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO17-2)

Starts the streaming, data processing, and trading.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#co\_automating\_trading\_operations\_CO17-3)

Closes out the final open position.

The preceding code generates an output similar to the following:

```
          *** GOING LONG ***


          {'id': '1735', 'time': '2020-08-19T14:46:15.552233563Z', 'userID':
           13834683, 'accountID': '101-004-13834683-001', 'batchID': '1734',
           'requestID': '42730658849646182', 'type': 'ORDER_FILL', 'orderID':
           '1734', 'instrument': 'EUR_USD', 'units': '100000.0',
           'gainQuoteHomeConversionFactor': '0.835983419025',
           'lossQuoteHomeConversionFactor': '0.844385262432', 'price': 1.1903,
           'fullVWAP': 1.1903, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':
           1.19013, 'liquidity': '10000000'}], 'asks': [{'price': 1.1903,
           'liquidity': '10000000'}], 'closeoutBid': 1.19013, 'closeoutAsk':
           1.1903}, 'reason': 'MARKET_ORDER', 'pl': '0.0', 'financing': '0.0',
           'commission': '0.0', 'guaranteedExecutionFee': '0.0',
           'accountBalance': '98507.7425', 'tradeOpened': {'tradeID': '1735',
           'units': '100000.0', 'price': 1.1903, 'guaranteedExecutionFee': '0.0',
           'halfSpreadCost': '7.1416', 'initialMarginRequired': '3330.0'},
           'halfSpreadCost': '7.1416'}

          *** GOING SHORT ***


          {'id': '1737', 'time': '2020-08-19T14:48:10.510726213Z', 'userID':
           13834683, 'accountID': '101-004-13834683-001', 'batchID': '1736',
           'requestID': '42730659332312267', 'type': 'ORDER_FILL', 'orderID':
           '1736', 'instrument': 'EUR_USD', 'units': '-200000.0',
           'gainQuoteHomeConversionFactor': '0.835885095595',
           'lossQuoteHomeConversionFactor': '0.844285950827', 'price': 1.19029,
           'fullVWAP': 1.19029, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':
           1.19029, 'liquidity': '10000000'}], 'asks': [{'price': 1.19042,
           'liquidity': '10000000'}], 'closeoutBid': 1.19029, 'closeoutAsk':
           1.19042}, 'reason': 'MARKET_ORDER', 'pl': '-0.8443', 'financing':
           '0.0', 'commission': '0.0', 'guaranteedExecutionFee': '0.0',
           'accountBalance': '98506.8982', 'tradeOpened': {'tradeID': '1737',
           'units': '-100000.0', 'price': 1.19029, 'guaranteedExecutionFee':
           '0.0', 'halfSpreadCost': '5.4606', 'initialMarginRequired': '3330.0'},
           'tradesClosed': [{'tradeID': '1735', 'units': '-100000.0', 'price':
           1.19029, 'realizedPL': '-0.8443', 'financing': '0.0',
           'guaranteedExecutionFee': '0.0', 'halfSpreadCost': '5.4606'}],
           'halfSpreadCost': '10.9212'}

          *** GOING LONG ***


          {'id': '1739', 'time': '2020-08-19T14:48:15.529680632Z', 'userID':
           13834683, 'accountID': '101-004-13834683-001', 'batchID': '1738',
           'requestID': '42730659353297789', 'type': 'ORDER_FILL', 'orderID':
           '1738', 'instrument': 'EUR_USD', 'units': '200000.0',
           'gainQuoteHomeConversionFactor': '0.835835944263',
           'lossQuoteHomeConversionFactor': '0.844236305512', 'price': 1.1905,
           'fullVWAP': 1.1905, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':
           1.19035, 'liquidity': '10000000'}], 'asks': [{'price': 1.1905,
           'liquidity': '10000000'}], 'closeoutBid': 1.19035, 'closeoutAsk':
           1.1905}, 'reason': 'MARKET_ORDER', 'pl': '-17.729', 'financing':
           '0.0', 'commission': '0.0', 'guaranteedExecutionFee': '0.0',
           'accountBalance': '98489.1692', 'tradeOpened': {'tradeID': '1739',
           'units': '100000.0', 'price': 1.1905, 'guaranteedExecutionFee': '0.0',
           'halfSpreadCost': '6.3003', 'initialMarginRequired': '3330.0'},
           'tradesClosed': [{'tradeID': '1737', 'units': '100000.0', 'price':
           1.1905, 'realizedPL': '-17.729', 'financing': '0.0',
           'guaranteedExecutionFee': '0.0', 'halfSpreadCost': '6.3003'}],
           'halfSpreadCost': '12.6006'}

          *** CLOSING OUT ***


          {'id': '1741', 'time': '2020-08-19T14:49:11.976885485Z', 'userID':
           13834683, 'accountID': '101-004-13834683-001', 'batchID': '1740',
           'requestID': '42730659588338204', 'type': 'ORDER_FILL', 'orderID':
           '1740', 'instrument': 'EUR_USD', 'units': '-100000.0',
           'gainQuoteHomeConversionFactor': '0.835730636848',
           'lossQuoteHomeConversionFactor': '0.844129939731', 'price': 1.19051,
           'fullVWAP': 1.19051, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':
           1.19051, 'liquidity': '10000000'}], 'asks': [{'price': 1.19064,
           'liquidity': '10000000'}], 'closeoutBid': 1.19051, 'closeoutAsk':
           1.19064}, 'reason': 'MARKET_ORDER', 'pl': '0.8357', 'financing':
           '0.0', 'commission': '0.0', 'guaranteedExecutionFee': '0.0',
           'accountBalance': '98490.0049', 'tradesClosed': [{'tradeID': '1739',
           'units': '-100000.0', 'price': 1.19051, 'realizedPL': '0.8357',
           'financing': '0.0', 'guaranteedExecutionFee': '0.0', 'halfSpreadCost':
           '5.4595'}], 'halfSpreadCost': '5.4595'}
```

## Infrastructure and Deployment

Deploying an automated algorithmic trading strategy with real funds requires an appropriate infrastructure. Among other things, the infrastructure should satisfy the following:

Reliability

The infrastructure on which to deploy an algorithmic trading strategy should allow for high availability (for example, 99.9% or higher) and should otherwise take care of reliability (automatic backups, redundancy of drives and web connections, and so on).

Performance

Depending on the amount of data being processed and the computational demand the algorithms generate, the infrastructure must have enough CPU cores, working memory (RAM), and storage (SSD). In addition, the web connections should be fast enough.

Security

The operating system and the applications that run on it should be protected by strong passwords, as well as SSL encryption and hard drive encryption. The hardware should be protected from fire, water, and unauthorized physical access.

Basically, these requirements can only be fulfilled by renting an appropriate infrastructure from a professional data center or a cloud provider. Own investments in the physical infrastructure to satisfy the aforementioned requirements can in general only be justified by the bigger, or even the biggest, players in the financial markets.

From a development and testing point of view, even the smallest Droplet (cloud instance) from DigitalOcean ([_http://digitalocean.com_](http://digitalocean.com/)) is enough to get started. At the time of writing, such a Droplet costs 5 USD per month and is billed by the hour, created within minutes, and destroyed within seconds.[3](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#idm45785334066856)

How to set up a Droplet with DigitalOcean is explained in detail in [Chapter 2](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch02.html#python\_environment) (specifically in [“Using Cloud Instances”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch02.html#cloud\_instance)), with Bash scripts that can be adjusted to reflect individual requirements regarding Python packages, for example.

Although the development and testing of automated algorithmic trading strategies is possible from a local computer (desktop, notebook, or similar), it is not appropriate for the deployment of automated strategies trading real money. A simple loss of the web connection or a brief power outage might bring down the whole algorithm, leaving, for example, unintended open positions in the portfolio. As another example, it would cause one to miss out on real-time tick data and end up with corrupted data sets, potentially leading to wrong signals and unintended trades and positions.

## Logging and Monitoring

Assume now that the automated algorithmic trading strategy is to be deployed on a remote server (virtual cloud instance or dedicated server). Further assume that all required Python packages have been installed (see [“Using Cloud Instances”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch02.html#cloud\_instance)) and that, for instance, `Jupyter Lab` is running securely (see [Running a notebook server](https://oreil.ly/cnBHE)). What else needs to be considered from the algorithmic traders’ point of view if they do not want to sit all day in front of the screen being logged in to the server?

This section addresses two important topics in this regard: _logging_ and _real-time monitoring_. Logging persists information and events on disk for later inspection. It is standard practice in software application development and deployment. However, here the focus might be put instead on the financial side, logging important financial data and event information for later inspection and analysis. The same holds true for real-time monitoring making use of socket communication. Via sockets, a constant real-time stream of important financial aspects can be created that can then be retrieved and processed on a local computer, even if the deployment happens in the cloud.

[“Automated Trading Strategy”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_script) presents a Python script implementing all these aspects and making use of the code from [“Online Algorithm”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_online). The script brings the code in a shape that allows, for example, the _deployment_ of the algorithmic trading strategy—sbased on the persisted algorithm object—son a remote server. It adds both _logging and monitoring_ capabilities based on a custom function that, among other things, makes use of `ZeroMQ` (see [_http://zeromq.org_](http://zeromq.org/)) for socket communication. In combination with the short script from [“Strategy Monitoring”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_monitor), this allows for a remote real-time monitoring of the activity on a remote server.[4](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#idm45785334006200)

When the script from [“Automated Trading Strategy”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_script) is executed, either locally or remotely, the output that is logged and sent via the socket looks as follows:

```
2020-06-15 17:04:14.298653
================================================================================
NUMBER OF TICKS: 147 | NUMBER OF BARS: 49

================================================================================
MOST RECENT DATA
                     return_lag_1  return_lag_2  ...  max_lag_5  max_lag_6
2020-06-15 15:04:06      0.026508     -0.125253  ...  -1.703276  -1.700746
2020-06-15 15:04:08     -0.049373      0.026508  ...  -1.694419  -1.703276
2020-06-15 15:04:10     -0.077828     -0.049373  ...  -1.694419  -1.694419
2020-06-15 15:04:12      0.064448     -0.077828  ...  -1.705807  -1.694419
2020-06-15 15:04:14     -0.020918      0.064448  ...  -1.710869  -1.705807

[5 rows x 36 columns]

================================================================================
features:
[[-0.02091774  0.06444794 -0.07782834 -0.04937258  0.02650799 -0.12525265
  -2.06428556 -1.96568848 -2.16288147 -2.08071843 -1.94925692 -2.19574189
   0.92939697  0.92939697 -1.07368691  0.92939697 -1.07368691 -1.07368691
  -1.41861822 -1.42605902 -1.4294412  -1.42470615 -1.4274119  -1.42470615
  -1.05508516 -1.06879043 -1.06879043 -1.0619378  -1.06741991 -1.06741991
  -1.70580717 -1.70707253 -1.71339931 -1.7108686  -1.7108686  -1.70580717]]
position: 1
signal:   1


2020-06-15 17:04:14.402154
================================================================================
*** NO TRADE PLACED ***

*** END OF CYCLE ***


2020-06-15 17:04:16.199950
================================================================================


================================================================================
*** GOING NEUTRAL ***

{'id': '979', 'time': '2020-06-15T15:04:16.138027118Z', 'userID': 13834683,
'accountID': '101-004-13834683-001', 'batchID': '978',
'requestID': '60721506683906591', 'type': 'ORDER_FILL', 'orderID': '978',
'instrument': 'EUR_USD', 'units': '-100000.0',
'gainQuoteHomeConversionFactor': '0.882420762903',
'lossQuoteHomeConversionFactor': '0.891289313284',
'price': 1.12751, 'fullVWAP': 1.12751, 'fullPrice': {'type': 'PRICE',
'bids': [{'price': 1.12751, 'liquidity': '10000000'}],
'asks': [{'price': 1.12765, 'liquidity': '10000000'}],
'closeoutBid': 1.12751, 'closeoutAsk': 1.12765}, 'reason': 'MARKET_ORDER',
'pl': '-3.5652', 'financing': '0.0', 'commission': '0.0',
'guaranteedExecutionFee': '0.0', 'accountBalance': '99259.7485',
'tradesClosed': [{'tradeID': '975', 'units': '-100000.0',
'price': 1.12751, 'realizedPL': '-3.5652', 'financing': '0.0',
'guaranteedExecutionFee': '0.0', 'halfSpreadCost': '6.208'}],
'halfSpreadCost': '6.208'}
================================================================================
```

Running the script from [“Strategy Monitoring”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_monitor) locally then allows for the real-time retrieval and processing of such information. Of course, it is easy to adjust the logging and streaming data to one’s own requirements.[5](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#idm45785336429992) Furthermore, the trading script and the whole logic can be adjusted to include such elements as stop losses or take profit targets programmatically.

Trading currency pairs and/or CFDs is associated with a number of financial risks. Implementing an algorithmic trading strategy for such instruments automatically leads to a number of additional risks. Among them are flaws in the trading and/or execution logic, as well as technical risks including problems associated with socket communication, delayed retrieval, or even loss of tick data during the deployment. Therefore, before one deploys a trading strategy in automated fashion one should make sure that all associated market, execution, operational, technical, and other risks have been identified, evaluated, and properly addressed. The code presented in this chapter is only for technical illustration purposes.

## Visual Step-by-Step Overview

This final section provides a step-by-step overview in screenshots. While the previous sections are based on the FXCM trading platform, the visual overview is based on the Oanda trading platform.

### Configuring Oanda Account

The first step is to set up an account with Oanda (or any other trading platform to this end) and to set the correct leverage ratio for the account according to the Kelly criterion and as shown in [Figure 10-8](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_00).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1008.png" alt="pfat 1008" height="1756" width="2884"><figcaption></figcaption></figure>

**Figure 10-8. Setting leverage on Oanda**

### Setting Up the Hardware

The second step is to create a DigitalOcean droplet, as shown in [Figure 10-9](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_01).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1009.png" alt="pfat 1009" height="1756" width="2882"><figcaption></figcaption></figure>

**Figure 10-9. DigitalOcean droplet**

### Setting Up the Python Environment

The third step is to put all the software on the droplet (see [Figure 10-10](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_02)) in order to set up the infrastructure. When it all works fine, you can create a new Jupyter Notebook and start your interactive Python session (see [Figure 10-11](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_03)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1010.png" alt="pfat 1010" height="1569" width="2622"><figcaption></figcaption></figure>

**Figure 10-10. Installing Python and packages**

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1011.png" alt="pfat 1011" height="1756" width="2882"><figcaption></figcaption></figure>

**Figure 10-11. Testing Jupyter Lab**

### Uploading the Code

The fourth step is to upload the Python scripts for automated trading and real-time monitoring, as shown in [Figure 10-12](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_04). The configuration file with the account credentials also needs to be uploaded.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1012.png" alt="pfat 1012" height="1756" width="2882"><figcaption></figcaption></figure>

**Figure 10-12. Uploading Python code files**

### Running the Code

The fifth step is to run the Python script for automated trading, as shown in [Figure 10-13](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_05). [Figure 10-14](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_06) shows a trade that the Python script has initiated.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1013.png" alt="pfat 1013" height="1757" width="2881"><figcaption></figcaption></figure>

**Figure 10-13. Running the Python script**

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1014.png" alt="pfat 1014" height="1756" width="2883"><figcaption></figcaption></figure>

**Figure 10-14. A trade initiated by the Python script**

### Real-Time Monitoring

The final step is to run the monitoring script locally (provided you have set the correct IP in the local script), as seen in [Figure 10-15](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_07). In practice, this means that you can monitor locally in real time what exactly is happening on your cloud instance.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_1015.png" alt="pfat 1015" height="1571" width="2622"><figcaption></figcaption></figure>

**Figure 10-15. Local real-time monitoring via socket**

## Conclusions

This chapter is about the deployment of an algorithmic trading strategy in automated fashion, based on a classification algorithm from machine learning to predict the direction of market movements. It addresses such important topics as capital management (based on the Kelly criterion), vectorized backtesting for performance and risk, the transformation of offline to online trading algorithms, an appropriate infrastructure for deployment, and logging and monitoring during deployment.

The topic of this chapter is complex and requires a broad skill set from the algorithmic trading practitioner. On the other hand, having RESTful APIs for algorithmic trading available, such as the one from Oanda, simplifies the automation task considerably since the core part boils down mainly to making use of the capabilities of the Python wrapper package `tpqoa` for tick data retrieval and order placement. Around this core, elements to mitigate operational and technical risks should be added as far as appropriate and possible.

## References and Further Resources

Papers cited in this chapter:

* Rotando, Louis, and Edward Thorp. 1992. “The Kelly Criterion and the Stock Market.” _The American Mathematical Monthly_ 99 (10): 922-931.
* Hung, Jane. 2010. “Betting with the Kelly Criterion.” [_http://bit.ly/betting\_with\_kelly_](http://bit.ly/betting\_with\_kelly).

## Python Script

This section contains Python scripts used in this chapter.

### Automated Trading Strategy

The following Python script contains the code for the automated deployment of the ML-based trading strategy, as discussed and backtested in this chapter:

```
#
# Automated ML-Based Trading Strategy for Oanda
# Online Algorithm, Logging, Monitoring
#
# Python for Algorithmic Trading
# (c) Dr. Yves J. Hilpisch
#
import zmq
import tpqoa
import pickle
import numpy as np
import pandas as pd
import datetime as dt

log_file = 'automated_strategy.log'

# loads the persisted algorithm object
algorithm = pickle.load(open('algorithm.pkl', 'rb'))

# sets up the socket communication via ZeroMQ (here: "publisher")
context = zmq.Context()
socket = context.socket(zmq.PUB)

# this binds the socket communication to all IP addresses of the machine
socket.bind('tcp://0.0.0.0:5555')

# recreating the log file
with open(log_file, 'w') as f:
    f.write('*** NEW LOG FILE ***\n')
    f.write(str(dt.datetime.now()) + '\n\n\n')


def logger_monitor(message, time=True, sep=True):
    ''' Custom logger and monitor function.
    '''
    with open(log_file, 'a') as f:
        t = str(dt.datetime.now())
        msg = ''
        if time:
            msg += '\n' + t + '\n'
        if sep:
            msg += 80 * '=' + '\n'
        msg += message + '\n\n'
        # sends the message via the socket
        socket.send_string(msg)
        # writes the message to the log file
        f.write(msg)


class MLTrader(tpqoa.tpqoa):
    def __init__(self, config_file, algorithm):
        super(MLTrader, self).__init__(config_file)
        self.model = algorithm['model']
        self.mu = algorithm['mu']
        self.std = algorithm['std']
        self.units = 100000
        self.position = 0
        self.bar = '2s'
        self.window = 2
        self.lags = 6
        self.min_length = self.lags + self.window + 1
        self.features = ['return', 'vol', 'mom', 'sma', 'min', 'max']
        self.raw_data = pd.DataFrame()

    def prepare_features(self):
        self.data['return'] = np.log(
            self.data['mid'] / self.data['mid'].shift(1))
        self.data['vol'] = self.data['return'].rolling(self.window).std()
        self.data['mom'] = np.sign(
            self.data['return'].rolling(self.window).mean())
        self.data['sma'] = self.data['mid'].rolling(self.window).mean()
        self.data['min'] = self.data['mid'].rolling(self.window).min()
        self.data['max'] = self.data['mid'].rolling(self.window).max()
        self.data.dropna(inplace=True)
        self.data[self.features] -= self.mu
        self.data[self.features] /= self.std
        self.cols = []
        for f in self.features:
            for lag in range(1, self.lags + 1):
                col = f'{f}_lag_{lag}'
                self.data[col] = self.data[f].shift(lag)
                self.cols.append(col)

    def report_trade(self, pos, order):
        ''' Prints, logs, and sends trade data.
        '''
        out = '\n\n' + 80 * '=' + '\n'
        out += '*** GOING {} *** \n'.format(pos) + '\n'
        out += str(order) + '\n'
        out += 80 * '=' + '\n'
        logger_monitor(out)
        print(out)

    def on_success(self, time, bid, ask):
        print(self.ticks, 20 * ' ', end='\r')
        df = pd.DataFrame({'bid': float(bid), 'ask': float(ask)},
                          index=[pd.Timestamp(time).tz_localize(None)])
        self.raw_data = self.raw_data.append(df)
        self.data = self.raw_data.resample(
            self.bar, label='right').last().ffill()
        self.data = self.data.iloc[:-1]
        if len(self.data) > self.min_length:
            logger_monitor('NUMBER OF TICKS: {} | '.format(self.ticks) +
                           'NUMBER OF BARS: {}'.format(self.min_length))
            self.min_length += 1
            self.data['mid'] = (self.data['bid'] + self.data['ask']) / 2
            self.prepare_features()
            features = self.data[self.cols].iloc[-1].values.reshape(1, -1)
            signal = self.model.predict(features)[0]
            # logs and sends major financial information
            logger_monitor('MOST RECENT DATA\n' +
                           str(self.data[self.cols].tail()),
                           False)
            logger_monitor('features:\n' + str(features) + '\n' +
                           'position: ' + str(self.position) + '\n' +
                           'signal:   ' + str(signal), False)
            if self.position in [0, -1] and signal == 1:  # going long?
                order = self.create_order(self.stream_instrument,
                                          units=(1 - self.position) *
                                          self.units,
                                          suppress=True, ret=True)
                self.report_trade('LONG', order)
                self.position = 1
            elif self.position in [0, 1] and signal == -1:  # going short?
                order = self.create_order(self.stream_instrument,
                                          units=-(1 + self.position) *
                                          self.units,
                                          suppress=True, ret=True)
                self.report_trade('SHORT', order)
                self.position = -1
            else:  # no trade
                logger_monitor('*** NO TRADE PLACED ***')

            logger_monitor('*** END OF CYCLE ***\n\n', False, False)


if __name__ == '__main__':
    mlt = MLTrader('../pyalgo.cfg', algorithm)
    mlt.stream_data('EUR_USD', stop=150)
    order = mlt.create_order(mlt.stream_instrument,
                             units=-mlt.position * mlt.units,
                             suppress=True, ret=True)
    mlt.position = 0
    mlt.report_trade('NEUTRAL', order)
```

### Strategy Monitoring

The following Python script contains code to remotely monitor the execution of the Python script from [“Automated Trading Strategy”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_script).

```
#
# Automated ML-Based Trading Strategy for Oanda
# Strategy Monitoring via Socket Communication
#
# Python for Algorithmic Trading
# (c) Dr. Yves J. Hilpisch
#
import zmq

# sets up the socket communication via ZeroMQ (here: "subscriber")
context = zmq.Context()
socket = context.socket(zmq.SUB)

# adjust the IP address to reflect the remote location
socket.connect('tcp://134.122.70.51:5555')

# local IP address used for testing
# socket.connect('tcp://0.0.0.0:5555')


# configures the socket to retrieve every message
socket.setsockopt_string(zmq.SUBSCRIBE, '')

while True:
    msg = socket.recv_string()
    print(msg)
```

[1](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#idm45785342245112-marker) The exposition follows Hung (2010).

[2](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#idm45785339950712-marker) It is a stylized empirical fact that it is of paramount importance for the investment and trading performance to get the largest market movements right (that is, the biggest winner _and_ loser movements). This aspect is neatly illustrated in [Figure 10-5](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#auto\_plot\_05), which shows that the trading strategy gets a large downwards movement in the underlying instrument correct, leading to a larger jump for the trading strategy.

[3](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#idm45785334066856-marker) Use the link [_http://bit.ly/do\_sign\_up_](http://bit.ly/do\_sign\_up) to get a 10 USD bonus on DigitalOcean when signing up for a new account.

[4](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#idm45785334006200-marker) The logging approach used here is pretty simple in the form of a simple text file. It is easy to change the logging and persisting of, say, the relevant financial data in the form of a database or appropriate binary storage formats, such as `HDF5` (see [Chapter 3](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch03.html#financial\_data)).

[5](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch10.html#idm45785336429992-marker) Note that the socket communication, as implemented in the two scripts, is not encrypted and is sending plain text over the web, which might represent a security risk in production.
