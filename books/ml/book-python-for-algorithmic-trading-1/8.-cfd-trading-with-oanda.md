# 8. CFD Trading with Oanda

## Chapter 8. CFD Trading with Oanda

> Today, even small entities that trade complex instruments or are granted sufficient leverage can threaten the global financial system.
>
> Paul Singer

Today, it is easier than ever to get started with trading in the financial markets. There is a large number of online trading platforms (brokers) available from which an algorithmic trader can choose. The choice of a platform might be influenced by multiple factors:

Instruments

The first criterion that comes to mind is the type of instrument one is interested in to trade. For example, one might be interested in trading stocks, exchange traded funds (ETFs), bonds, currencies, commodities, options, or futures.

Strategies

Some traders are interested in long-only strategies, while others require short selling as well. Some focus on single-instrument strategies, while others focus on those involving multiple instruments at the same time.

Costs

Fixed and variable transaction costs are an important factor for many traders. They might even decide whether a certain strategy is profitable or not (see, for instance, Chapters [4](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch04.html#vectorized\_backtesting) and [6](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch06.html#event\_based\_backtesting)).

Technology

Technology has become an important factor in the selection of trading platforms. First, there are the tools that the platforms offer to traders. Trading tools are available, in general, for desktop/notebook computers, tablets, and smart phones. Second, there are the application programming interfaces (APIs) that can be accessed programmatically by traders.

Jurisdiction

Financial trading is a heavily regulated field with different legal frameworks in place for different countries or regions. This might prohibit certain traders from using certain platforms and/or financial instruments depending on their residence.

This chapter focuses on [Oanda](http://oanda.com/), an online trading platform that is well suited to deploy automated, algorithmic trading strategies, even for retail traders. The following is a brief description of Oanda along the criteria as outlined previously:

Instruments

Oanda offers a wide range of so-called _contracts for difference_ (CFD) products (see also [“Contracts for Difference (CFDs)”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#cfds) and [“Disclaimer”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch09.html#disclaimer)). Main characteristics of CFDs are that they are leveraged (for example, 10:1 or 50:1) and traded on margin such that losses might exceed the initial capital.

Strategies

Oanda allows both to go long (buy) and to go short (sell) CFDs. Different order types are available, such as market or limit orders, with or without profit targets and/or (trailing) stop losses.

Costs

There are no fixed transaction costs associated with the trading of CFDs at Oanda. However, there is a bid-ask spread that leads to variable transaction costs when trading CFDs.

Technology

Oanda provides the trading application fxTrade (Practice), which retrieves data in real time and allows the (manual, discretionary) trading of all instruments (see [Figure 8-1](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_01\_a)). There is also a browser-based trading application available (see [Figure 8-2](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_01\_b)). A major strength of the platform are the RESTful and streaming APIs (see [Oanda v20 API](https://oreil.ly/\_AHHI)) via which traders can programmatically access historical and streaming data, place buy and sell orders, or retrieve account information. A Python wrapper package is available (see [v20 on PyPi](https://oreil.ly/iZuuV)). Oanda offers free paper trading accounts that provide full access to all technological capabilities, which is really helpful in getting started on the platform. This also simplifies the transitioning from paper to live trading.

Jurisdiction

Depending on the residence of the account holder, the selection of CFDs that can be traded changes. FX-related CFDs are available basically everywhere Oanda is active. CFDs on stock indices, for instance, might not be available in certain jurisdictions.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_0801.png" alt="pfat 0801" height="1732" width="2882"><figcaption></figcaption></figure>

**Figure 8-1. Oanda trading application fxTrade Practice**

**CONTRACTS FOR DIFFERENCE (CFDS)**

For more details on CFDs, see the [Investopedia CFD page](https://oreil.ly/wsoAz) or the more detailed [Wikipedia CFD page](https://oreil.ly/2PnEQ). There are CFDs available on currency pairs (for example, EUR/USD), commodities (for example, gold), stock indices (for example, S\&P 500 stock index), bonds (for example, German 10 Year Bund), and more. One can think of a product range that basically allows one to implement global macro strategies. Financially speaking, CFDs are derivative products that derive their payoff based on the development of prices for other instruments. In addition, trading activity (liquidity) influences the price of CFDs. Although a CFD might be based on the S\&P 500 index, it is a completely different product issued, quoted, and supported by Oanda (or a similar provider).

This brings along certain risks that traders should be aware of. A recent event that illustrates this issue is the _Swiss Franc event_ that led to a number of insolvencies in the online broker space. See, for instance, the article [Currency Brokers Fall Over Like Dominoes After SNB Decison on Swiss Franc](https://oreil.ly/dx7ps).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_0802.png" alt="pfat 0802" height="1758" width="2883"><figcaption></figcaption></figure>

**Figure 8-2. Oanda browser-based trading application**

The chapter is organized as follows. [“Setting Up an Account”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_setup) briefly discusses how to set up an account. [“The Oanda API”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_api) illustrates the necessary steps to access the API. Based on the API access, [“Retrieving Historical Data”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_historical) retrieves and works with historical data for a certain CFD. [“Working with Streaming Data”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_streaming) introduces the streaming API of Oanda for data retrieval and visualization. [“Implementing Trading Strategies in Real Time”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_trading) implements an automated, algorithmic trading strategy in real time. Finally, [“Retrieving Account Information”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_account) deals with retrieving data about the account itself, such as the current balance or recent trades. Throughout, the code makes use of a Python wrapper class called `tpqoa` (see [GitHub repository](https://oreil.ly/E95UV)).

The goal of this chapter is to make use of the approaches and technologies as introduced in previous chapters to automatically trade on the Oanda platform.

## Setting Up an Account

The process for setting up an account with Oanda is simple and efficient. You can choose between a real account and a free demo (“practice”) account, which absolutely suffices to implement what follows (see Figures [8-3](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_02) and [8-4](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_03)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_0803.png" alt="pfat 0803" height="1756" width="2884"><figcaption></figcaption></figure>

**Figure 8-3. Oanda account registration (account types)**

If the registration is successful and you are logged in to the account on the platform, you should see a starting page, as shown in [Figure 8-5](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_04). In the middle, you will find a download link for the `fxTrade Practice for Desktop` application, which you should install. Once it is running, it looks similar to the screenshot shown in [Figure 8-1](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_01\_a).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_0804.png" alt="pfat 0804" height="1757" width="2882"><figcaption></figcaption></figure>

**Figure 8-4. Oanda account registration (registration form)**

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_0805.png" alt="pfat 0805" height="1757" width="2881"><figcaption></figcaption></figure>

**Figure 8-5. Oanda account starting page**

## The Oanda API

After registration, getting access to the APIs of Oanda is an easy affair. The major ingredients needed are the account number and the access token (API key). You will find the account number, for instance, in the area `Manage Funds`. The access token can be generated in the area `Manage API Access` (see [Figure 8-6](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_05)).[1](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#idm45785354036712)

From now on, the [`configparser`](https://oreil.ly/UaQyo) module is used to manage account credentials. The module expects a text file—with a filename, say, of _pyalgo.cfg_—in the following format for use with an Oanda practice account:

```
[oanda]
account_id = YOUR_ACCOUNT_ID
access_token = YOUR_ACCESS_TOKEN
account_type = practice
```

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_0806.png" alt="pfat 0806" height="1758" width="2882"><figcaption></figcaption></figure>

**Figure 8-6. Oanda API access managing page**

To access the API via Python, it is recommended to use the Python wrapper package `tpqoa` (see [GitHub repository](http://github.com/yhilpisch/tpqoa)) that in turn relies on the `v20` package from Oanda (see [GitHub repository](https://oreil.ly/F\_cB2)).

It is installed with the following command:

```
pip install git+https://github.com/yhilpisch/tpqoa.git
```

With these prerequisites, you can connect to the API with a single line of code:

```
In [1]: import tpqoa

In [2]: api = tpqoa.tpqoa('../pyalgo.cfg')  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO1-1)

Adjust the path and filename if required.

This is a major milestone: being connected to the Oanda API allows for the retrieval of historical data, the programmatic placement of orders, and more.

The upside of using the `configparser` module is that it simplifies the storage and management of account credentials. In algorithmic trading, the number of accounts needed can quickly grow. Examples are a cloud instance or server, data service provider, online trading platform, and so on.

The downside is that the account information is stored in the form of plain text, which represents a considerable security risk, particularly since the information about multiple accounts is stored in a single file. When moving to production, you should therefore apply, for example, file encryption methods to keep the credentials safe.

## Retrieving Historical Data

A major benefit of working with the Oanda platform is that the complete price history of all Oanda instruments is accessible via the RESTful API. In this context, _complete history_ refers to the different CFDs themselves, not the underlying instruments they are defined on.

### Looking Up Instruments Available for Trading

For an overview of what instruments can be traded for a given account, use the `.get_instruments()` method. It only retrieves the display names and technical instruments, names from the API. More details are available via the API, such as minimum position size:

```
In [3]: api.get_instruments()[:15]
Out[3]: [('AUD/CAD', 'AUD_CAD'),
         ('AUD/CHF', 'AUD_CHF'),
         ('AUD/HKD', 'AUD_HKD'),
         ('AUD/JPY', 'AUD_JPY'),
         ('AUD/NZD', 'AUD_NZD'),
         ('AUD/SGD', 'AUD_SGD'),
         ('AUD/USD', 'AUD_USD'),
         ('Australia 200', 'AU200_AUD'),
         ('Brent Crude Oil', 'BCO_USD'),
         ('Bund', 'DE10YB_EUR'),
         ('CAD/CHF', 'CAD_CHF'),
         ('CAD/HKD', 'CAD_HKD'),
         ('CAD/JPY', 'CAD_JPY'),
         ('CAD/SGD', 'CAD_SGD'),
         ('CHF/HKD', 'CHF_HKD')]
```

### Backtesting a Momentum Strategy on Minute Bars

The example that follows uses the instrument `EUR_USD` based on the EUR/USD currency pair. The goal is to backtest _momentum-based strategies on one-minute bars_. The data used is for two days in May 2020. The first step is to _retrieve the raw data_ from Oanda:

```
In [4]: help(api.get_history)  
        Help on method get_history in module tpqoa.tpqoa:

        get_history(instrument, start, end, granularity, price, localize=True)
         method of tpqoa.tpqoa.tpqoa instance
            Retrieves historical data for instrument.

            Parameters
            ==========
            instrument: string
                valid instrument name
            start, end: datetime, str
                Python datetime or string objects for start and end
            granularity: string
                a string like 'S5', 'M1' or 'D'
            price: string
                one of 'A' (ask), 'B' (bid) or 'M' (middle)

            Returns
            =======
            data: pd.DataFrame
                pandas DataFrame object with data


In [5]: instrument = 'EUR_USD'  
        start = '2020-08-10'  
        end = '2020-08-12'  
        granularity = 'M1'  
        price = 'M'  

In [6]: data = api.get_history(instrument, start, end,
                              granularity, price)  

In [7]: data.info()  
        <class 'pandas.core.frame.DataFrame'>
        DatetimeIndex: 2814 entries, 2020-08-10 00:00:00 to 2020-08-11
         23:59:00
        Data columns (total 6 columns):
         #   Column    Non-Null Count  Dtype
        ---  ------    --------------  -----
         0   o         2814 non-null   float64
         1   h         2814 non-null   float64
         2   l         2814 non-null   float64
         3   c         2814 non-null   float64
         4   volume    2814 non-null   int64
         5   complete  2814 non-null   bool
        dtypes: bool(1), float64(4), int64(1)
        memory usage: 134.7 KB

In [8]: data[['c', 'volume']].head()  
Out[8]:                            c  volume
        time
        2020-08-10 00:00:00  1.17822      18
        2020-08-10 00:01:00  1.17836      32
        2020-08-10 00:02:00  1.17828      25
        2020-08-10 00:03:00  1.17834      13
        2020-08-10 00:04:00  1.17847      43
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO2-1)

Shows the docstring (help text) for the `.get_history()` method.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO2-2)

Defines the parameter values.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO2-7)

Retrieves the raw data from the API.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO2-8)

Shows the meta information for the retrieved data set.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO2-9)

Shows the first five data rows for two columns.

The second step is to _implement the vectorized backtesting_. The idea is to simultaneously backtest a couple of momentum strategies. The code is straightforward and concise (see also [Chapter 4](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch04.html#vectorized\_backtesting)).

For simplicity, the following code uses close (`c`) values of mid prices only:[2](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#idm45785352515432)

```
In [9]: import numpy as np

In [10]: data['returns'] = np.log(data['c'] / data['c'].shift(1))  

In [11]: cols = []  

In [12]: for momentum in [15, 30, 60, 120]:  
             col = 'position_{}'.format(momentum)  
             data[col] = np.sign(data['returns'].rolling(momentum).mean())  
             cols.append(col)  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO3-1)

Calculates the log returns based on the `close` values of the mid prices.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO3-2)

Instantiates an empty `list` object to collect column names.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO3-3)

Defines the time interval in minute bars for the momentum strategy.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO3-4)

Defines the name of the column to be used for storage in the `DataFrame` object.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO3-5)

Adds the strategy positionings as a new column.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO3-6)

Appends the name of the column to the `list` object.

The final step is the _derivation and plotting of the absolute performance_ of the different momentum strategies. The plot [Figure 8-7](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_plot\_1) shows the performances of the momentum-based strategies graphically and compares them to the performance of the base instrument itself:

```
In [13]: from pylab import plt
         plt.style.use('seaborn')
         import matplotlib as mpl
         mpl.rcParams['savefig.dpi'] = 300
         mpl.rcParams['font.family'] = 'serif'

In [14]: strats = ['returns']  

In [15]: for col in cols:  
             strat = 'strategy_{}'.format(col.split('_')[1])  
             data[strat] = data[col].shift(1) * data['returns']  
             strats.append(strat)  

In [16]: data[strats].dropna().cumsum(
             ).apply(np.exp).plot(figsize=(10, 6));  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO4-1)

Defines another `list` object to store the column names to be plotted later on.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO4-2)

Iterates over columns with the positionings for the different strategies.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO4-3)

Derives the name for the new column in which the strategy performance is stored.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO4-4)

Calculates the log returns for the different strategies and stores them as new columns.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO4-5)

Appends the column names to the `list` object for later plotting.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO4-6)

Plots the cumulative performances for the instrument and the strategies.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_0807.png" alt="pfat 0807" height="1434" width="2497"><figcaption></figcaption></figure>

**Figure 8-7. Gross performance of different momentum strategies for `EUR_USD` instrument (minute bars)**

### Factoring In Leverage and Margin

In general, when you buy a share of a stock for, say, 100 USD, the profit and loss (P\&L) calculations are straightforward: if the stock price rises by 1 USD, you earn 1 USD (unrealized profit); if the stock price falls by 1 USD, you lose 1 USD (unrealized loss). If you buy 10 shares, just multiply the results by 10.

Trading CFDs on the Oanda platform involves leverage and margin. This significantly influences the P\&L calculation. For an introduction to and overview of this topic refer to [Oanda fxTrade Margin Rules](https://oreil.ly/8I5Eg). A simple example can illustrate the major aspects in this context.

Consider that a EUR-based algorithmic trader wants to trade the `EUR_USD` instrument on the Oanda platform and wants to get a long exposure of 10,000 EUR at an ask price of 1.1. Without leverage and margin, the trader (or Python program) would buy 10,000 units of the CFD.[3](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#idm45785353211096) If the price of the instrument (exchange rate) rises to 1.105 (as the midpoint rate between bid and ask prices), the absolute profit is 10,000 x 0.005 = 50 or 0.5%.

What impact do leverage and margining have? Suppose the algorithmic trader chooses a leverage ratio of 20:1, which translates into a 5% margin (= 100% / 20). This in turn implies that the trader only needs to put up a margin upfront of 10,000 EUR x 5% = 500 EUR to get the same exposure. If the price of the instrument then rises to 1.105, the absolute profit stays the same at 50 EUR, but the relative profit rises to 50 EUR / 500 EUR = 10%. The return is considerably amplified by a factor of 20; this is the benefit of leverage when things go as desired.

What happens if things go south? Assume the instrument price drops to 1.08 (as the midpoint rate between bid and ask prices), leading to a loss of 10,000 x (1.08 - 1.1) = -200 EUR. The relative loss now is -200 EUR / 500 EUR = -40%. If the account the algorithmic trader is trading with has less than 200 EUR left in equity/cash, the position needs to be closed out since the (regulatory) margin requirements cannot be met anymore. If losses eat up the margin completely, additional funds need to be allocated as margin to keep the trade alive.[4](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#idm45785353206904)

[Figure 8-8](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_plot\_2) shows the amplifying effect on the performance of the momentum strategies for a leverage ratio of 20:1. The initial margin of 5% suffices to cover potential losses since it is not eaten up even in the worst case depicted:

```
In [17]: data[strats].dropna().cumsum().apply(
                     lambda x: x * 20).apply(np.exp).plot(figsize=(10, 6));  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO5-1)

Multiplies the log returns by a factor of 20 according to the leverage ratio assumed.

Leveraged trading does not only amplify potentials profits, but it also amplifies potential losses. With leveraged trading based on a 10:1 factor (10% margin), a 10% adverse move in the base instrument already wipes out the complete margin. In other words, a 10% move leads to a 100% loss. Therefore, you should make sure to fully understand all risks involved in leveraged trading. You should also make sure to apply appropriate risk measures, such as stop loss orders, that are in line with your risk profile and appetite.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_0808.png" alt="pfat 0808" height="1434" width="2489"><figcaption></figcaption></figure>

**Figure 8-8. Gross performance of momentum strategies for `EUR_USD` instrument with 20:1 leverage (minute bars)**

## Working with Streaming Data

Working with streaming data is again made simple and straightforward by the Python wrapper package `tpqoa`. The package, in combination with the `v20` package, takes care of the socket communication such that the algorithmic trader only needs to decide what to do with the streaming data:

```
In [18]: instrument = 'EUR_USD'

In [19]: api.stream_data(instrument, stop=10)  
         2020-08-19T14:39:13.560138152Z 1.19131 1.1915
         2020-08-19T14:39:14.088511060Z 1.19134 1.19152
         2020-08-19T14:39:14.390081879Z 1.19124 1.19145
         2020-08-19T14:39:15.105974700Z 1.19129 1.19144
         2020-08-19T14:39:15.375370451Z 1.19128 1.19144
         2020-08-19T14:39:15.501380756Z 1.1912 1.19141
         2020-08-19T14:39:15.951793928Z 1.1912 1.19138
         2020-08-19T14:39:16.354844135Z 1.19123 1.19138
         2020-08-19T14:39:16.661440356Z 1.19118 1.19133
         2020-08-19T14:39:16.912150908Z 1.19112 1.19132
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO6-1)

The `stop` parameter stops the streaming after a certain number of ticks retrieved.

## Placing Market Orders

Similarly, it is straightforward to place market buy or sell orders with the `create_order()` method:

```
In [20]: help(api.create_order)  
         Help on method create_order in module tpqoa.tpqoa:

         create_order(instrument, units, price=None, sl_distance=None,
          tsl_distance=None, tp_price=None, comment=None, touch=False,
          suppress=False, ret=False) method of tpqoa.tpqoa.tpqoa instance
             Places order with Oanda.

             Parameters
             ==========
             instrument: string
                 valid instrument name
             units: int
                 number of units of instrument to be bought
                 (positive int, e.g., 'units=50')
                 or to be sold (negative int, e.g., 'units=-100')
             price: float
                 limit order price, touch order price
             sl_distance: float
                 stop loss distance price, mandatory e.g., in Germany
             tsl_distance: float
                 trailing stop loss distance
             tp_price: float
                 take profit price to be used for the trade
             comment: str
                 string
             touch: boolean
                 market_if_touched order (requires price to be set)
             suppress: boolean
                 whether to suppress print out
             ret: boolean
                 whether to return the order object


In [21]: api.create_order(instrument, 1000)  


         {'id': '1721', 'time': '2020-08-19T14:39:17.062399275Z', 'userID':
          13834683, 'accountID': '101-004-13834683-001', 'batchID': '1720',
          'requestID': '24716258589170956', 'type': 'ORDER_FILL', 'orderID':
          '1720', 'instrument': 'EUR_USD', 'units': '1000.0',
          'gainQuoteHomeConversionFactor': '0.835288642787',
          'lossQuoteHomeConversionFactor': '0.843683503518', 'price': 1.19131,
          'fullVWAP': 1.19131, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':
          1.1911, 'liquidity': '10000000'}], 'asks': [{'price': 1.19131,
          'liquidity': '10000000'}], 'closeoutBid': 1.1911, 'closeoutAsk':
          1.19131}, 'reason': 'MARKET_ORDER', 'pl': '0.0', 'financing': '0.0',
          'commission': '0.0', 'guaranteedExecutionFee': '0.0',
          'accountBalance': '98510.7986', 'tradeOpened': {'tradeID': '1721',
          'units': '1000.0', 'price': 1.19131, 'guaranteedExecutionFee': '0.0',
          'halfSpreadCost': '0.0881', 'initialMarginRequired': '33.3'},
          'halfSpreadCost': '0.0881'}


In [22]: api.create_order(instrument, -1500)  


         {'id': '1723', 'time': '2020-08-19T14:39:17.200434462Z', 'userID':
          13834683, 'accountID': '101-004-13834683-001', 'batchID': '1722',
          'requestID': '24716258589171315', 'type': 'ORDER_FILL', 'orderID':
          '1722', 'instrument': 'EUR_USD', 'units': '-1500.0',
          'gainQuoteHomeConversionFactor': '0.835288642787',
          'lossQuoteHomeConversionFactor': '0.843683503518', 'price': 1.1911,
          'fullVWAP': 1.1911, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':
          1.1911, 'liquidity': '10000000'}], 'asks': [{'price': 1.19131,
          'liquidity': '9999000'}], 'closeoutBid': 1.1911, 'closeoutAsk':
          1.19131}, 'reason': 'MARKET_ORDER', 'pl': '-0.1772', 'financing':
          '0.0', 'commission': '0.0', 'guaranteedExecutionFee': '0.0',
          'accountBalance': '98510.6214', 'tradeOpened': {'tradeID': '1723',
          'units': '-500.0', 'price': 1.1911, 'guaranteedExecutionFee': '0.0',
          'halfSpreadCost': '0.0441', 'initialMarginRequired': '16.65'},
          'tradesClosed': [{'tradeID': '1721', 'units': '-1000.0', 'price':
          1.1911, 'realizedPL': '-0.1772', 'financing': '0.0',
          'guaranteedExecutionFee': '0.0', 'halfSpreadCost': '0.0881'}],
          'halfSpreadCost': '0.1322'}


In [23]: api.create_order(instrument, 500)  


         {'id': '1725', 'time': '2020-08-19T14:39:17.348231507Z', 'userID':
          13834683, 'accountID': '101-004-13834683-001', 'batchID': '1724',
          'requestID': '24716258589171775', 'type': 'ORDER_FILL', 'orderID':
          '1724', 'instrument': 'EUR_USD', 'units': '500.0',
          'gainQuoteHomeConversionFactor': '0.835313189428',
          'lossQuoteHomeConversionFactor': '0.84370829686', 'price': 1.1913,
          'fullVWAP': 1.1913, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':
          1.19104, 'liquidity': '9998500'}], 'asks': [{'price': 1.1913,
          'liquidity': '9999000'}], 'closeoutBid': 1.19104, 'closeoutAsk':
          1.1913}, 'reason': 'MARKET_ORDER', 'pl': '-0.0844', 'financing':
          '0.0', 'commission': '0.0', 'guaranteedExecutionFee': '0.0',
          'accountBalance': '98510.537', 'tradesClosed': [{'tradeID': '1723',
          'units': '500.0', 'price': 1.1913, 'realizedPL': '-0.0844',
          'financing': '0.0', 'guaranteedExecutionFee': '0.0', 'halfSpreadCost':
          '0.0546'}], 'halfSpreadCost': '0.0546'}
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO7-1)

Shows all options for placing market, limit, and market-if-touched orders.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO7-2)

Opens a long position via market order.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO7-3)

Goes short after closing the long position via market order.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO7-4)

Closes the short position via market order.

Although the Oanda API allows the placement of different order types, this chapter and the following chapter mainly focus on _market orders_ to instantly go long or short whenever a new signal appears.

## Implementing Trading Strategies in Real Time

This section presents a custom class that automatically trades the `EUR_USD` instrument on the Oanda platform based on a momentum strategy. It is called `MomentumTrader` and is presented in [“Python Script”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#oanda\_momentum\_trader). The following walks through the class line by line, beginning with the `0` method. The class itself inherits from the `tpqoa` class:

```
import tpqoa
import numpy as np
import pandas as pd


class MomentumTrader(tpqoa.tpqoa):
    def __init__(self, conf_file, instrument, bar_length, momentum, units,
                 *args, **kwargs):
        super(MomentumTrader, self).__init__(conf_file)
        self.position = 0  
        self.instrument = instrument  
        self.momentum = momentum  
        self.bar_length = bar_length  
        self.units = units  
        self.raw_data = pd.DataFrame()  
        self.min_length = self.momentum + 1  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO8-1)

Initial position value (market neutral).

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO8-2)

Instrument to be traded.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO8-3)

Length of the bar for the resampling of the tick data.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO8-4)

Number of intervals for momentum calculation.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO8-5)

Number of units to be traded.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO8-6)

An empty `DataFrame` object to be filled with tick data.

[![7](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/7.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO8-7)

The initial minimum bar length for the start of the trading itself.

The major method is the `.on_success()` method, which implements the trading logic for the momentum strategy:

```
    def on_success(self, time, bid, ask):  
        ''' Takes actions when new tick data arrives. '''
        print(self.ticks, end=' ')  
        self.raw_data = self.raw_data.append(pd.DataFrame(
            {'bid': bid, 'ask': ask}, index=[pd.Timestamp(time)]))  
        self.data = self.raw_data.resample(
            self.bar_length, label='right').last().ffill().iloc[:-1]  
        self.data['mid'] = self.data.mean(axis=1)  
        self.data['returns'] = np.log(self.data['mid'] /
                                      self.data['mid'].shift(1))  
        self.data['position'] = np.sign(
            self.data['returns'].rolling(self.momentum).mean())  

        if len(self.data) > self.min_length:  
            self.min_length += 1  
            if self.data['position'].iloc[-1] == 1:  
                if self.position == 0:  
                    self.create_order(self.instrument, self.units)  
                elif self.position == -1:  
                    self.create_order(self.instrument, self.units * 2)  
                self.position = 1  
            elif self.data['position'].iloc[-1] == -1:  
                if self.position == 0:  
                    self.create_order(self.instrument, -self.units)  
                elif self.position == 1:  
                    self.create_order(self.instrument, -self.units * 2)  
                self.position = -1  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-1)

This method is called whenever new tick data arrives.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-2)

The number of ticks retrieved is printed.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-3)

The tick data is collected and stored.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-4)

The tick data is then resampled to the appropriate bar length.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-5)

The mid prices are calculated…

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-6)

…based on which the log returns are derived.

[![7](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/7.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-7)

The signal (positioning) is derived based on the `momentum` parameter/attribute (via an online algorithm).

[![8](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/8.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-8)

When there is enough or new data, the trading logic is applied and the minimum length is increased by one every time.

[![9](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/9.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-10)

Checks whether the latest positioning (“signal”) is `1` (long).

[![10](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/10.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-11)

If the current market position is `0` (neutral)…

[![11](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/11.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-12)

…a buy order for `self.units` is initiated.

[![12](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/12.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-13)

If it is `-1` (short)…

[![13](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/13.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-14)

…a buy order for `0` is initiated.

[![14](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/14.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-15)

The market position `self.position` is set to `+1` (long).

[![15](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/15.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-16)

Checks whether the latest positioning (“signal”) is `-1` (short).

[![16](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/16.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-17)

If the current market position is `0` (neutral)…

[![17](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/17.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-18)

…a sell order for `-self.units` is initiated.

[![18](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/18.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-19)

If it is `+1` (long)…

[![19](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/19.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-20)

…a sell order for `0` is initiated.

[![20](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/20.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO9-21)

The market position `self.position` is set to -1 (short).

Based on this class, getting started with automated, algorithmic trading is just four lines of code. The Python code that follows initiates an automated trading session:

```
In [24]: import MomentumTrader as MT

In [25]: mt = MT.MomentumTrader('../pyalgo.cfg',  
                                instrument=instrument,  
                                bar_length='10s',  
                                momentum=6,  
                                units=10000)  

In [26]: mt.stream_data(mt.instrument, stop=500)  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO10-1)

The configuration file with the credentials.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO10-2)

The `instrument` parameter is specified.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO10-3)

The `bar_length` parameter for the resampling is provided.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO10-4)

The `momentum` parameter is defined, which is applied to the resampled data intervals.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO10-5)

The `units` parameter is set, which specifies the position size for long and short positions.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO10-6)

This starts the streaming and therewith the trading; it stops after 100 ticks.

The preceding code provides the following output:

```
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73
 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96
 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114
 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131
 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148
 149 150 151 152 153

{'id': '1727', 'time': '2020-08-19T14:40:30.443867492Z', 'userID':
 13834683, 'accountID': '101-004-13834683-001', 'batchID': '1726',
 'requestID': '42730657405829101', 'type': 'ORDER_FILL', 'orderID':
 '1726', 'instrument': 'EUR_USD', 'units': '10000.0',
 'gainQuoteHomeConversionFactor': '0.8350012403',
 'lossQuoteHomeConversionFactor': '0.843393212565', 'price': 1.19168,
 'fullVWAP': 1.19168, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':
 1.19155, 'liquidity': '10000000'}], 'asks': [{'price': 1.19168,
 'liquidity': '10000000'}], 'closeoutBid': 1.19155, 'closeoutAsk':
 1.19168}, 'reason': 'MARKET_ORDER', 'pl': '0.0', 'financing': '0.0',
 'commission': '0.0', 'guaranteedExecutionFee': '0.0',
 'accountBalance': '98510.537', 'tradeOpened': {'tradeID': '1727',
 'units': '10000.0', 'price': 1.19168, 'guaranteedExecutionFee': '0.0',
 'halfSpreadCost': '0.5455', 'initialMarginRequired': '333.0'},
 'halfSpreadCost': '0.5455'}

154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171
 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188
 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205
 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222
 223

{'id': '1729', 'time': '2020-08-19T14:41:11.436438078Z', 'userID':
 13834683, 'accountID': '101-004-13834683-001', 'batchID': '1728',
 'requestID': '42730657577912600', 'type': 'ORDER_FILL', 'orderID':
 '1728', 'instrument': 'EUR_USD', 'units': '-20000.0',
 'gainQuoteHomeConversionFactor': '0.83519398913',
 'lossQuoteHomeConversionFactor': '0.843587898569', 'price': 1.19124,
 'fullVWAP': 1.19124, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':
 1.19124, 'liquidity': '10000000'}], 'asks': [{'price': 1.19144,
 'liquidity': '10000000'}], 'closeoutBid': 1.19124, 'closeoutAsk':
 1.19144}, 'reason': 'MARKET_ORDER', 'pl': '-3.7118', 'financing':
 '0.0', 'commission': '0.0', 'guaranteedExecutionFee': '0.0',
 'accountBalance': '98506.8252', 'tradeOpened': {'tradeID': '1729',
 'units': '-10000.0', 'price': 1.19124, 'guaranteedExecutionFee':
 '0.0', 'halfSpreadCost': '0.8394', 'initialMarginRequired': '333.0'},
 'tradesClosed': [{'tradeID': '1727', 'units': '-10000.0', 'price':
 1.19124, 'realizedPL': '-3.7118', 'financing': '0.0',
 'guaranteedExecutionFee': '0.0', 'halfSpreadCost': '0.8394'}],
 'halfSpreadCost': '1.6788'}

224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241
 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258
 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275
 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292
 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309
 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326
 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343
 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360
 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377
 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394

{'id': '1731', 'time': '2020-08-19T14:42:20.525804142Z', 'userID':
 13834683, 'accountID': '101-004-13834683-001', 'batchID': '1730',
 'requestID': '42730657867512554', 'type': 'ORDER_FILL', 'orderID':
 '1730', 'instrument': 'EUR_USD', 'units': '20000.0',
 'gainQuoteHomeConversionFactor': '0.835400847964',
 'lossQuoteHomeConversionFactor': '0.843796836386', 'price': 1.19111,
 'fullVWAP': 1.19111, 'fullPrice': {'type': 'PRICE', 'bids': [{'price':
 1.19098, 'liquidity': '10000000'}], 'asks': [{'price': 1.19111,
 'liquidity': '10000000'}], 'closeoutBid': 1.19098, 'closeoutAsk':
 1.19111}, 'reason': 'MARKET_ORDER', 'pl': '1.086', 'financing': '0.0',
 'commission': '0.0', 'guaranteedExecutionFee': '0.0',
 'accountBalance': '98507.9112', 'tradeOpened': {'tradeID': '1731',
 'units': '10000.0', 'price': 1.19111, 'guaranteedExecutionFee': '0.0',
 'halfSpreadCost': '0.5457', 'initialMarginRequired': '333.0'},
 'tradesClosed': [{'tradeID': '1729', 'units': '10000.0', 'price':
 1.19111, 'realizedPL': '1.086', 'financing': '0.0',
 'guaranteedExecutionFee': '0.0', 'halfSpreadCost': '0.5457'}],
 'halfSpreadCost': '1.0914'}

395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412
 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429
 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446
 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463
 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480
 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497
 498 499 500
```

Finally, close out the final position:

```
In [27]: oo = mt.create_order(instrument, units=-mt.position * mt.units,
                              ret=True, suppress=True)  
         oo
Out[27]: {'id': '1733',
          'time': '2020-08-19T14:43:17.107985242Z',
          'userID': 13834683,
          'accountID': '101-004-13834683-001',
          'batchID': '1732',
          'requestID': '42730658106750652',
          'type': 'ORDER_FILL',
          'orderID': '1732',
          'instrument': 'EUR_USD',
          'units': '-10000.0',
          'gainQuoteHomeConversionFactor': '0.835327206922',
          'lossQuoteHomeConversionFactor': '0.843722455232',
          'price': 1.19109,
          'fullVWAP': 1.19109,
          'fullPrice': {'type': 'PRICE',
           'bids': [{'price': 1.19109, 'liquidity': '10000000'}],
           'asks': [{'price': 1.19121, 'liquidity': '10000000'}],
           'closeoutBid': 1.19109,
           'closeoutAsk': 1.19121},
          'reason': 'MARKET_ORDER',
          'pl': '-0.1687',
          'financing': '0.0',
          'commission': '0.0',
          'guaranteedExecutionFee': '0.0',
          'accountBalance': '98507.7425',
          'tradesClosed': [{'tradeID': '1731',
            'units': '-10000.0',
            'price': 1.19109,
            'realizedPL': '-0.1687',
            'financing': '0.0',
            'guaranteedExecutionFee': '0.0',
            'halfSpreadCost': '0.5037'}],
          'halfSpreadCost': '0.5037'}
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#co\_cfd\_trading\_with\_oanda\_CO11-1)

Closes out the final position.

## Retrieving Account Information

With regard to account information, transaction history, and the like, the Oanda RESTful API is also convenient to work with. For example, after the execution of the momentum strategy in the previous section, the algorithmic trader might want to inspect the current balance of the trading account. This is possible via the `.get_account_summary()` method:

```
In [28]: api.get_account_summary()
Out[28]: {'id': '101-004-13834683-001',
          'alias': 'Primary',
          'currency': 'EUR',
          'balance': '98507.7425',
          'createdByUserID': 13834683,
          'createdTime': '2020-03-19T06:08:14.363139403Z',
          'guaranteedStopLossOrderMode': 'DISABLED',
          'pl': '-1273.126',
          'resettablePL': '-1273.126',
          'resettablePLTime': '0',
          'financing': '-219.1315',
          'commission': '0.0',
          'guaranteedExecutionFees': '0.0',
          'marginRate': '0.0333',
          'openTradeCount': 1,
          'openPositionCount': 1,
          'pendingOrderCount': 0,
          'hedgingEnabled': False,
          'unrealizedPL': '929.8862',
          'NAV': '99437.6287',
          'marginUsed': '377.76',
          'marginAvailable': '99064.4945',
          'positionValue': '3777.6',
          'marginCloseoutUnrealizedPL': '935.8183',
          'marginCloseoutNAV': '99443.5608',
          'marginCloseoutMarginUsed': '377.76',
          'marginCloseoutPercent': '0.0019',
          'marginCloseoutPositionValue': '3777.6',
          'withdrawalLimit': '98507.7425',
          'marginCallMarginUsed': '377.76',
          'marginCallPercent': '0.0038',
          'lastTransactionID': '1733'}
```

Information about the last few trades is received with the `.get_transactions()` method:

```
In [29]: api.get_transactions(tid=int(oo['id']) - 2)
Out[29]: [{'id': '1732',
           'time': '2020-08-19T14:43:17.107985242Z',
           'userID': 13834683,
           'accountID': '101-004-13834683-001',
           'batchID': '1732',
           'requestID': '42730658106750652',
           'type': 'MARKET_ORDER',
           'instrument': 'EUR_USD',
           'units': '-10000.0',
           'timeInForce': 'FOK',
           'positionFill': 'DEFAULT',
           'reason': 'CLIENT_ORDER'},
          {'id': '1733',
           'time': '2020-08-19T14:43:17.107985242Z',
           'userID': 13834683,
           'accountID': '101-004-13834683-001',
           'batchID': '1732',
           'requestID': '42730658106750652',
           'type': 'ORDER_FILL',
           'orderID': '1732',
           'instrument': 'EUR_USD',
           'units': '-10000.0',
           'gainQuoteHomeConversionFactor': '0.835327206922',
           'lossQuoteHomeConversionFactor': '0.843722455232',
           'price': 1.19109,
           'fullVWAP': 1.19109,
           'fullPrice': {'type': 'PRICE',
            'bids': [{'price': 1.19109, 'liquidity': '10000000'}],
            'asks': [{'price': 1.19121, 'liquidity': '10000000'}],
            'closeoutBid': 1.19109,
            'closeoutAsk': 1.19121},
           'reason': 'MARKET_ORDER',
           'pl': '-0.1687',
           'financing': '0.0',
           'commission': '0.0',
           'guaranteedExecutionFee': '0.0',
           'accountBalance': '98507.7425',
           'tradesClosed': [{'tradeID': '1731',
             'units': '-10000.0',
             'price': 1.19109,
             'realizedPL': '-0.1687',
             'financing': '0.0',
             'guaranteedExecutionFee': '0.0',
             'halfSpreadCost': '0.5037'}],
           'halfSpreadCost': '0.5037'}]
```

For a concise overview, there is also the `.print_transactions()` method available:

```
In [30]: api.print_transactions(tid=int(oo['id']) - 18)
         1717 | 2020-08-19T14:37:00.803426931Z | EUR_USD |   -10000.0 | 0.0
         1719 | 2020-08-19T14:38:21.953399006Z | EUR_USD |    10000.0 | 6.8444
         1721 | 2020-08-19T14:39:17.062399275Z | EUR_USD |     1000.0 | 0.0
         1723 | 2020-08-19T14:39:17.200434462Z | EUR_USD |    -1500.0 | -0.1772
         1725 | 2020-08-19T14:39:17.348231507Z | EUR_USD |      500.0 | -0.0844
         1727 | 2020-08-19T14:40:30.443867492Z | EUR_USD |    10000.0 | 0.0
         1729 | 2020-08-19T14:41:11.436438078Z | EUR_USD |   -20000.0 | -3.7118
         1731 | 2020-08-19T14:42:20.525804142Z | EUR_USD |    20000.0 | 1.086
         1733 | 2020-08-19T14:43:17.107985242Z | EUR_USD |   -10000.0 | -0.1687
```

## Conclusions

The Oanda platform allows for an easy and straightforward entry into the world of automated, algorithmic trading. Oanda specializes in so-called contracts for difference (CFDs). Depending on the country of residence of the trader, there is a great variety of instruments that can be traded.

A major advantage of Oanda from a technological point of view is the modern, powerful APIs that can be easily accessed via a dedicated Python wrapper package (`v20`). This chapter shows how to set up an account, how to connect to the APIs with Python, how to retrieve historical data (one minute bars) for backtesting purposes, how to retrieve streaming data in real time, how to automatically trade a CFD based on a momentum strategy, and how to retrieve account information and the detailed transaction history.

## References and Further Resources

Visit the help and support pages of Oanda under [Help and Support](https://oreil.ly/-CMwk) to learn more about the Oanda platform and important aspects of CFD trading.

The developer portal of Oanda [Getting Started](https://oreil.ly/oO\_eV) provides a detailed description of the APIs.

## Python Script

The following Python script contains an Oanda custom streaming class that automatically trades a momentum strategy:

```
#
# Python Script
# with Momentum Trading Class
# for Oanda v20
#
# Python for Algorithmic Trading
# (c) Dr. Yves J. Hilpisch
# The Python Quants GmbH
#
import tpqoa
import numpy as np
import pandas as pd


class MomentumTrader(tpqoa.tpqoa):
    def __init__(self, conf_file, instrument, bar_length, momentum, units,
                 *args, **kwargs):
        super(MomentumTrader, self).__init__(conf_file)
        self.position = 0
        self.instrument = instrument
        self.momentum = momentum
        self.bar_length = bar_length
        self.units = units
        self.raw_data = pd.DataFrame()
        self.min_length = self.momentum + 1

    def on_success(self, time, bid, ask):
        ''' Takes actions when new tick data arrives. '''
        print(self.ticks, end=' ')
        self.raw_data = self.raw_data.append(pd.DataFrame(
            {'bid': bid, 'ask': ask}, index=[pd.Timestamp(time)]))
        self.data = self.raw_data.resample(
            self.bar_length, label='right').last().ffill().iloc[:-1]
        self.data['mid'] = self.data.mean(axis=1)
        self.data['returns'] = np.log(self.data['mid'] /
                                      self.data['mid'].shift(1))
        self.data['position'] = np.sign(
            self.data['returns'].rolling(self.momentum).mean())

        if len(self.data) > self.min_length:
            self.min_length += 1
            if self.data['position'].iloc[-1] == 1:
                if self.position == 0:
                    self.create_order(self.instrument, self.units)
                elif self.position == -1:
                    self.create_order(self.instrument, self.units * 2)
                self.position = 1
            elif self.data['position'].iloc[-1] == -1:
                if self.position == 0:
                    self.create_order(self.instrument, -self.units)
                elif self.position == 1:
                    self.create_order(self.instrument, -self.units * 2)
                self.position = -1


if __name__ == '__main__':
    strat = 2
    if strat == 1:
        mom = MomentumTrader('../pyalgo.cfg', 'DE30_EUR', '5s', 3, 1)
        mom.stream_data(mom.instrument, stop=100)
        mom.create_order(mom.instrument, units=-mom.position * mom.units)
    elif strat == 2:
        mom = MomentumTrader('../pyalgo.cfg', instrument='EUR_USD',
                             bar_length='5s', momentum=6, units=100000)
        mom.stream_data(mom.instrument, stop=100)
        mom.create_order(mom.instrument, units=-mom.position * mom.units)
    else:
        print('Strategy not known.')
```

[1](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#idm45785354036712-marker) The naming of certain objects is not completely consistent in the context of the Oanda APIs. For example, _API key_ and _access token_ are used interchangeably. Also, _account ID_ and _account number_ refer to the same number.

[2](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#idm45785352515432-marker) This implicitely neglects transaction costs in the form of bid-ask spreads when selling and buying units of the instrument, respectively.

[3](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#idm45785353211096-marker) Note that for some instruments, _one unit_ means 1 USD, like for currency-related CFDs. For others, like for index-related CFDs (for example, `DE30_EUR`), _one unit_ means a currency exposure at the (bid/ask) price of the CFD (for example, 11,750 EUR).

[4](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch08.html#idm45785353206904-marker) The simplified calculations neglect, for example, _financing costs_ that might become due for leveraged trading.
