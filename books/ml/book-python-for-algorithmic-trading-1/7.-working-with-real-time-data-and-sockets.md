# 7. Working with Real-Time Data and Sockets

## Chapter 7. Working with Real-Time Data and Sockets

> If you want to find the secrets of the universe, think in terms of energy, frequency, and vibration.
>
> Nikola Tesla

Developing trading ideas and backtesting them is a rather asynchronous and non-critical process during which there are multiple steps that might or might not be repeated, during which no capital is at stake, and during which performance and speed are not the most important requirements. Turning to the markets to deploy a trading strategy changes the rules considerably. Data arrives in real time and usually in massive amounts, making a real-time processing of the data and the real-time decision making based on the streaming data a necessity. This chapter is about working with real-time data for which _sockets_ are in general the technological tool of choice. In this context, here are a few words on central technical terms:

Network socket

Endpoint of a connection in a computer network, also simply _socket_ for short.

Socket address

Combination of an Internet Protocol (IP) address and a port number.

Socket protocol

A protocol defining and handling the socket communication, like the Transfer Control Protocol (TCP).

Socket pair

Combination of a local and a remote socket that communicate with each other.

Socket API

The application programming interface allowing for the controlling of sockets and their communication.

This chapter focuses on the use of [`ZeroMQ`](http://zeromq.org/) as a lightweight, fast, and scalable socket programming library. It is available on multiple platforms with wrappers for the most popular programming languages. `ZeroMQ` supports different patterns for socket communication. One of those patterns is the so-called _publisher-subscriber_ (`PUB-SUB`) pattern where a single socket publishes data and multiple sockets simultaneously retrieve the data. This is similar to a radio station that broadcasts its program that is simultaneously listened to by thousands of people via radio devices.

Given the `PUB-SUB` pattern, a fundamental application scenario in algorithmic trading is the retrieval of real-time financial data from an exchange, a trading platform, or a data service provider. Suppose you have developed an intraday trading idea based on the EUR/USD currency pair and have backtested it thoroughly. When deploying it, you need to be able to receive and process the price data in real-time. This fits exactly such a `PUB-SUB` pattern. A central instance broadcasts the new tick data as it becomes available and you, as well as probably thousands of others, receive and process it at the same time.[1](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#idm45785358164968)

This chapter is organized as follows. [“Running a Simple Tick Data Server”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#tick\_server) describes how to implement and run a tick data server for sample financial data. [“Connecting a Simple Tick Data Client”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#tick\_client) implements a tick data client to connect to the tick data server. [“Signal Generation in Real Time”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#signal\_generation) shows how to generate trading signals in real time based on data from the tick data server. Finally, [“Visualizing Streaming Data with Plotly”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#stream\_plotting) introduces the [Plotly](http://plot.ly/) plotting package as an efficient way to plot streaming data in real time.

The goal of this chapter is to have a tool set and approaches available to be able to work with streaming data in the context of algorithmic trading.

The code in this chapter makes heavy use of ports over which socket communication takes place and requires the simultaneous execution of two or more scripts at the same time. It is therefore recommended to execute the codes in this chapter in different terminal instances, running different Python kernels. The execution within a single Jupyter Notebook, for instance, does not work in general. What works, however, is the execution of the tick data server script ([“Running a Simple Tick Data Server”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#tick\_server)) in a terminal and the retrieval of data in a Jupyter Notebook ([“Visualizing Streaming Data with Plotly”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#stream\_plotting)).

## Running a Simple Tick Data Server

This section shows how to run a simple tick data server based on simulated financial instrument prices. The model used for the data generation is the geometric Brownian motion (without dividends) for which an exact Euler discretization is available, as shown in [Equation 7-1](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#euler\_disc). Here, � is the instrument price, � is the constant short rate, � is the constant volatility factor, and � is a standard normal random variable. �� is the interval between two discrete observations of the instrument price.

**Equation 7-1. Euler discretization of geometric Brownian motion**

��=��-��·exp�-�22��+����

Making use of this model, [“Sample Tick Data Server”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#py\_tick\_server) presents a Python script that implements a tick data server using `ZeroMQ` and a class called `InstrumentPrice` to publish new, simulated tick data in a randomized fashion. The publishing is randomized in two ways. First, the stock price value is based on a Monte Carlo simulation. Second is the length of time interval between two publishing events it randomized. The remainder of this section explains the major parts of the script in detail.

The first part of the following script does some imports, among other things, for the Python wrapper of `ZeroMQ`. It also instantiates the major objects needed to open a socket of `PUB` type:

```
import zmq  
import math
import time
import random

context = zmq.Context()  
socket = context.socket(zmq.PUB)  
socket.bind('tcp://0.0.0.0:5555')  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO1-1)

This imports the Python wrapper for the `ZeroMQ` library.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO1-2)

A `Context` object is instantiated. It is the central object for the socket communication.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO1-3)

The socket itself is defined based on the `PUB` socket type (“communication pattern”).

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO1-4)

The socket gets bound to the local IP address (`0.0.0.0` on Linux and Mac OS, `127.0.0.1` on Windows) and the port number 5555.

The class `InstrumentPrice` is for the simulation of instrument price values over time. As attributes, there are the major parameters for the geometric Brownian motion in addition to the instrument symbol and the time at which an instance is created. The only method `.simulate_value()` generates new values for the stock price given the time passed since it has been called the last time and a random factor:

```
class InstrumentPrice(object):
    def __init__(self):
        self.symbol = 'SYMBOL'
        self.t = time.time()  
        self.value = 100.
        self.sigma = 0.4
        self.r = 0.01

    def simulate_value(self):
        ''' Generates a new, random stock price.
        '''
        t = time.time()  
        dt = (t - self.t) / (252 * 8 * 60 * 60)  
        dt *= 500  
        self.t = t  
        self.value *= math.exp((self.r - 0.5 * self.sigma ** 2) * dt +
                               self.sigma * math.sqrt(dt) * random.gauss(0, 1))  
        return self.value
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO2-1)

The attribute `t` stores the time of the initialization.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO2-2)

When the `.simulate_value()` method is called, the current time is recorded.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO2-3)

`dt` represents the time interval between the current time and the one stored in `self.t` in (trading) year fractions.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO2-4)

To have larger instrument price movements, this line of code scales the `dt` variable (by an arbitrary factor).

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO2-5)

The attribute `t` is updated with the current time, which represents the reference point for the next call of the method.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO2-6)

Based on an Euler scheme for the geometric Brownian motion, a new instrument price is simulated.

The main part of the script consists of the instantiation of an object of type `InstrumentPrice` and an infinite `while` loop. During the `while` loop, a new instrument price gets simulated, and a message is created, printed, and sent via the socket.

Finally, the execution pauses for a random amount of time:

```
ip = InstrumentPrice()  

while True:  
    msg = '{} {:.2f}'.format(ip.symbol, ip.simulate_value())  
    print(msg)  
    socket.send_string(msg)  
    time.sleep(random.random() * 2)  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO3-1)

This line instantiates an `InstrumentPrice` object.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO3-2)

An infinite `while` loop is started.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO3-3)

The message text gets generated based on the `symbol` attribute and a newly simulated stock price value.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO3-4)

The message `str` object is printed to the standard out.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO3-5)

It is also sent to subscribed sockets.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO3-6)

The execution of the loop is paused for a random amount of time (between 0 and 2 seconds), simulating the random arrival of new tick data in the markets.

Executing the script prints out messages as follows:

```
(base) pro:ch07 yves$ Python TickServer.py
SYMBOL 100.00
SYMBOL 99.65
SYMBOL 99.28
SYMBOL 99.09
SYMBOL 98.76
SYMBOL 98.83
SYMBOL 98.82
SYMBOL 98.92
SYMBOL 98.57
SYMBOL 98.81
SYMBOL 98.79
SYMBOL 98.80
```

At this point, it cannot yet be verified whether the script is also sending the same message via the socket bound to `tcp://0.0.0.0:5555` (`tcp://127.0.0.1:5555` on Windows). To this end, another socket subscribing to the publishing socket is needed to complete the socket pair.

Often, the Monte Carlo simulation of prices for financial instruments relies on homogeneous time intervals (like “one trading day”). In many cases, this is a “good enough” approximation when working with, say, end-of-day closing prices over longer horizons. In the context of intraday tick data, the random arrival of the data is an important characteristic that needs to be taken into account. The Python script for the tick data server implements the random arrival times by randomized time intervals during which it pauses the execution.

## Connecting a Simple Tick Data Client

The code for the tick data server is already quite concise, with the `InstrumentPrice` simulation class representing the longest part. The code for a respective tick data client, as shown in [“Tick Data Client”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#py\_tick\_client), is even more concise. It is only a few lines of code that instantiate the main `Context` object, connect to the publishing socket, and subscribe to the `SYMBOL` channel, which happens to be the only available channel here. In the `while` loop, the string-based message is received and printed. That makes for a rather short script.

The initial part of the following script is almost symmetrical to the tick data server script:

```
import zmq  

context = zmq.Context()  
socket = context.socket(zmq.SUB)  
socket.connect('tcp://0.0.0.0:5555')  
socket.setsockopt_string(zmq.SUBSCRIBE, 'SYMBOL')  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO4-1)

This imports the Python wrapper for the `ZeroMQ` library.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO4-2)

For the client, the main object also is an instance of `zmq.Context`.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO4-3)

From here, the code is different; the socket type is set to `SUB`.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO4-4)

This socket connects to the respective IP address and port combination.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO4-5)

This line of code defines the so-called channel to which the socket subscribes. Here, there is only one, but a specification is nevertheless required. In real-world applications, however, you might receive data for a multitude of different symbols via a socket connection.

The `while` loop boils down to the retrieval of the messages sent by the server socket and printing them out:

```
while True:  
    data = socket.recv_string()  
    print(data)  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO5-1)

This socket receives data in an infinite loop.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO5-2)

This is the main line of code where the data (string-based message) is received.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO5-3)

`data` is printed to `stdout`.

The output of the Python script for the socket client is exactly the same as the one from the Python script for the socket server:

```
(base) pro:ch07 yves$ Python TickClient.py
SYMBOL 100.00
SYMBOL 99.65
SYMBOL 99.28
SYMBOL 99.09
SYMBOL 98.76
SYMBOL 98.83
SYMBOL 98.82
SYMBOL 98.92
SYMBOL 98.57
SYMBOL 98.81
SYMBOL 98.79
SYMBOL 98.80
```

Retrieving data in the form of string-based messages via socket communication is only a prerequisite for the very tasks to be accomplished based on the data, like generating trading signals in real time or visualizing the data. This is what the two next sections cover.

`ZeroMQ` allows the transmission of other object types, as well. For example, there is an option to send a Python object via a socket. To this end, the object is, by default, serialized and deserialized with `pickle`. The respective methods to accomplish this are `.send_pyobj()` and `.recv_pyobj()` (see [The PyZMQ API](https://oreil.ly/ok2kc)). In practice, however, platforms and data providers cater to a diverse set of environments, with Python being only one out of many languages. Therefore, string-based socket communication is often used, for example, in combination with standard data formats such as `JSON`.

## Signal Generation in Real Time

An _online algorithm_ is an algorithm based on data that is received incrementally (bit by bit) over time. Such an algorithm only knows the current and previous states of relevant variables and parameters, but nothing about the future. This is a realistic setting for financial trading algorithms for which any element of (perfect) foresight is to be excluded. By contrast, an _offline algorithm_ knows the complete data set from the beginning. Many algorithms in computer science fall into the category of offline algorithms, such as a sorting algorithm over a list of numbers.

To generate signals in real time on the basis of an online algorithm, data needs to be collected and processed over time. Consider, for example, a trading strategy based on the time series momentum of the last three five-second intervals (see [Chapter 4](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch04.html#vectorized\_backtesting)). Tick data needs to be collected and then resampled, and the momentum needs to be calculated based on the resampled data set. When time passes by, a continuous, incremental updating takes place. [“Momentum Online Algorithm”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#py\_online\_algorithm) presents a Python script that implements the momentum strategy, as described previously as an online algorithm. Technically, there are two major parts in addition to handling the socket communication. First are the retrieval and storage of the tick data:

```
df = pd.DataFrame()  
mom = 3  
min_length = mom + 1  

while True:
    data = socket.recv_string()  
    t = datetime.datetime.now()  
    sym, value = data.split()  
    df = df.append(pd.DataFrame({sym: float(value)}, index=[t]))  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO6-1)

Instantiates an empty `pandas` `DataFrame` to collect the tick data.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO6-2)

Defines the number of time intervals for the momentum calculation.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO6-3)

Specifies the (initial) minimum length for the signal generation to be triggered.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO6-4)

The retrieval of the tick data via the socket connection.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO6-5)

A timestamp is generated for the data retrieval.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO6-6)

The string-based message is split into the symbol and the numerical value (still a `str` object here).

[![7](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/7.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO6-7)

This line of code first generates a temporary `DataFrame` object with the new data and then appends it to the existing `DataFrame` object.

Second is the resampling and processing of the data, as shown in the following Python code. This happens based on the tick data collected up to a certain point in time. During this step, log returns are calculated based on the resampled data and the momentum is derived. The sign of the momentum defines the positioning to be taken in the financial instrument:

```
    dr = df.resample('5s', label='right').last()  
    dr['returns'] = np.log(dr / dr.shift(1))  
    if len(dr) > min_length:
        min_length += 1  
        dr['momentum'] = np.sign(dr['returns'].rolling(mom).mean())  
        print('\n' + '=' * 51)
        print('NEW SIGNAL | {}'.format(datetime.datetime.now()))
        print('=' * 51)
        print(dr.iloc[:-1].tail())  
        if dr['momentum'].iloc[-2] == 1.0:  
            print('\nLong market position.')
            # take some action (e.g., place buy order)
        elif dr['momentum'].iloc[-2] == -1.0:  
            print('\nShort market position.')
            # take some action (e.g., place sell order)
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO7-1)

The tick data is resampled to a five-second interval, taking the last available tick value as the relevant one.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO7-2)

This calculates the log returns over the five-second intervals.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO7-3)

This increases the minimum length of the resampled `DataFrame` object by one.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO7-4)

The momentum and, based on its sign, the positioning are derived given the log returns from three resampled time intervals.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO7-5)

This prints the final five rows of the resampled `DataFrame` object.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/6.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO7-6)

A momentum value of `1.0` means a long market position. In production, the first signal or a change in the signal then triggers certain actions, like placing an order with the broker. Note that the second but last value of the `momentum` column is used since the last value is based at this stage on incomplete data for the relevant (not yet finished) time interval. Technically, this is due to using the `pandas` `.resample()` method with the `label='right'` parametrization.

[![7](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/7.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO7-7)

Similarly, a momentum value of `-1.0` implies a short market position and potentially certain actions that might be triggered, such as a sell order with a broker. Again, the second but last value from the `momentum` column is used.

When the script is executed, it takes some time, depending on the very parameters chosen, until there is enough (resampled) data available to generate the first signal.

Here is an intermediate example output of the online trading algorithm script:

```
(base) yves@pro ch07 $ python OnlineAlgorithm.py

===================================================
NEW SIGNAL | 2020-05-23 11:33:31.233606
===================================================
                     SYMBOL  ...  momentum
2020-05-23 11:33:15   98.65  ...       NaN
2020-05-23 11:33:20   98.53  ...       NaN
2020-05-23 11:33:25   98.83  ...       NaN
2020-05-23 11:33:30   99.33  ...       1.0

[4 rows x 3 columns]

Long market position.

===================================================
NEW SIGNAL | 2020-05-23 11:33:36.185453
===================================================
                     SYMBOL  ...  momentum
2020-05-23 11:33:15   98.65  ...       NaN
2020-05-23 11:33:20   98.53  ...       NaN
2020-05-23 11:33:25   98.83  ...       NaN
2020-05-23 11:33:30   99.33  ...       1.0
2020-05-23 11:33:35   97.76  ...      -1.0

[5 rows x 3 columns]

Short market position.

===================================================
NEW SIGNAL | 2020-05-23 11:33:40.077869
===================================================
                     SYMBOL  ...  momentum
2020-05-23 11:33:20   98.53  ...       NaN
2020-05-23 11:33:25   98.83  ...       NaN
2020-05-23 11:33:30   99.33  ...       1.0
2020-05-23 11:33:35   97.76  ...      -1.0
2020-05-23 11:33:40   98.51  ...      -1.0

[5 rows x 3 columns]

Short market position.
```

It is a good exercise to implement, based on the presented tick client script, both an SMA-based strategy and a mean-reversion strategy as an online algorithm.

## Visualizing Streaming Data with Plotly

The visualization of streaming data in real time is generally a demanding task. Fortunately, there are quite a few technologies and Python packages available nowadays that significantly simplify such a task. In what follows, we will work with [Plotly](http://plot.ly/), which is both a technology and a service used to generate nice looking, interactive plots for static and streaming data. To follow along, the `plotly` package needs to be installed. Also, several Jupyter Lab extensions need to be installed when working with Jupyter Lab. The following command should be executed on the terminal:

```
conda install plotly ipywidgets
jupyter labextension install jupyterlab-plotly
jupyter labextension install @jupyter-widgets/jupyterlab-manager
jupyter labextension install plotlywidget
```

### The Basics

Once the required packages and extension are installed, the generation of a streaming plot is quite efficient. The first step is the creation of a Plotly figure widget:

```
In [1]: import zmq
        from datetime import datetime
        import plotly.graph_objects as go  

In [2]: symbol = 'SYMBOL'

In [3]: fig = go.FigureWidget()  
        fig.add_scatter()  
        fig  
Out[3]: FigureWidget({
       'data': [{'type': 'scatter', 'uid':
        'e1a65f25-287d-4021-a210-c2f41f32426a'}], 'layout': {'t…
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO8-1)

This imports the graphical objects from `plotly`.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO8-2)

This instantiates a Plotly figure widget within the Jupyter Notebook.

The second step is to set up the socket communication with the sample tick data server, which needs to run on the same machine in a separate Python process. The incoming data is enriched by a timestamp and collected in `list` objects. These `list` objects in turn are used to update the `data` objects of the figure widget (see [Figure 7-1](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#plotly\_stream\_01)):

```
In [4]: context = zmq.Context()

In [5]: socket = context.socket(zmq.SUB)

In [6]: socket.connect('tcp://0.0.0.0:5555')

In [7]: socket.setsockopt_string(zmq.SUBSCRIBE, 'SYMBOL')

In [8]: times = list()  
        prices = list()  

In [9]: for _ in range(50):
            msg = socket.recv_string()
            t = datetime.now()  
            times.append(t)  
            _, price = msg.split()
            prices.append(float(price))
            fig.data[0].x = times  
            fig.data[0].y = prices  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO9-1)

`list` object for the timestamps.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO9-2)

`list` object for the real-time prices.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO9-3)

Generates a timestamp and appends it.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO9-5)

Updates the `data` object with the amended `x` (`times`) and `y` (`prices`) data sets.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_0701.png" alt="pfat 0701" height="302" width="568"><figcaption></figcaption></figure>

**Figure 7-1. Plot of streaming price data, as retrieved in real time via socket connection**

### Three Real-Time Streams

A streaming plot with Plotly can have multiple graph objects. This comes in handy when, for instance, two simple moving averages (SMAs) shall be visualized in real time in addition to the price ticks. The following code instantiates again a figure widget—this time with three `scatter` objects. The tick data from the sample tick data server is collected in a `pandas` `DataFrame` object. The two SMAs are calculated after each update from the socket. The amended data sets are used to update the `data` object of the figure widget (see [Figure 7-2](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#plotly\_stream\_02)):

```
In [10]: fig = go.FigureWidget()
         fig.add_scatter(name='SYMBOL')
         fig.add_scatter(name='SMA1', line=dict(width=1, dash='dot'),
                         mode='lines+markers')
         fig.add_scatter(name='SMA2', line=dict(width=1, dash='dash'),
                         mode='lines+markers')
         fig
Out[10]: FigureWidget({
        'data': [{'name': 'SYMBOL', 'type': 'scatter', 'uid':
        'bcf83157-f015-411b-a834-d5fd6ac509ba…

In [11]: import pandas as pd

In [12]: df = pd.DataFrame()  

In [13]: for _ in range(75):
             msg = socket.recv_string()
             t = datetime.now()
             sym, price = msg.split()
             df = df.append(pd.DataFrame({sym: float(price)}, index=[t]))  
             df['SMA1'] = df[sym].rolling(5).mean()  
             df['SMA2'] = df[sym].rolling(10).mean()  
             fig.data[0].x = df.index
             fig.data[1].x = df.index
             fig.data[2].x = df.index
             fig.data[0].y = df[sym]
             fig.data[1].y = df['SMA1']
             fig.data[2].y = df['SMA2']
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO10-1)

Collects the tick data in a `DataFrame` object.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO10-3)

Adds the two SMAs in separate columns to the `DataFrame` object.

Again, it is a good exercise to combine the plotting of streaming tick data and the two SMAs with the implementation of an online trading algorithm based on the two SMAs. In this case, resampling should be added to the implementation since such trading algorithms are hardly ever based on tick data but rather on bars of fixed length (five seconds, one minute, etc.).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_0702.png" alt="pfat 0702" height="302" width="626"><figcaption></figcaption></figure>

**Figure 7-2. Plot of streaming price data and two SMAs calculated in real time**

### Three Sub-Plots for Three Streams

As with conventional Plotly plots, streaming plots based on figure widgets can also have multiple sub-plots. The example that follows creates a streaming plot with three sub-plots. The first plots the real-time tick data. The second plots the log returns data. The third plots the time series momentum based on the log returns data. [Figure 7-3](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#plotly\_stream\_03) shows a snapshot of the whole figure object:

```
In [14]: from plotly.subplots import make_subplots

In [15]: f = make_subplots(rows=3, cols=1, shared_xaxes=True)  
         f.append_trace(go.Scatter(name='SYMBOL'), row=1, col=1)  
         f.append_trace(go.Scatter(name='RETURN', line=dict(width=1, dash='dot'),
                  mode='lines+markers', marker={'symbol': 'triangle-up'}),
                  row=2, col=1)  
         f.append_trace(go.Scatter(name='MOMENTUM', line=dict(width=1, dash='dash'),
                  mode='lines+markers', marker={'symbol': 'x'}), row=3, col=1)  
         # f.update_layout(height=600)  

In [16]: fig = go.FigureWidget(f)

In [17]: fig
Out[17]: FigureWidget({
           'data': [{'name': 'SYMBOL',
                     'type': 'scatter',
                     'uid': 'c8db0cac…

In [18]: import numpy as np

In [19]: df = pd.DataFrame()

In [20]: for _ in range(75):
             msg = socket.recv_string()
             t = datetime.now()
             sym, price = msg.split()
             df = df.append(pd.DataFrame({sym: float(price)}, index=[t]))
             df['RET'] = np.log(df[sym] / df[sym].shift(1))
             df['MOM'] = df['RET'].rolling(10).mean()
             fig.data[0].x = df.index
             fig.data[1].x = df.index
             fig.data[2].x = df.index
             fig.data[0].y = df[sym]
             fig.data[1].y = df['RET']
             fig.data[2].y = df['MOM']
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/1.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO11-1)

Creates three sub-plots that share the x-axis.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/2.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO11-2)

Creates the first sub-plot for the price data.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/3.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO11-3)

Creates the second sub-plot for the log returns data.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/4.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO11-4)

Creates the third sub-plot for the momentum data.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/5.png)](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#co\_working\_with\_real\_time\_data\_and\_sockets\_CO11-5)

Adjusts the height of the figure object.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_0703.png" alt="pfat 0703" height="302" width="647"><figcaption></figcaption></figure>

**Figure 7-3. Streaming price data, log returns, and momentum in different sub-plots**

### Streaming Data as Bars

Not all streaming data is best visualized as a time series (`Scatter` object). Some streaming data is better visualized as bars with changing height. [“Sample Data Server for Bar Plot”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#py\_bars\_server) contains a Python script that serves sample data suited for a bar-based visualization. A single data set (message) consists of eight floating point numbers. The following Python code generates a streaming bar plot (see [Figure 7-4](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#plotly\_stream\_04)). In this context, the x data usually does not change. For the following code to work, the `BarsServer.py` script needs to be executed in a separate, local Python instance:

```
In [21]: socket = context.socket(zmq.SUB)

In [22]: socket.connect('tcp://0.0.0.0:5556')

In [23]: socket.setsockopt_string(zmq.SUBSCRIBE, '')

In [24]: for _ in range(5):
             msg = socket.recv_string()
             print(msg)
         60.361 53.504 67.782 64.165 35.046 94.227 20.221 54.716
         79.508 48.210 84.163 73.430 53.288 38.673 4.962 78.920
         53.316 80.139 73.733 55.549 21.015 20.556 49.090 29.630
         86.664 93.919 33.762 82.095 3.108 92.122 84.194 36.666
         37.192 85.305 48.397 36.903 81.835 98.691 61.818 87.121

In [25]: fig = go.FigureWidget()
         fig.add_bar()
         fig
Out[25]: FigureWidget({
        'data': [{'type': 'bar', 'uid':
        '51c6069f-4924-458d-a1ae-c5b5b5f3b07f'}], 'layout': {'templ…

In [26]: x = list('abcdefgh')
         fig.data[0].x = x
         for _ in range(25):
             msg = socket.recv_string()
             y = msg.split()
             y = [float(n) for n in y]
             fig.data[0].y = y
```

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492053347/files/assets/pfat_0704.png" alt="pfat 0704" height="286" width="563"><figcaption></figcaption></figure>

**Figure 7-4. Streaming data as bars with changing height**

## Conclusions

Nowadays, algorithmic trading has to deal with different types of streaming (real-time) data types. The most important type in this regard is tick data for financial instruments that is, in principle, generated and published around the clock.[2](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#idm45785354874120) Sockets are the technological tool of choice to deal with streaming data. A powerful and at the same time easy-to-use library in this regard is `ZeroMQ`, which is used in this chapter to create a simple tick data server that endlessly emits sample tick data.

Different tick data clients are introduced and explained to generate trading signals in real time based on online algorithms and to visualize the incoming tick data by streaming plots using Plotly. Plotly makes streaming visualization within a Jupyter Notebook an efficient affair, allowing for, among other things, multiple streams at the same time—both in a single plot or in different sub-plots.

Based on the topics covered in this chapter and the previous ones, you are now able to work with both _historical structured data_ (for example, in the context of the backtesting of trading strategies) and _real-time streaming data_ (for example, in the context of generating trading signals in real time). This represents a major milestone in the endeavor to build an automated, algorithmic trading operation.

## References and Further Resources

The best starting point for a thorough overview of `ZeroMQ` is the [ZeroMQ home page](http://zeromq.org/). The [Learning ZeroMQ with Python](https://bit.ly/zmq\_pub\_sub) tutorial page provides an overview of the `PUB-SUB` pattern based on the Python wrapper for the socket communication library.

A good place to start working with Plotly is the [Plotly home page](http://plot.ly/) and in particular the [Getting Started with Plotly page](https://oreil.ly/7ARrQ) for Python.

## Python Scripts

This section presents Python scripts referenced and used in this chapter.

### Sample Tick Data Server

The following is a script that runs a sample tick data server based on `ZeroMQ`. It makes use of Monte Carlo simulation for the geometric Brownian motion:

```
#
# Python Script to Simulate a
# Financial Tick Data Server
#
# Python for Algorithmic Trading
# (c) Dr. Yves J. Hilpisch
# The Python Quants GmbH
#
import zmq
import math
import time
import random

context = zmq.Context()
socket = context.socket(zmq.PUB)
socket.bind('tcp://0.0.0.0:5555')


class InstrumentPrice(object):
    def __init__(self):
        self.symbol = 'SYMBOL'
        self.t = time.time()
        self.value = 100.
        self.sigma = 0.4
        self.r = 0.01

    def simulate_value(self):
        ''' Generates a new, random stock price.
        '''
        t = time.time()
        dt = (t - self.t) / (252 * 8 * 60 * 60)
        dt *= 500
        self.t = t
        self.value *= math.exp((self.r - 0.5 * self.sigma ** 2) * dt +
                               self.sigma * math.sqrt(dt) * random.gauss(0, 1))
        return self.value


ip = InstrumentPrice()

while True:
    msg = '{} {:.2f}'.format(ip.symbol, ip.simulate_value())
    print(msg)
    socket.send_string(msg)
    time.sleep(random.random() * 2)
```

### Tick Data Client

The following is a script that runs a tick data client based on `ZeroMQ`. It connects to the tick data server from [“Sample Tick Data Server”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#py\_tick\_server):

```
#
# Python Script
# with Tick Data Client
#
# Python for Algorithmic Trading
# (c) Dr. Yves J. Hilpisch
# The Python Quants GmbH
#
import zmq

context = zmq.Context()
socket = context.socket(zmq.SUB)
socket.connect('tcp://0.0.0.0:5555')
socket.setsockopt_string(zmq.SUBSCRIBE, 'SYMBOL')

while True:
    data = socket.recv_string()
    print(data)
```

### Momentum Online Algorithm

The following is a script that implements a trading strategy based on time series momentum as an online algorithm. It connects to the tick data server from [“Sample Tick Data Server”](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#py\_tick\_server):

```
#
# Python Script
# with Online Trading Algorithm
#
# Python for Algorithmic Trading
# (c) Dr. Yves J. Hilpisch
# The Python Quants GmbH
#
import zmq
import datetime
import numpy as np
import pandas as pd

context = zmq.Context()
socket = context.socket(zmq.SUB)
socket.connect('tcp://0.0.0.0:5555')
socket.setsockopt_string(zmq.SUBSCRIBE, 'SYMBOL')

df = pd.DataFrame()
mom = 3
min_length = mom + 1

while True:
    data = socket.recv_string()
    t = datetime.datetime.now()
    sym, value = data.split()
    df = df.append(pd.DataFrame({sym: float(value)}, index=[t]))
    dr = df.resample('5s', label='right').last()
    dr['returns'] = np.log(dr / dr.shift(1))
    if len(dr) > min_length:
        min_length += 1
        dr['momentum'] = np.sign(dr['returns'].rolling(mom).mean())
        print('\n' + '=' * 51)
        print('NEW SIGNAL | {}'.format(datetime.datetime.now()))
        print('=' * 51)
        print(dr.iloc[:-1].tail())
        if dr['momentum'].iloc[-2] == 1.0:
            print('\nLong market position.')
            # take some action (e.g., place buy order)
        elif dr['momentum'].iloc[-2] == -1.0:
            print('\nShort market position.')
            # take some action (e.g., place sell order)
```

### Sample Data Server for Bar Plot

The following is a Python script that generates sample data for a streaming bar plot:

```
#
# Python Script to Serve
# Random Bars Data
#
# Python for Algorithmic Trading
# (c) Dr. Yves J. Hilpisch
# The Python Quants GmbH
#
import zmq
import math
import time
import random

context = zmq.Context()
socket = context.socket(zmq.PUB)
socket.bind('tcp://0.0.0.0:5556')

while True:
    bars = [random.random() * 100 for _ in range(8)]
    msg = ' '.join([f'{bar:.3f}' for bar in bars])
    print(msg)
    socket.send_string(msg)
    time.sleep(random.random() * 2)
```

[1](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#idm45785358164968-marker) When speaking of _simultaneously_ or _at the same time_, this is meant in a theoretical, idealized sense. In practical applications, different distances between the sending and receiving sockets, network speeds, and other factors affect the exact retrieval time per subscriber socket.

[2](https://learning.oreilly.com/library/view/python-for-algorithmic/9781492053347/ch07.html#idm45785354874120-marker) Not all markets are open 24 hours, 7 days per week, and for sure not all financial instruments are traded around the clock. However, cryptocurrency markets, for example, for Bitcoin, indeed operate around the clock, constantly creating new data that needs to be digested in real-time by players active in these markets.
