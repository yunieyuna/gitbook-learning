# 12. Execution and Deployment

## Chapter 12. Execution and Deployment

> Considerable progress is needed before autonomous vehicles can operate reliably in mixed urban traffic, heavy rain and snow, unpaved and unmapped roads, and where wireless access is unreliable.
>
> Todd Litman (2020)

> An investment firm that engages in algorithmic trading shall have in place effective systems and risk controls suitable to the business it operates to ensure that its trading systems are resilient and have sufficient capacity, are subject to appropriate trading thresholds and limits and prevent the sending of erroneous orders or the systems otherwise functioning in a way that may create or contribute to a disorderly market.
>
> MiFID II (Article 17)

[Chapter 11](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch11.html#risk\_management) trains a trading bot in the form of a financial Q-learning agent based on historical data. It introduces event-based backtesting as an approach flexible enough to account for typical risk measures, such as trailing stop loss orders or take profit targets. However, all this happens asynchronously in a sandbox environment based on historical data only. As with an autonomous vehicle (AV), there is the problem of deploying the AI in the real world. For an AV this means combining the AI with the car hardware and deploying the AV on test and public streets. For a trading bot this means connecting the trading bot with a trading platform and deploying it such that orders are executed automatically. In other words, the algorithmic side is clear—execution and deployment now need to be added to implement algorithmic trading.

This chapter introduces the [Oanda](http://oanda.com/) trading platform for algorithmic trading. Therefore, the focus is on the [v20 API](https://oreil.ly/TbGKN) of the platform and not on applications that provide users with an interface for manual trading. To simplify the code, the wrapper package [`tpqoa`](https://oreil.ly/72pWe) is introduced and used. It relies on the [`v20`](https://oreil.ly/H\_pIj) Python package from Oanda and provides a more Pythonic user interface.

[“Oanda Account”](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#ed\_account) details the prerequisites to use a _demo account_ with Oanda. [“Data Retrieval”](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#ed\_data\_retrieval) shows how to retrieve historical and real-time (streaming) data from the API. [“Order Execution”](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#ed\_execution) deals with the execution of buy and sell orders, potentially including other orders, such as trailing stop loss orders. [“Trading Bot”](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#ed\_trading\_bot) trains a trading bot based on historical intraday data from Oanda and backtests its performance in vectorized fashion. Finally, [“Deployment”](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#ed\_deployment) shows how to deploy the trading bot in real-time and an automated fashion.

## Oanda Account

The code in this chapter relies on the Python wrapper package [`tpqoa`](https://oreil.ly/72pWe). This package can be installed via `pip` as follows:

```
pip install --upgrade git+https://github.com/yhilpisch/tpqoa.git
```

To make use of this package, a demo account with [Oanda](http://oanda.com/) is sufficient. Once the account is open, an _access token_ is generated on the account page (after login). The access token and the _account id_ (also found on the account page) are then stored in a configuration text file as follows:

```
[oanda]
account_id = XYZ-ABC-...
access_token = ZYXCAB...
account_type = practice
```

If the name of the configuration file is _aiif.cfg_ and if it is stored in the current working directory, then the `tpqoa` package can be used as follows:

```
import tpqoa
api = tpqoa.tpqoa('aiif.cfg')
```

## RISK DISCLAIMERS AND DISCLOSURES

Oanda is a platform for _foreign exchange_ (FX) and _contracts for difference_ (CFD) trading. These instruments involve considerable risks, in particular when traded with leverage. It is strongly recommended that you read all relevant risk disclaimers and disclosures from Oanda on its [website](http://oanda.com/) carefully before moving on (check for the appropriate jurisdiction).

All code and examples presented in this chapter are for technical illustration only and do not constitute any investment advice or similar.

## Data Retrieval

As usual, some Python imports and configurations come first:

```
In [1]: import os
        import time
        import numpy as np
        import pandas as pd
        from pprint import pprint
        from pylab import plt, mpl
        plt.style.use('seaborn')
        mpl.rcParams['savefig.dpi'] = 300
        mpl.rcParams['font.family'] = 'serif'
        pd.set_option('mode.chained_assignment', None)
        pd.set_option('display.float_format', '{:.5f}'.format)
        np.set_printoptions(suppress=True, precision=4)
        os.environ['PYTHONHASHSEED'] = '0'
```

Depending on the relevant jurisdiction of the account, Oanda offers a number of tradable FX and CFD instruments. The following Python code retrieves the available instruments for a given account:

```
In [2]: import tpqoa  

In [3]: api = tpqoa.tpqoa('../aiif.cfg')  

In [4]: ins = api.get_instruments()  

In [5]: ins[:5]  
Out[5]: [('AUD/CAD', 'AUD_CAD'),
         ('AUD/CHF', 'AUD_CHF'),
         ('AUD/HKD', 'AUD_HKD'),
         ('AUD/JPY', 'AUD_JPY'),
         ('AUD/NZD', 'AUD_NZD')]
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO1-1)

Imports the `tpqoa` package

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO1-2)

Instantiates an API object given the account credentials

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/3.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO1-3)

Retrieves the list of available instruments in the format `(display_name,` `technical_name)`

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/4.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO1-4)

Shows a select few of these instruments

Oanda provides a wealth of historical data via its v20 API. The following examples retrieve historical data for the EUR/USD currency pair—the granularity is set to `D` (that is, _daily_).

[Figure 12-1](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#figure\_ed\_01) plots the closing (ask) prices:

```
In [6]: raw = api.get_history(instrument='EUR_USD',  
                              start='2018-01-01',  
                              end='2020-07-31',  
                              granularity='D',  
                              price='A')  

In [7]: raw.info()
        <class 'pandas.core.frame.DataFrame'>
        DatetimeIndex: 671 entries, 2018-01-01 22:00:00 to 2020-07-30 21:00:00
        Data columns (total 6 columns):
         #   Column    Non-Null Count  Dtype
        ---  ------    --------------  -----
         0   o         671 non-null    float64
         1   h         671 non-null    float64
         2   l         671 non-null    float64
         3   c         671 non-null    float64
         4   volume    671 non-null    int64
         5   complete  671 non-null    bool
        dtypes: bool(1), float64(4), int64(1)
        memory usage: 32.1 KB

In [8]: raw.head()
Out[8]:                           o       h       l       c  volume  complete
        time
        2018-01-01 22:00:00 1.20101 1.20819 1.20051 1.20610   35630      True
        2018-01-02 22:00:00 1.20620 1.20673 1.20018 1.20170   31354      True
        2018-01-03 22:00:00 1.20170 1.20897 1.20049 1.20710   35187      True
        2018-01-04 22:00:00 1.20692 1.20847 1.20215 1.20327   36478      True
        2018-01-07 22:00:00 1.20301 1.20530 1.19564 1.19717   27618      True

In [9]: raw['c'].plot(figsize=(10, 6));
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO2-1)

Specifies the instrument…

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO2-2)

…the starting date…

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/3.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO2-3)

…the end date…

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/4.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO2-4)

…the granularity (`D` = daily)…

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/5.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO2-5)

…and the type of the price series (`A` = ask)

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/aiif_1201.png" alt="aiif 1201" height="1427" width="2468"><figcaption></figcaption></figure>

**Figure 12-1. Historical daily closing prices for EUR/USD from Oanda**

Intraday data is as easily retrieved and used as daily data, as the code that follows shows. [Figure 12-2](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#figure\_ed\_02) visualizes minute bar (mid) price data:

```
In [10]: raw = api.get_history(instrument='EUR_USD',
                               start='2020-07-01',
                               end='2020-07-31',
                               granularity='M1',  
                               price='M')   

In [11]: raw.info()
         <class 'pandas.core.frame.DataFrame'>
         DatetimeIndex: 30728 entries, 2020-07-01 00:00:00 to 2020-07-30 23:59:00
         Data columns (total 6 columns):
          #   Column    Non-Null Count  Dtype
         ---  ------    --------------  -----
          0   o         30728 non-null  float64
          1   h         30728 non-null  float64
          2   l         30728 non-null  float64
          3   c         30728 non-null  float64
          4   volume    30728 non-null  int64
          5   complete  30728 non-null  bool
         dtypes: bool(1), float64(4), int64(1)
         memory usage: 1.4 MB

In [12]: raw.tail()
Out[12]:                           o       h       l       c  volume  complete
         time
         2020-07-30 23:55:00 1.18724 1.18739 1.18718 1.18738      57      True
         2020-07-30 23:56:00 1.18736 1.18758 1.18722 1.18757      57      True
         2020-07-30 23:57:00 1.18756 1.18756 1.18734 1.18734      49      True
         2020-07-30 23:58:00 1.18736 1.18737 1.18713 1.18717      36      True
         2020-07-30 23:59:00 1.18718 1.18724 1.18714 1.18722      31      True

In [13]: raw['c'].plot(figsize=(10, 6));
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO3-1)

Specifies the granularity (`M1` = one minute)…

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO3-2)

…and the type of the price series (`M` = mid)

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/aiif_1202.png" alt="aiif 1202" height="1460" width="2444"><figcaption></figcaption></figure>

**Figure 12-2. Historical one-minute bar closing prices for EUR/USD from Oanda**

Whereas historical data is important, for instance, to train and test a trading bot, real-time (streaming) data is required to deploy such a bot for algorithmic trading. `tpqoa` allows the synchronous streaming of real-time data for all available instruments with a single method call. The method prints by default the time stamp and the bid/ask prices. For algorithmic trading, this default behavior can be adjusted, as [“Deployment”](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#ed\_deployment) shows:

```
In [14]: api.stream_data('EUR_USD', stop=10)
         2020-08-13T12:07:09.735715316Z 1.18328 1.18342
         2020-08-13T12:07:16.245253689Z 1.18329 1.18343
         2020-08-13T12:07:16.397803785Z 1.18328 1.18342
         2020-08-13T12:07:17.240232521Z 1.18331 1.18346
         2020-08-13T12:07:17.358476854Z 1.18334 1.18348
         2020-08-13T12:07:17.778061207Z 1.18331 1.18345
         2020-08-13T12:07:18.016544856Z 1.18333 1.18346
         2020-08-13T12:07:18.144762415Z 1.18334 1.18348
         2020-08-13T12:07:18.689365678Z 1.18331 1.18345
         2020-08-13T12:07:19.148039139Z 1.18331 1.18345
```

## Order Execution

The AI of an AV needs to be able to control the physical vehicle. To this end it sends different types of signals to the vehicle, for example, to accelerate, break, turn left, or turn right. A trading bot needs to be able to place orders with the trading platform. This section covers different types of orders, such as market orders and stop loss orders.

The most fundamental type of order is a _market order_. This order allows buying or selling a financial instrument at the current market price (that is, the _ask price_ when buying and the _bid price_ when selling). The following examples are based on an account leverage of 20 and relatively small order sizes. Therefore, liquidity issues, for example, do not play a role. When executing orders via the Oanda v20 API, the API returns a detailed order object. First, a _buy market order_ is placed:

```
In [15]: order = api.create_order('EUR_USD', units=25000,
                                  suppress=True, ret=True)  
         pprint(order)  
         {'accountBalance': '98553.3172',
          'accountID': '101-004-13834683-001',
          'batchID': '1625',
          'commission': '0.0',
          'financing': '0.0',
          'fullPrice': {'asks': [{'liquidity': '10000000', 'price': 1.18345}],
                        'bids': [{'liquidity': '10000000', 'price': 1.18331}],
                        'closeoutAsk': 1.18345,
                        'closeoutBid': 1.18331,
                        'type': 'PRICE'},
          'fullVWAP': 1.18345,
          'gainQuoteHomeConversionFactor': '0.840811914585',
          'guaranteedExecutionFee': '0.0',
          'halfSpreadCost': '1.4788',
          'id': '1626',
          'instrument': 'EUR_USD',
          'lossQuoteHomeConversionFactor': '0.849262285586',
          'orderID': '1625',
          'pl': '0.0',
          'price': 1.18345,
          'reason': 'MARKET_ORDER',
          'requestID': '78757241547812154',
          'time': '2020-08-13T12:07:19.434407966Z',
          'tradeOpened': {'guaranteedExecutionFee': '0.0',
                          'halfSpreadCost': '1.4788',
                          'initialMarginRequired': '832.5',
                          'price': 1.18345,
                          'tradeID': '1626',
                          'units': '25000.0'},
          'type': 'ORDER_FILL',
          'units': '25000.0',
          'userID': 13834683}

In [16]: def print_details(order):  
             details = (order['time'][:-7], order['instrument'], order['units'],
                        order['price'], order['pl'])
             return details

In [17]: print_details(order)  
Out[17]: ('2020-08-13T12:07:19.434', 'EUR_USD', '25000.0', 1.18345, '0.0')

In [18]: time.sleep(1)
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO4-1)

Places a _buy market order_ and prints the order object details

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO4-3)

Selects and shows the `time`, `instrument`, `units`, `price`, and `pl` details of the order

Second, the position is closed via a _sell market order_ of the same size. Whereas the first trade has a profit/loss (P\&L) of zero by its nature—before accounting for transaction costs—the second trade in general has a nonzero P\&L:

```
In [19]: order = api.create_order('EUR_USD', units=-25000,
                                  suppress=True, ret=True)  
         pprint(order)  
         {'accountBalance': '98549.283',
          'accountID': '101-004-13834683-001',
          'batchID': '1627',
          'commission': '0.0',
          'financing': '0.0',
          'fullPrice': {'asks': [{'liquidity': '9975000', 'price': 1.18339}],
                        'bids': [{'liquidity': '10000000', 'price': 1.18326}],
                        'closeoutAsk': 1.18339,
                        'closeoutBid': 1.18326,
                        'type': 'PRICE'},
          'fullVWAP': 1.18326,
          'gainQuoteHomeConversionFactor': '0.840850994445',
          'guaranteedExecutionFee': '0.0',
          'halfSpreadCost': '1.3732',
          'id': '1628',
          'instrument': 'EUR_USD',
          'lossQuoteHomeConversionFactor': '0.849301758209',
          'orderID': '1627',
          'pl': '-4.0342',
          'price': 1.18326,
          'reason': 'MARKET_ORDER',
          'requestID': '78757241552009237',
          'time': '2020-08-13T12:07:20.586564454Z',
          'tradesClosed': [{'financing': '0.0',
                            'guaranteedExecutionFee': '0.0',
                            'halfSpreadCost': '1.3732',
                            'price': 1.18326,
                            'realizedPL': '-4.0342',
                            'tradeID': '1626',
                            'units': '-25000.0'}],
          'type': 'ORDER_FILL',
          'units': '-25000.0',
          'userID': 13834683}

In [20]: print_details(order) 
Out[20]: ('2020-08-13T12:07:20.586', 'EUR_USD', '-25000.0', 1.18326, '-4.0342')

In [21]: time.sleep(1)
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO5-1)

Places a _sell market order_ and prints the order object details

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO5-3)

Selects and shows the `time`, `instrument`, `units`, `price`, and `pl` details of the order

## LIMIT ORDERS

This chapter covers _market orders_ as a type of base order only. With a market order, buying or selling a financial instrument happens at the price that is current when the order is placed. By contrast, a _limit order_, as the other main type of base order, allows the placement of an order with a minimum price or a maximum price. Only when the minimum/maximum price is reached is the order executed. Until that point, no transaction takes place.

Next, consider an example for the same combination of trades but this time with a _stop loss_ (SL) order. An SL order is treated as a separate (limit) order. The following Python code places the orders and shows the details of the SL order object:

```
In [22]: order = api.create_order('EUR_USD', units=25000,
                                  sl_distance=0.005,  
                                  suppress=True, ret=True)

In [23]: print_details(order)
Out[23]: ('2020-08-13T12:07:21.740', 'EUR_USD', '25000.0', 1.18343, '0.0')

In [24]: sl_order = api.get_transaction(tid=int(order['id']) + 1)  

In [25]: sl_order  
Out[25]: {'id': '1631',
          'time': '2020-08-13T12:07:21.740825489Z',
          'userID': 13834683,
          'accountID': '101-004-13834683-001',
          'batchID': '1629',
          'requestID': '78757241556206373',
          'type': 'STOP_LOSS_ORDER',
          'tradeID': '1630',
          'price': 1.17843,
          'distance': '0.005',
          'timeInForce': 'GTC',
          'triggerCondition': 'DEFAULT',
          'reason': 'ON_FILL'}

In [26]: (sl_order['time'], sl_order['type'], order['price'],
          sl_order['price'], sl_order['distance'])  
Out[26]: ('2020-08-13T12:07:21.740825489Z',
          'STOP_LOSS_ORDER',
          1.18343,
          1.17843,
          '0.005')

In [27]: time.sleep(1)

In [28]: order = api.create_order('EUR_USD', units=-25000, suppress=True, ret=True)

In [29]: print_details(order)
Out[29]: ('2020-08-13T12:07:23.059', 'EUR_USD', '-25000.0', 1.18329, '-2.9725')
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO6-1)

The SL distance is defined in currency units.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO6-2)

Selects and shows the SL order object data.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/3.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO6-4)

Selects and shows some relevant details of the two order objects.

A _trailing stop loss_ (TSL) order is handled in the same way. The only difference is that there is no fixed price attached to a TSL order:

```
In [30]: order = api.create_order('EUR_USD', units=25000,
                                  tsl_distance=0.005,  
                                  suppress=True, ret=True)

In [31]: print_details(order)
Out[31]: ('2020-08-13T12:07:23.204', 'EUR_USD', '25000.0', 1.18341, '0.0')

In [32]: tsl_order = api.get_transaction(tid=int(order['id']) + 1)  

In [33]: tsl_order  
Out[33]: {'id': '1637',
          'time': '2020-08-13T12:07:23.204457044Z',
          'userID': 13834683,
          'accountID': '101-004-13834683-001',
          'batchID': '1635',
          'requestID': '78757241564598562',
          'type': 'TRAILING_STOP_LOSS_ORDER',
          'tradeID': '1636',
          'distance': '0.005',
          'timeInForce': 'GTC',
          'triggerCondition': 'DEFAULT',
          'reason': 'ON_FILL'}

In [34]: (tsl_order['time'][:-7], tsl_order['type'],
          order['price'], tsl_order['distance'])  
Out[34]: ('2020-08-13T12:07:23.204', 'TRAILING_STOP_LOSS_ORDER', 1.18341, '0.005')

In [35]: time.sleep(1)

In [36]: order = api.create_order('EUR_USD', units=-25000,
                                  suppress=True, ret=True)

In [37]: print_details(order)
Out[37]: ('2020-08-13T12:07:24.551', 'EUR_USD', '-25000.0', 1.1833, '-2.3355')

In [38]: time.sleep(1)
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO7-1)

The TSL distance is defined in currency units.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO7-2)

Selects and shows the TSL order object data.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/3.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO7-4)

Selects and shows some relevant details of the two order objects.

Finally, here is a _take profit_ (TP) order. This order requires a fixed TP target price. Therefore, the following code uses the execution price from the previous order to define the TP price in relative terms. Beyond this small difference, the handling is again the same as before:

```
In [39]: tp_price = round(order['price'] + 0.01, 4)
         tp_price
Out[39]: 1.1933

In [40]: order = api.create_order('EUR_USD', units=25000,
                                  tp_price=tp_price,  
                                  suppress=True, ret=True)

In [41]: print_details(order)
Out[41]: ('2020-08-13T12:07:25.712', 'EUR_USD', '25000.0', 1.18344, '0.0')

In [42]: tp_order = api.get_transaction(tid=int(order['id']) + 1)  

In [43]: tp_order  
Out[43]: {'id': '1643',
          'time': '2020-08-13T12:07:25.712531725Z',
          'userID': 13834683,
          'accountID': '101-004-13834683-001',
          'batchID': '1641',
          'requestID': '78757241572993078',
          'type': 'TAKE_PROFIT_ORDER',
          'tradeID': '1642',
          'price': 1.1933,
          'timeInForce': 'GTC',
          'triggerCondition': 'DEFAULT',
          'reason': 'ON_FILL'}

In [44]: (tp_order['time'][:-7], tp_order['type'],
          order['price'], tp_order['price'])  
Out[44]: ('2020-08-13T12:07:25.712', 'TAKE_PROFIT_ORDER', 1.18344, 1.1933)

In [45]: time.sleep(1)

In [46]: order = api.create_order('EUR_USD', units=-25000,
                                  suppress=True, ret=True)

In [47]: print_details(order)
Out[47]: ('2020-08-13T12:07:27.020', 'EUR_USD', '-25000.0', 1.18332, '-2.5478')
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO8-1)

The TP target price is defined relative to the previous execution price.

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO8-2)

Selects and shows the TP order object data.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/3.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO8-4)

Selects and shows some relevant details of the two order objects.

The code so far only deals with transaction details of single orders. However, it is also of interest to have an overview of multiple _historical transactions_. To this end, the following method call provides overview data for all the main orders placed in this section, including P\&L data:

```
In [48]: api.print_transactions(tid=int(order['id']) - 22)
          1626 | 2020-08-13T12:07:19.434407966Z |   EUR_USD |      25000.0 |      0.0
          1628 | 2020-08-13T12:07:20.586564454Z |   EUR_USD |     -25000.0 |  -4.0342
          1630 | 2020-08-13T12:07:21.740825489Z |   EUR_USD |      25000.0 |      0.0
          1633 | 2020-08-13T12:07:23.059178023Z |   EUR_USD |     -25000.0 |  -2.9725
          1636 | 2020-08-13T12:07:23.204457044Z |   EUR_USD |      25000.0 |      0.0
          1639 | 2020-08-13T12:07:24.551026466Z |   EUR_USD |     -25000.0 |  -2.3355
          1642 | 2020-08-13T12:07:25.712531725Z |   EUR_USD |      25000.0 |      0.0
          1645 | 2020-08-13T12:07:27.020414342Z |   EUR_USD |     -25000.0 |  -2.5478
```

Yet another method call provides a snapshot of the _account details_. The details shown are from an Oanda demo account that has been in use for quite some time for technical testing purposes:

```
In [49]: api.get_account_summary()
Out[49]: {'id': '101-004-13834683-001',
          'alias': 'Primary',
          'currency': 'EUR',
          'balance': '98541.4272',
          'createdByUserID': 13834683,
          'createdTime': '2020-03-19T06:08:14.363139403Z',
          'guaranteedStopLossOrderMode': 'DISABLED',
          'pl': '-1248.5543',
          'resettablePL': '-1248.5543',
          'resettablePLTime': '0',
          'financing': '-210.0185',
          'commission': '0.0',
          'guaranteedExecutionFees': '0.0',
          'marginRate': '0.0333',
          'openTradeCount': 1,
          'openPositionCount': 1,
          'pendingOrderCount': 0,
          'hedgingEnabled': False,
          'unrealizedPL': '941.9536',
          'NAV': '99483.3808',
          'marginUsed': '380.83',
          'marginAvailable': '99107.2283',
          'positionValue': '3808.3',
          'marginCloseoutUnrealizedPL': '947.9546',
          'marginCloseoutNAV': '99489.3818',
          'marginCloseoutMarginUsed': '380.83',
          'marginCloseoutPercent': '0.00191',
          'marginCloseoutPositionValue': '3808.3',
          'withdrawalLimit': '98541.4272',
          'marginCallMarginUsed': '380.83',
          'marginCallPercent': '0.00383',
          'lastTransactionID': '1646'}
```

This concludes the discussion of the basics of executing orders with Oanda. All elements are now together to support the deployment of a trading bot. The remainder of this chapter trains a trading bot on Oanda data and deploys it in automated fashion.

## Trading Bot

[Chapter 11](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch11.html#risk\_management) shows in detail how to train a deep Q-learning trading bot and how to backtest it in vectorized and event-based fashion. This section now repeats selected core steps in this regard based on historical data from Oanda. [“Oanda Environment”](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#ed\_oanda\_env) provides a Python module that contains the environment class `OandaEnv` to work with Oanda data. It can be used in the same way as the `Finance` class from [Chapter 11](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch11.html#risk\_management).

The following Python code instantiates the learning environment object. During this step, the major data-related parameters driving the learning, validation, and testing are fixed. The `OandaEnv` class allows the inclusion of leverage, which is typical for FX and CFD trading. Leverage amplifies the realized returns, thereby increasing the profit potential but also the loss risks:

```
In [50]: import oandaenv as oe

In [51]: symbol = 'EUR_USD'

In [52]: date = '2020-08-11'

In [53]: features = [symbol, 'r', 's', 'm', 'v']

In [54]: %%time
         learn_env = oe.OandaEnv(symbol=symbol,
                           start=f'{date} 08:00:00',
                           end=f'{date} 13:00:00',
                           granularity='S30',  
                           price='M',  
                           features=features,  
                           window=20,  
                           lags=3,  
                           leverage=20,  
                           min_accuracy=0.4,  
                           min_performance=0.85  
                          )
         CPU times: user 23.1 ms, sys: 2.86 ms, total: 25.9 ms
         Wall time: 26.8 ms

In [55]: np.bincount(learn_env.data['d'])
Out[55]: array([299, 281])

In [56]: learn_env.data.info()
         <class 'pandas.core.frame.DataFrame'>
         DatetimeIndex: 580 entries, 2020-08-11 08:10:00 to 2020-08-11 12:59:30
         Data columns (total 6 columns):
          #   Column   Non-Null Count  Dtype
         ---  ------   --------------  -----
          0   EUR_USD  580 non-null    float64
          1   r        580 non-null    float64
          2   s        580 non-null    float64
          3   m        580 non-null    float64
          4   v        580 non-null    float64
          5   d        580 non-null    int64
         dtypes: float64(5), int64(1)
         memory usage: 31.7 KB
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO9-1)

Sets the granularity for the data to five seconds

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO9-2)

Sets the price type to mid prices

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/3.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO9-3)

Defines the set of features to be used

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/4.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO9-4)

Defines the window length for rolling statistics

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/5.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO9-5)

Specifies the number of lags

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/6.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO9-6)

Fixes the leverage

[![7](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/7.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO9-7)

Sets the required minimum accuracy

[![8](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/8.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO9-8)

Sets the required minimum performance

In a next step, the validation environment is instantiated, relying on the parameters of the learning environment—apart from the time interval, for obvious reasons. [Figure 12-3](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#figure\_ed\_03) shows the closing prices of EUR/USD as used in the learning, validation, and test environments (from left to right):

```
In [57]: valid_env = oe.OandaEnv(symbol=learn_env.symbol,
                           start=f'{date} 13:00:00',
                           end=f'{date} 14:00:00',
                           granularity=learn_env.granularity,
                           price=learn_env.price,
                           features=learn_env.features,
                           window=learn_env.window,
                           lags=learn_env.lags,
                           leverage=learn_env.leverage,
                           min_accuracy=0,
                           min_performance=0,
                           mu=learn_env.mu,
                           std=learn_env.std
                          )

In [58]: valid_env.data.info()
         <class 'pandas.core.frame.DataFrame'>
         DatetimeIndex: 100 entries, 2020-08-11 13:10:00 to 2020-08-11 13:59:30
         Data columns (total 6 columns):
          #   Column   Non-Null Count  Dtype
         ---  ------   --------------  -----
          0   EUR_USD  100 non-null    float64
          1   r        100 non-null    float64
          2   s        100 non-null    float64
          3   m        100 non-null    float64
          4   v        100 non-null    float64
          5   d        100 non-null    int64
         dtypes: float64(5), int64(1)
         memory usage: 5.5 KB

In [59]: test_env = oe.OandaEnv(symbol=learn_env.symbol,
                           start=f'{date} 14:00:00',
                           end=f'{date} 17:00:00',
                           granularity=learn_env.granularity,
                           price=learn_env.price,
                           features=learn_env.features,
                           window=learn_env.window,
                           lags=learn_env.lags,
                           leverage=learn_env.leverage,
                           min_accuracy=0,
                           min_performance=0,
                           mu=learn_env.mu,
                           std=learn_env.std
                          )

In [60]: test_env.data.info()
         <class 'pandas.core.frame.DataFrame'>
         DatetimeIndex: 340 entries, 2020-08-11 14:10:00 to 2020-08-11 16:59:30
         Data columns (total 6 columns):
          #   Column   Non-Null Count  Dtype
         ---  ------   --------------  -----
          0   EUR_USD  340 non-null    float64
          1   r        340 non-null    float64
          2   s        340 non-null    float64
          3   m        340 non-null    float64
          4   v        340 non-null    float64
          5   d        340 non-null    int64
         dtypes: float64(5), int64(1)
         memory usage: 18.6 KB

In [61]: ax = learn_env.data[learn_env.symbol].plot(figsize=(10, 6))
         plt.axvline(learn_env.data.index[-1], ls='--')
         valid_env.data[learn_env.symbol].plot(ax=ax, style='-.')
         plt.axvline(valid_env.data.index[-1], ls='--')
         test_env.data[learn_env.symbol].plot(ax=ax, style='-.');
```

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/aiif_1203.png" alt="aiif 1203" height="1466" width="2468"><figcaption></figcaption></figure>

**Figure 12-3. Historical 30-second bar closing prices for EUR/USD from Oanda (learning = left, validation = middle, testing = right)**

Based on the Oanda environment, the trading bot from [Chapter 11](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch11.html#risk\_management) can be trained and validated. The following Python code performs this task and visualizes the performance results (see [Figure 12-4](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#figure\_ed\_04)):

```
In [62]: import sys
         sys.path.append('../ch11/')  

In [63]: import tradingbot  
         Using TensorFlow backend.

In [64]: tradingbot.set_seeds(100)
         agent = tradingbot.TradingBot(24, 0.001, learn_env=learn_env,
                                       valid_env=valid_env)  

In [65]: episodes = 31

In [66]: %time agent.learn(episodes)  
         =======================================================================
         episode:  5/31 | VALIDATION | treward:   97 | perf: 1.004 | eps: 0.96
         =======================================================================
         =======================================================================
         episode: 10/31 | VALIDATION | treward:   97 | perf: 1.005 | eps: 0.91
         =======================================================================
         =======================================================================
         episode: 15/31 | VALIDATION | treward:   97 | perf: 0.986 | eps: 0.87
         =======================================================================
         =======================================================================
         episode: 20/31 | VALIDATION | treward:   97 | perf: 1.012 | eps: 0.83
         =======================================================================
         =======================================================================
         episode: 25/31 | VALIDATION | treward:   97 | perf: 0.995 | eps: 0.79
         =======================================================================
         =======================================================================
         episode: 30/31 | VALIDATION | treward:   97 | perf: 0.972 | eps: 0.75
         =======================================================================
         episode: 31/31 | treward:   16 | perf: 0.981 | av: 376.0 | max:  577
         CPU times: user 22.1 s, sys: 1.17 s, total: 23.3 s
         Wall time: 20.1 s

In [67]: tradingbot.plot_performance(agent)  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO10-1)

Imports the `tradingbot` module from [Chapter 11](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch11.html#risk\_management)

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO10-3)

Trains and validates the trading bot based on Oanda data

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/3.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO10-5)

Visualizes the performance results

As discussed in the previous two chapters, the training and validation performances are just an indicator of the trading bot performance.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/aiif_1204.png" alt="aiif 1204" height="1491" width="2510"><figcaption></figcaption></figure>

**Figure 12-4. Training and validation performance results of the trading bot for Oanda data**

The following code implements a vectorized backtest of the trading bot performance for the test environment—again with the same parameters as the learning environment apart from the time interval used. The code makes use of the function `backtest()` as provided in the Python module presented in [“Vectorized Backtesting”](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#ed\_backtest). The reported performance numbers include a leverage of 20. This holds true for both the gross performance of the passive benchmark investment and the trading bot over time, as shown in [Figure 12-5](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#figure\_ed\_05):

```
In [68]: import backtest as bt

In [69]: env = test_env

In [70]: bt.backtest(agent, env)

In [71]: env.data['p'].iloc[env.lags:].value_counts()  
Out[71]:  1    263
         -1     74
         Name: p, dtype: int64

In [72]: sum(env.data['p'].iloc[env.lags:].diff() != 0)  
Out[72]: 25

In [73]: (env.data[['r', 's']].iloc[env.lags:] * env.leverage).sum(
                 ).apply(np.exp)  
Out[73]: r   0.99966
         s   1.05910
         dtype: float64

In [74]: (env.data[['r', 's']].iloc[env.lags:] * env.leverage).sum(
                 ).apply(np.exp) - 1  
Out[74]: r   -0.00034
         s    0.05910
         dtype: float64

In [75]: (env.data[['r', 's']].iloc[env.lags:] * env.leverage).cumsum(
                 ).apply(np.exp).plot(figsize=(10, 6));  
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO11-1)

Shows the total number of long and short positions

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO11-2)

Shows the number of trades required to implement the strategy

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/3.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO11-3)

Calculates the gross performance including leverage

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/4.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO11-4)

Calculates the net performance including leverage

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/5.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO11-5)

Visualizes the gross performance over time including leverage

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/aiif_1205.png" alt="aiif 1205" height="1490" width="2444"><figcaption></figcaption></figure>

**Figure 12-5. Gross performance of the passive benchmark investment and the trading bot over time (including leverage)**

## SIMPLIFIED BACKTESTING

The training and backtesting of the trading bot in this section happen under assumptions that are not realistic. The trading strategy based on the 30-second bars might lead to a large number of trades over a short period of time. Assuming typical transaction costs (bid-ask spreads), such a strategy often is not economically viable. Longer bars or a strategy with fewer trades would be more realistic. However, to allow for a “quick” deployment demo in the next section, the training and backtest are implemented intentionally on the relatively short 30-second bars.

## Deployment

This section combines the major elements of the previous sections to deploy the trained trading bot in automated fashion. This is comparable to the point in time at which an AV is prepared to be deployed on the streets. The class `OandaTradingBot` presented in the following code inherits from the `tpqoa` class and adds some helper functions and the trading logic:

```
In [76]: import tpqoa

In [77]: class OandaTradingBot(tpqoa.tpqoa):
             def __init__(self, config_file, agent, granularity, units,
                          verbose=True):
                 super(OandaTradingBot, self).__init__(config_file)
                 self.agent = agent
                 self.symbol = self.agent.learn_env.symbol
                 self.env = agent.learn_env
                 self.window = self.env.window
                 if granularity is None:
                     self.granularity = agent.learn_env.granularity
                 else:
                     self.granularity = granularity
                 self.units = units
                 self.trades = 0
                 self.position = 0
                 self.tick_data = pd.DataFrame()
                 self.min_length = (self.agent.learn_env.window +
                                    self.agent.learn_env.lags)
                 self.pl = list()
                 self.verbose = verbose
             def _prepare_data(self):
                 self.data['r'] = np.log(self.data / self.data.shift(1))
                 self.data.dropna(inplace=True)
                 self.data['s'] = self.data[self.symbol].rolling(
                                                     self.window).mean()
                 self.data['m'] = self.data['r'].rolling(self.window).mean()
                 self.data['v'] = self.data['r'].rolling(self.window).std()
                 self.data.dropna(inplace=True)
                 # self.data_ = (self.data - self.env.mu) / self.env.std  
                 self.data_ = (self.data - self.data.mean()) / self.data.std()  
             def _resample_data(self):
                 self.data = self.tick_data.resample(self.granularity,
                                 label='right').last().ffill().iloc[:-1]  
                 self.data = pd.DataFrame(self.data['mid'])  
                 self.data.columns = [self.symbol,]  
                 self.data.index = self.data.index.tz_localize(None)  
             def _get_state(self):
                 state = self.data_[self.env.features].iloc[-self.env.lags:]  
                 return np.reshape(state.values, [1, self.env.lags,
                                                  self.env.n_features])  
             def report_trade(self, time, side, order):
                 self.trades += 1
                 pl = float(order['pl'])  
                 self.pl.append(pl)  
                 cpl = sum(self.pl)  
                 print('\n' + 75 * '=')
                 print(f'{time} | *** GOING {side} ({self.trades}) ***')
                 print(f'{time} | PROFIT/LOSS={pl:.2f} | CUMULATIVE={cpl:.2f}')
                 print(75 * '=')
                 if self.verbose:
                     pprint(order)
                     print(75 * '=')
             def on_success(self, time, bid, ask):
                 df = pd.DataFrame({'ask': ask, 'bid': bid,
                                    'mid': (bid + ask) / 2},
                                   index=[pd.Timestamp(time)])
                 self.tick_data = self.tick_data.append(df)  
                 self._resample_data()  
                 if len(self.data) > self.min_length:
                     self.min_length += 1
                     self._prepare_data()
                     state = self._get_state()  
                     prediction = np.argmax(
                         self.agent.model.predict(state)[0, 0])  
                     position = 1 if prediction == 1 else -1  
                     if self.position in [0, -1] and position == 1:  
                         order = self.create_order(self.symbol,
                                 units=(1 - self.position) * self.units,
                                         suppress=True, ret=True)
                         self.report_trade(time, 'LONG', order)
                         self.position = 1
                     elif self.position in [0, 1] and position == -1:  
                         order = self.create_order(self.symbol,
                                 units=-(1 + self.position) * self.units,
                                         suppress=True, ret=True)
                         self.report_trade(time, 'SHORT', order)
                         self.position = -1
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO12-1)

For demonstration, the normalization is done with the real-time data statistics.[1](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#idm46319919595768)

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO12-3)

Collects the tick data and resamples it to the required granularity.

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/3.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO12-7)

Returns the current state of the financial market.

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/4.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO12-9)

Collects the P\&L figures for every trade.

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/5.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO12-11)

Calculates the cumulative P\&L for all trades.

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/6.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO12-14)

Predicts the market direction and derives the signal (position).

[![7](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/7.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO12-17)

Checks whether the conditions for a _long position_ (buy order) are met.

[![8](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/8.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO12-18)

Checks whether the conditions for a _short position_ (sell order) are met.

The application of this class is straightforward. First, an object is instantiated, providing as the major input the trained trading bot `agent` from the previous section. Second, the streaming for the instrument to be traded needs to be started. Whenever new tick data arrives, the `.on_success()` method is called, which contains the main logic for both the processing of the tick data and the placement of trades. To speed things up a bit, the deployment example relies, as did the backtesting before, on 30-second bars. In a production context, when managing real money, a longer time interval might be the better choice—if only to reduce the number of trades and therewith the transaction costs:

```
In [78]: otb = OandaTradingBot('../aiif.cfg', agent, '30s',
                               25000, verbose=False)  

In [79]: otb.tick_data.info()
         <class 'pandas.core.frame.DataFrame'>
         Index: 0 entries
         Empty DataFrame
In [80]: otb.stream_data(agent.learn_env.symbol, stop=1000)  

         ===========================================================================
         2020-08-13T12:19:32.320291893Z | *** GOING SHORT (1) ***
         2020-08-13T12:19:32.320291893Z | PROFIT/LOSS=0.00 | CUMULATIVE=0.00
         ===========================================================================

         ===========================================================================
         2020-08-13T12:20:00.083985447Z | *** GOING LONG (2) ***
         2020-08-13T12:20:00.083985447Z | PROFIT/LOSS=-6.80 | CUMULATIVE=-6.80
         ===========================================================================

         ===========================================================================
         2020-08-13T12:25:00.099901587Z | *** GOING SHORT (3) ***
         2020-08-13T12:25:00.099901587Z | PROFIT/LOSS=-7.86 | CUMULATIVE=-14.66
         ===========================================================================

In [81]: print('\n' + 75 * '=')
         print('*** CLOSING OUT ***')
         order = otb.create_order(otb.symbol,
                         units=-otb.position * otb.units,
                         suppress=True, ret=True)  
         otb.report_trade(otb.time, 'NEUTRAL', order)  
         if otb.verbose:
             pprint(order)
         print(75 * '=')

         ===========================================================================
         *** CLOSING OUT ***

         ===========================================================================
         2020-08-13T12:25:16.870357562Z | *** GOING NEUTRAL (4) ***
         2020-08-13T12:25:16.870357562Z | PROFIT/LOSS=-3.19 | CUMULATIVE=-17.84
         ===========================================================================
         ===========================================================================
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO13-1)

Instantiates the `OandaTradingBot` object

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO13-2)

Starts the streaming of the real-time data and the trading

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/3.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO13-3)

Closes the final position after a certain number of ticks retrieved

During the deployment, P\&L figures are collected in the `pl` attribute, which is a `list` object. Once the trading has stopped, the P\&L figures can be analyzed:

```
In [82]: pl = np.array(otb.pl)  

In [83]: pl  
Out[83]: array([ 0.    , -6.7959, -7.8594, -3.1862])

In [84]: pl.cumsum()  
Out[84]: array([  0.    ,  -6.7959, -14.6553, -17.8415])
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO14-1)

P\&L figures for all trades

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO14-3)

Cumulative P\&L figures

The simple deployment example illustrates that one can trade algorithmically and in automated fashion with a deep Q-learning trading bot in less than 100 lines of Python code. The major prerequisite is the trained trading bot (i.e., an instance of the `tradingbot` class). Many important aspects are intentionally left out here. For example, in a production environment, one would probably like to persist the data. One would also like to persist the order objects. Measures to make sure that the socket connection is still alive are also important (for example, by monitoring a heartbeat). Overall, security, reliability, logging, and monitoring are not really addressed. Some more details in this regard are provided in Hilpisch (2020).

The Python script in [“Oanda Trading Bot”](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#ed\_otb) presents a standalone executable version of the `OandaTradingBot` class. This represents a major step toward a more robust deployment option as compared to an interactive context such as Jupyter Notebook or Jupyter Lab. The script also includes functionality to add SL, TSL, or TP orders for the execution. The script expects a pickled version of the `agent` object in the current working directory. The following Python code pickles the object for later usage by the script and saves the Keras model object separately:

```
In [85]: import pickle

In [86]: agent.model.save('tradingbot')

In [87]: agent.model = None

In [88]: pickle.dump(agent, open('trading.bot', 'wb'))
```

## Conclusions

This chapter discusses central aspects of the execution of an algorithmic trading strategy and the deployment of a trading bot. The Oanda trading platform provides directly or indirectly with its v20 API all necessary capabilities to do the following:

* Retrieve historical data
* Train and backtest a trading bot (deep Q-learning agent)
* Stream real-time data
* Place market (and limit) orders
* Make use of SL, TSL, and TP orders
* Deploy a trading bot in an automated manner

The prerequisites to implement all these steps are a demo account with Oanda, standard hardware and software (open source only), and a stable internet connection. In other words, the barriers of entry to algorithmic trading for the purposes of exploiting economic inefficiencies are pretty low. This is in stark contrast, for example, to the training, design, and construction of AVs for deployment on public streets—the budgets of companies in the AV space run into the billions of dollars. In other words, the finance domain has distinctive advantages compared to other industries and domains with regard to the real-world deployment of AI agents, such as trading bots, as focused on in this and the previous chapter.

## References

Books and papers cited in this chapter:

* Hilpisch, Yves. 2020. _Python for Algorithmic Trading: From Idea to Cloud Deployment._ Sebastopol: O’Reilly.
* Litman, Todd. 2020. “Autonomous Vehicle Implementation Predictions.” _Victoria Transport Policy Institute_. [_https://oreil.ly/ds7YM_](https://oreil.ly/ds7YM).

## Python Code

This section contains code used and referenced in the main body of the chapter.

### Oanda Environment

The following is the Python module with the `OandaEnv` class to train a trading bot based on historical Oanda data:

```
#
# Finance Environment
#
# (c) Dr. Yves J. Hilpisch
# Artificial Intelligence in Finance
#
#
import math
import tpqoa
import random
import numpy as np
import pandas as pd


class observation_space:
    def __init__(self, n):
        self.shape = (n,)


class action_space:
    def __init__(self, n):
        self.n = n

    def sample(self):
        return random.randint(0, self.n - 1)


class OandaEnv:
    def __init__(self, symbol, start, end, granularity, price,
                 features, window, lags, leverage=1,
                 min_accuracy=0.5, min_performance=0.85,
                 mu=None, std=None):
        self.symbol = symbol
        self.start = start
        self.end = end
        self.granularity = granularity
        self.price = price
        self.api = tpqoa.tpqoa('../aiif.cfg')
        self.features = features
        self.n_features = len(features)
        self.window = window
        self.lags = lags
        self.leverage = leverage
        self.min_accuracy = min_accuracy
        self.min_performance = min_performance
        self.mu = mu
        self.std = std
        self.observation_space = observation_space(self.lags)
        self.action_space = action_space(2)
        self._get_data()
        self._prepare_data()

    def _get_data(self):
        ''' Method to retrieve data from Oanda.
        '''
        self.fn = f'../../source/oanda/'  
        self.fn += f'oanda_{self.symbol}_{self.start}_{self.end}_'  
        self.fn += f'{self.granularity}_{self.price}.csv'  
        self.fn = self.fn.replace(' ', '_').replace('-', '_').replace(':', '_')
        try:
            self.raw = pd.read_csv(self.fn, index_col=0, parse_dates=True)  
        except:
            self.raw = self.api.get_history(self.symbol, self.start,
                                       self.end, self.granularity,
                                       self.price)  
            self.raw.to_csv(self.fn)  
        self.data = pd.DataFrame(self.raw['c'])  
        self.data.columns = [self.symbol]  

    def _prepare_data(self):
        ''' Method to prepare additional time series data
            (such as features data).
        '''
        self.data['r'] = np.log(self.data / self.data.shift(1))
        self.data.dropna(inplace=True)
        self.data['s'] = self.data[self.symbol].rolling(self.window).mean()
        self.data['m'] = self.data['r'].rolling(self.window).mean()
        self.data['v'] = self.data['r'].rolling(self.window).std()
        self.data.dropna(inplace=True)
        if self.mu is None:
            self.mu = self.data.mean()
            self.std = self.data.std()
        self.data_ = (self.data - self.mu) / self.std
        self.data['d'] = np.where(self.data['r'] > 0, 1, 0)
        self.data['d'] = self.data['d'].astype(int)

    def _get_state(self):
        ''' Privat method that returns the state of the environment.
        '''
        return self.data_[self.features].iloc[self.bar -
                                    self.lags:self.bar].values

    def get_state(self, bar):
        ''' Method that returns the state of the environment.
        '''
        return self.data_[self.features].iloc[bar - self.lags:bar].values

    def reset(self):
        ''' Method to reset the environment.
        '''
        self.treward = 0
        self.accuracy = 0
        self.performance = 1
        self.bar = self.lags
        state = self._get_state()
        return state

    def step(self, action):
        ''' Method to step the environment forwards.
        '''
        correct = action == self.data['d'].iloc[self.bar]
        ret = self.data['r'].iloc[self.bar] * self.leverage
        reward_1 = 1 if correct else 0  
        reward_2 = abs(ret) if correct else -abs(ret)  
        reward = reward_1 + reward_2 * self.leverage  
        self.treward += reward_1
        self.bar += 1
        self.accuracy = self.treward / (self.bar - self.lags)
        self.performance *= math.exp(reward_2)
        if self.bar >= len(self.data):
            done = True
        elif reward_1 == 1:
            done = False
        elif (self.accuracy < self.min_accuracy and
              self.bar > self.lags + 15):
            done = True
        elif (self.performance < self.min_performance and
              self.bar > self.lags + 15):
            done = True
        else:
            done = False
        state = self._get_state()
        info = {}
        return state, reward, done, info
```

[![1](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/1.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO15-1)

Defines the path for the data file

[![2](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/2.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO15-2)

Defines the filename of the data file

[![3](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/3.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO15-4)

Reads the data if a corresponding data file exists

[![4](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/4.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO15-5)

Retrieves the data for the API if no such file exists

[![5](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/5.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO15-6)

Writes the data as a `CSV` file to disk

[![6](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/6.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO15-7)

Selects the column with the closing prices

[![7](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/7.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO15-8)

Renames the column to the instrument name (symbol)

[![8](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/8.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO15-9)

Reward for correct prediction

[![9](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/9.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO15-10)

Reward for the realized performance (return)

[![10](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492055426/files/assets/10.png)](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#co\_execution\_and\_deployment\_CO15-11)

Combined reward for prediction and performance

### Vectorized Backtesting

The following is the Python module with the helper function `backtest` to generate the data to do a vectorized backtest for a deep Q-learning trading bot. The code is also used in [Chapter 11](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch11.html#risk\_management):

```
#
# Vectorized Backtesting of
# Trading Bot (Financial Q-Learning Agent)
#
# (c) Dr. Yves J. Hilpisch
# Artificial Intelligence in Finance
#
import numpy as np
import pandas as pd
pd.set_option('mode.chained_assignment', None)

def reshape(s, env):
    return np.reshape(s, [1, env.lags, env.n_features])

def backtest(agent, env):
    done = False
    env.data['p'] = 0
    state = env.reset()
    while not done:
        action = np.argmax(
            agent.model.predict(reshape(state, env))[0, 0])
        position = 1 if action == 1 else -1
        env.data.loc[:, 'p'].iloc[env.bar] = position
        state, reward, done, info = env.step(action)
    env.data['s'] = env.data['p'] * env.data['r']
```

### Oanda Trading Bot

The following is the Python script with the `OandaTradingBot` class and code to deploy the class:

```
#
# Oanda Trading Bot
# and Deployment Code
#
# (c) Dr. Yves J. Hilpisch
# Artificial Intelligence in Finance
#
import sys
import tpqoa
import keras
import pickle
import numpy as np
import pandas as pd

sys.path.append('../ch11/')


class OandaTradingBot(tpqoa.tpqoa):
    def __init__(self, config_file, agent, granularity, units,
                 sl_distance=None, tsl_distance=None, tp_price=None,
                 verbose=True):
        super(OandaTradingBot, self).__init__(config_file)
        self.agent = agent
        self.symbol = self.agent.learn_env.symbol
        self.env = agent.learn_env
        self.window = self.env.window
        if granularity is None:
            self.granularity = agent.learn_env.granularity
        else:
            self.granularity = granularity
        self.units = units
        self.sl_distance = sl_distance
        self.tsl_distance = tsl_distance
        self.tp_price = tp_price
        self.trades = 0
        self.position = 0
        self.tick_data = pd.DataFrame()
        self.min_length = (self.agent.learn_env.window +
                           self.agent.learn_env.lags)
        self.pl = list()
        self.verbose = verbose
    def _prepare_data(self):
        ''' Prepares the (lagged) features data.
        '''
        self.data['r'] = np.log(self.data / self.data.shift(1))
        self.data.dropna(inplace=True)
        self.data['s'] = self.data[self.symbol].rolling(self.window).mean()
        self.data['m'] = self.data['r'].rolling(self.window).mean()
        self.data['v'] = self.data['r'].rolling(self.window).std()
        self.data.dropna(inplace=True)
        self.data_ = (self.data - self.env.mu) / self.env.std
    def _resample_data(self):
        ''' Resamples the data to the trading bar length.
        '''
        self.data = self.tick_data.resample(self.granularity,
                                label='right').last().ffill().iloc[:-1]
        self.data = pd.DataFrame(self.data['mid'])
        self.data.columns = [self.symbol,]
        self.data.index = self.data.index.tz_localize(None)
    def _get_state(self):
        ''' Returns the (current) state of the financial market.
        '''
        state = self.data_[self.env.features].iloc[-self.env.lags:]
        return np.reshape(state.values, [1, self.env.lags, self.env.n_features])
    def report_trade(self, time, side, order):
        ''' Reports trades and order details.
        '''
        self.trades += 1
        pl = float(order['pl'])
        self.pl.append(pl)
        cpl = sum(self.pl)
        print('\n' + 71 * '=')
        print(f'{time} | *** GOING {side} ({self.trades}) ***')
        print(f'{time} | PROFIT/LOSS={pl:.2f} | CUMULATIVE={cpl:.2f}')
        print(71 * '=')
        if self.verbose:
            pprint(order)
            print(71 * '=')
    def on_success(self, time, bid, ask):
        ''' Contains the main trading logic.
        '''
        df = pd.DataFrame({'ask': ask, 'bid': bid, 'mid': (bid + ask) / 2},
                          index=[pd.Timestamp(time)])
        self.tick_data = self.tick_data.append(df)
        self._resample_data()
        if len(self.data) > self.min_length:
            self.min_length += 1
            self._prepare_data()
            state = self._get_state()
            prediction = np.argmax(self.agent.model.predict(state)[0, 0])
            position = 1 if prediction == 1 else -1
            if self.position in [0, -1] and position == 1:
                order = self.create_order(self.symbol,
                        units=(1 - self.position) * self.units,
                        sl_distance=self.sl_distance,
                        tsl_distance=self.tsl_distance,
                        tp_price=self.tp_price,
                        suppress=True, ret=True)
                self.report_trade(time, 'LONG', order)
                self.position = 1
            elif self.position in [0, 1] and position == -1:
                order = self.create_order(self.symbol,
                        units=-(1 + self.position) * self.units,
                        sl_distance=self.sl_distance,
                        tsl_distance=self.tsl_distance,
                        tp_price=self.tp_price,
                        suppress=True, ret=True)
                self.report_trade(time, 'SHORT', order)
                self.position = -1


if __name__ == '__main__':
    model = keras.models.load_model('tradingbot')
    agent = pickle.load(open('trading.bot', 'rb'))
    agent.model = model
    otb = OandaTradingBot('../aiif.cfg', agent, '5s',
                          25000, verbose=False)
    otb.stream_data(agent.learn_env.symbol, stop=1000)
    print('\n' + 71 * '=')
    print('*** CLOSING OUT ***')
    order = otb.create_order(otb.symbol,
                    units=-otb.position * otb.units,
                    suppress=True, ret=True)
    otb.report_trade(otb.time, 'NEUTRAL', order)
    if otb.verbose:
        pprint(order)
    print(71 * '=')
```

[1](https://learning.oreilly.com/library/view/artificial-intelligence-in/9781492055426/ch12.html#idm46319919595768-marker) This little trick leads more quickly to trades in this particular context given the data used. For real deployment, the statistics from the learning environment data are to be used for the normalization.
