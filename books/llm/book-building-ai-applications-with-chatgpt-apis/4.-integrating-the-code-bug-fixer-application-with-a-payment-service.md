# 4. Integrating the Code Bug Fixer Application with a Payment Service

## 4. Integrating the Code Bug Fixer Application with a Payment Service <a href="#_idparadest-50" id="_idparadest-50"></a>

In this chapter, we will explore how to integrate a payment service into your ChatGPT Code Bug Fixer application using the **Stripe** API. This will allow you to keep track of the number of visits a user performs on your ChatGPT application and implement a payment mechanism for premium features or content. You will also learn how to use a basic database in your ChatGPT project, which is necessary to track user data and transactions.

First, we will introduce Stripe and show you how to set up an account and API key. We will then go through the steps of creating a SQL user database that will be used to store user data and transaction histories. Finally, we will guide you through the process of adding payment functionality to your ChatGPT application using the Stripe API, including creating a checkout process, handling payment Webhooks, and updating a database.

In this chapter, we will learn how to do the following:

* Use Stripe to implement payments in a ChatGPT application.
* Set up a basic SQL database for user management.
* Integrate Stripe with the ChatGPT API to keep track of the number of app usages.
* Test the payment flow using Stripe’s test mode.
* Monitor and analyze payment data using Stripe’s dashboard and analytics features.

By the end of this chapter, you will have the necessary knowledge and tools to add payment services to your ChatGPT application and build a successful online business.

## Technical Requirements <a href="#_idtextanchor059" id="_idtextanchor059"></a>

The technical requirements for this project are as follows:

* Python 3.7 or later installed on your machine.
* A code editor, such as PyCharm (recommended).
* A Python virtual environment.
* An OpenAI API key.
* A Stripe account and API key.

In the next section, you will learn how to integrate payments with Stripe. You will see how to create a Stripe account, obtain the necessary API keys, and set up the Stripe API for use in your application.

The code examples from this chapter can be found on GitHub at [https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/tree/main/Chapter04%20CodeBugFixer](https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/tree/main/Chapter04%20CodeBugFixer).

## Integrating Payments with Stripe <a href="#_idtextanchor060" id="_idtextanchor060"></a>

**Stripe** is a popular payment gateway that provides an easy way to accept payments online. It allows businesses and individuals to accept payments over the internet, manage subscriptions, and track revenue all in one place. Stripe has an easy-to-use API that allows developers to integrate payment functionality into their websites and applications. We will begin by creating a Stripe account and configuring the Stripe API keys that we will use to authenticate our requests to the Stripe API. Here, you will use the Stripe API to create a payment form and process payments securely in your Python code.

The first step toward accepting payments in your Code Big Fixer application is to create a Stripe account. Stripe is a popular payment processing platform that enables businesses to accept payments online. By setting up a Stripe account, you can integrate it with your ChatGPT application and start accepting payments from your users. Setting up a Stripe account is easy and straightforward, and we will guide you through all steps.

To get started with Stripe, you need to create an account. Follow these steps to create a new Stripe account:

1. Go to the Stripe website registration form: [https://dashboard.stripe.com/register](https://dashboard.stripe.com/register) (see _Figure 4.1_).
2. Fill out the registration form with your personal or business information. You’ll need to provide your name, email address, and password.
3. Confirm your email address by clicking the link in the verification email that Stripe sends you.
4. Provide your business details, such as your business name, address, and tax ID number (optional).
5. Set up your payment settings. You can choose to accept payments from all major credit cards and debit cards, as well as digital wallets such as Apple Pay and Google Pay (optional).

![Figure 4.1: The Stripe Registration Form](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_4.1\_B21110.jpg)

Figure 4.1: The Stripe Registration Form

Once you’ve created your Stripe account, you can start accepting payments from your customers. You can also use Stripe’s dashboard, as shown in _Figure 4.2_, to manage your transactions, issue refunds, and view reports on your payment activity. Stripe charges a fee for each transaction processed through its platform, but the fees are competitive and transparent.

![Figure 4.2: The Stripe Dashboard](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_4.2\_B21110.jpg)

Figure 4.2: The Stripe Dashboard

Next, you need to obtain access to your Stripe API keys, which will be used later in your application to facilitate payment processing. From the dashboard, click on the **Developers** tab on the left-hand side of the screen, and then click on **API keys**. On this page, you will see your live and test API keys, along with the option to reveal each key’s secret. Make sure to copy and securely store your keys, as you will need them to make API requests to Stripe from your ChatGPT application.

Important note

Your live API keys should be kept private and not shared publicly, as they provide access to your Stripe account’s sensitive data and allow users to make changes. Instead, you can use your **test API keys** for development and testing purposes.

Stripe provides three types of API keys – publishable keys, secret keys, and test keys:

1. The **Publishable Key** is used on the client side to make requests to Stripe securely. It does not have any access to your account and can be shared publicly. This key is normally placed in the application frontend.
2. The **Secret Key** is used on the server side to make requests to Stripe and has full access to your account, including the ability to make charges. It should be kept secret and should never be shared publicly. This key is normally placed in the application backend.
3. The **Test Key** is used in testing environments to perform test transactions without charging any money. It works like the secret key but only affects test data, and it should not be used in production.

On the **API keys** page, you will see both the **Publishable** and **Test** API keys. We will use **Publishable** key to identify your account with Stripe in the frontend of your application, while the **Test** key is used for server-side communication with Stripe. You will need to add the **Publishable** key to the frontend code of your ChatGPT application, and the **Test** key to the backend code.

This is how you can integrate payments into a website or application using **Stripe**, a popular payment gateway that provides an easy way to accept payments online. In this section, to use Stripe, you created a Stripe account and obtained the API keys, including the publishable key and a secret key, which have different access levels and should be kept secure. You also saw a step-by-step guide on how to create a Stripe account and obtain the necessary API keys.

In the next section, you will learn about setting up a SQL user database for the Code Big Fixer application. We will explore the different payment models and understand how to design a subscription-based payment plan.

## Setting Up a SQL User Database <a href="#_idtextanchor061" id="_idtextanchor061"></a>

Prior to implementing the payment infrastructure into your application, it’s essential to determine your business strategy, which pertains to how you’ll charge users of your web application. There are several ways to accomplish this:

* **Subscription plan**: This is a recurring payment model that allows users to pay for a service or product on a regular basis, such as monthly or yearly. It is a common payment option for **software-as-a-service** (**SaaS**) products and online publications, where users pay for access to the service or content.
* **One-time payment plan**: Customers make a single payment for a product or service.
* **Usage-based plan**: Customers are charged based on their usage of a product or service, such as pay-per-view or pay-per-click.

For our Code Big Fixer application, we will design a subscription model that provides users with three different plans to choose from. Furthermore, to make the user onboarding process smoother, we will include a **free trial** period that allows users to try out the application a certain number of times before committing to a payment plan.

The free trial period will provide users with the opportunity to explore the application’s features and determine whether it meets their needs. During the trial period, users can use the application for a specific number of times without any charge. After the trial period, users will be prompted to select a payment plan to continue using the application. This subscription-based approach is beneficial to both the users and you as an application owner. The users can select the subscription plan that best fits their budget and usage, while you can generate a steady stream of revenue from the subscription fees.

In order to implement the payment mechanism for our application, we will need to set up a database to track user visits and usage. The database will need to record two types of information – the browser ID (see _Table 4.1_), which is unique to each user accessing the application, and the usage counter, which keeps track of how many times each user has accessed the application. By tracking this information, we can identify unique users and ensure that they have not exceeded their allowed number of free visits before being prompted to choose a subscription plan.

| **BROWSER ID** | **USAGE COUNTER** |
| -------------- | ----------------- |
| 28ec523f092    | 3                 |
| 58c9f5702fd    | 6                 |
| c59523926d     | 10                |

Table 4.1: User Data Collected in the Database

Now that we have established a solid business plan, we can move forward and delve into the technical details of integrating a payment service into our ChatGPT application. Before we can do that, however, we need to initialize a SQL database.

### Initializing a SQL Database <a href="#_idtextanchor062" id="_idtextanchor062"></a>

A SQL database is essential to keep track of the number of visits that a user performs on our application, which will in turn enable us to implement a payment mechanism using the Stripe API. By having a database, we can easily store and retrieve data related to our users and their interaction with our application, allowing us to manage the payment process seamlessly.

Now, let’s open our Code Bug Fixer application’s **app.py** file in PyCharm and import all the necessary libraries to access Stripe and a SQL database:

app.py

<pre><code>from flask import Flask, request, render_template
import openai
import config
<strong>import hashlib
</strong><strong>import sqlite3
</strong><strong>import stripe
</strong></code></pre>

We have just added the following libraries to our **app.py** file:

* **hashlib**: Provides interfaces to secure hash algorithms. It is used to generate hash values of data. In our case, we will use **hashlib** to hash user information before storing them in the database for security purposes.
* **sqlite3**: This library provides a lightweight disk-based database that doesn’t require a separate server process and allows us to access the database using SQL commands. We will use it to create and manage a database to store user information.
* **stripe**: This is a third-party library that provides a Python client for the Stripe API, which allows us to handle payments in our application. We will use it to process payments made by users through our application.

While the **sqlite3** and **hashlib** are built-in libraries in Python, you will need to install **stripe**. You can simply do that by opening a new PyCharm terminal by going to **View** | **Tool Windows** | **Terminal** and typing the following:

```
$ pip install stripe
```

After successfully installing Stripe, you can proceed to configure the Stripe test key. To do so, simply navigate to the Stripe dashboard, and then head over to the **Developers** tab, followed by the **API keys** section. From there, you can click on the option to reveal the test key, which will allow you to copy the test key for use.

To create a new API key entry, make the required modifications to the files listed in your Code Bug Fixer project:

config.py

<pre><code>API_KEY = "&#x3C;YOUR_OPENAI_API_KEY>"
<strong>STRIPE_TEST_KEY = "&#x3C;YOUR_STRIPE_API_TEST_KEY>"
</strong></code></pre>

app.py

<pre><code>openai.api_key = config.API_KEY
<strong>stripe.api_key = config.STRIPE_TEST_KEY
</strong></code></pre>

This code will add your Stripe API test key to the **config.py** file and then retrieve this key in the **app.py** file, allowing your application to communicate with the Stripe APIs using the specified keys securely.

The next step is to add the **initialize\_database()** function just under the API keys in **app.py**. This function will create a SQLite database and a table of users with two columns for **fingerprint** and the **usage\_counter**, as shown in _Table 4.1_:

```
def initialize_database():
    conn = sqlite3.connect('app.db')
    c = conn.cursor()
    c.execute(
        '''CREATE TABLE IF NOT EXISTS users (fingerprint text primary key, usage_counter int)''')
    conn.commit()
    conn.close()
```

The preceding function establishes a connection to a newly created **SQLite** database named **app.db**, using the **sqlite3** library in Python. Then, it creates a **cursor object** called **c**, which is used to execute SQL commands and fetch results from the database. The cursor object allows you to perform various operations on the database such as creating tables, inserting data, and updating data.

Then, we use the cursor object to execute a SQL command that creates a table named **users** in the connected SQLite database. This table has two columns, **fingerprint** and **usage\_counter**; the **fingerprint** column will hold the user browser ID, and **usage\_counter** will hold the number of application usages for a specific user. The **primary key** keyword specifies that the **fingerprint** column is the primary key of the table.

Finally, we can **commit** the changes made to the database by the previous SQL command so that they become permanent, and **close** the database connection, freeing up any resources that were used by the connection.

This is how you can initialize a SQL database for the Code Bug Fixer application. Those are all necessary libraries to create a SQL database and configure the Stripe test key. In the next step, you will discover the process of obtaining the **fingerprint** browser, which will aid you to recognize individual users who utilize your application.

### Getting a Browser Fingerprint ID <a href="#_idtextanchor063" id="_idtextanchor063"></a>

In order to track and identify unique users of your web application, you need a way to obtain their browser fingerprint. A browser fingerprint is a unique identifier generated by the browser based on various parameters, such as browser type, screen resolution, and installed fonts. In this section, we will explore how to obtain the browser fingerprint ID in Python.

It is considered a good practice to have a dedicated Python function for each individual task in our application, and generating a browser fingerprint is no exception. Therefore, it is appropriate to create a new function called **get\_fingerprint()** under the **initialize\_database()** function:

```
def get_fingerprint():
    browser = request.user_agent.browser
    version = request.user_agent.version and float(
        request.user_agent.version.split(".")[0])
    platform = request.user_agent.platform
    string = f"{browser}:{version}:{platform}"
    fingerprint = hashlib.sha256(string.encode("utf-8")).hexdigest()
    print(fingerprint)
    return fingerprint
```

The **get\_fingerprint()** function is a Flask view function that is responsible for generating, in most cases, a unique browser fingerprint for each user who interacts with the application. A fingerprint is a hash of a string that uniquely identifies a user based on their browser type, version, and platform.

Important Note

The browser fingerprint is not 100% guaranteed to be unique for every user, but browser fingerprinting can often generate a relatively unique identifier that distinguishes one user from another. Identifiers such as an IP address or device-specific identifiers such as MAC addresses are more suitable for real-world applications.

First, the function gets the **user\_agent** object from the request object using **request.user\_agent**. This object contains information about the user’s browser, platform, and version.

Next, the function constructs a string from the browser, version, and platform information by concatenating them together, separated by colons (**:**). This string is used as the input to the **hashlib.sha256()** function, which generates a hash of the input string using the **SHA-256** algorithm. The resulting hash is a 64-character hexadecimal string that represents the unique browser fingerprint. We also add a **print()** statement so that we can verify the fingerprint in our PyCharm logs.

The function returns the generated fingerprint string. We will later store the fingerprint in the SQLite database, along with the usage counter for each user, so that the application can keep track of how many times a user has accessed the application. This information is used to determine whether the user needs to pay to continue using the application.

Now, it is time to cover the final part of our user tracking mechanism by getting the number of app utilizations per user in the next section.

### Tracking Application Users <a href="#_idtextanchor064" id="_idtextanchor064"></a>

In this section, we will delve into the usage counter functionality of the application’s backend. Specifically, we will examine the **get\_usage\_counter()** and **update\_usage\_counter()** functions, which are responsible for retrieving and updating the usage counter associated with a user’s browser fingerprint ID. These functions play a crucial role in determining when a user has exceeded their usage limit and should be prompted to make a payment to continue using the application.

The **get\_usage\_counter()** function is responsible for retrieving the usage counter for a particular browser fingerprint from the SQLite database. The counter keeps track of how many times a user with that fingerprint has submitted a code error:

```
def get_usage_counter(fingerprint):
    conn = sqlite3.connect('app.db')
    c = conn.cursor()
    result = c.execute('SELECT usage_counter FROM users WHERE                         fingerprint=?', [fingerprint]).fetchone()
    conn.close()
    if result is None:
        conn = sqlite3.connect('app.db')
        c = conn.cursor()
        c.execute('INSERT INTO users (fingerprint, usage_counter)                   VALUES ' '(?, 0)', [fingerprint])
        conn.commit()
        conn.close()
        return 0
    else:
        return result[0]
```

The function takes **fingerprint** as an argument because it is used to retrieve the usage counter for the given browser fingerprint. The fingerprint serves as the unique identifier for each user of the application, and the function looks up the usage counter associated with that fingerprint in the database. It creates a connection to the **SQLite** database named **app.db** and then creates a cursor object that can execute **SQLite** commands on the database.

Then, the **c.execute()** command creates a new database table called **users** with two columns named **fingerprint** and **usage\_counter**. It only creates the table if it doesn’t already exist.

The **result** executes a SQL query to fetch the value of the **usage\_counter** column for the given **fingerprint** from the **users** table. It does so by using parameterized queries and the **fetchone()** method. If no record is found for the given fingerprint, the result will be set to **None** for new users.

Once the connection with the database is closed, the function checks whether the result of the previous database query is **None** or not. If it is **None**, it means there is no record for the provided **fingerprint** in the **users** table. In this case, the function does the following:

1. Connects to the database.
2. Creates a cursor object.
3. Inserts a new record for **fingerprint** with a **usage\_counter** value of **0**.
4. Commits the changes to the database.
5. Closes the connection.
6. Returns **0**.

If the result is not **None**, it means that there is already a record for the provided **fingerprint** in the **users** table. In this case, the function returns the value of the **usage\_counter** column of the record. In essence, this function aims to either return the value of **0** for new users or the count of usages for those already in the database.

The **update\_usage\_counter()** function, on the other side, is responsible for updating the usage counter in the database for a given browser fingerprint. The function takes two arguments – the browser fingerprint and the updated usage counter value:

<pre><code><strong>def update_usage_counter(fingerprint, usage_counter):
</strong><strong>    conn = sqlite3.connect('app.db')
</strong>    c = conn.cursor()
<strong>    c.execute('UPDATE users SET usage_counter=? WHERE fingerprint=?',
</strong>              [usage_counter, fingerprint])
    conn.commit()
    conn.close()
</code></pre>

Once connected to the database and an edition cursor has been created, the function is responsible for updating the usage counter after every use of our Code Bug Fixer app. It uses the **execute** method of the cursor object to execute a SQL statement that updates the **usage\_counter** field for the user with the provided **fingerprint**.

The SQL statement uses **placeholders ?** to indicate where the values of **usage\_counter** and **fingerprint** should be inserted. The values to be inserted are passed as a list in the second argument of **execute()** in the order they appear in the SQL statement. The **WHERE** clause ensures that the update is only applied to the row matching the specified **fingerprint**.

To sum up, the **get\_usage\_counter()** function retrieves the usage counter for a user’s browser fingerprint ID from the SQLite database, while the **update\_usage\_counter()** function updates the usage counter value in the database for a given fingerprint after every use of the Code Bug Fixer app. These functions are crucial to determine when a user has exceeded their usage limit and should be prompted to make a payment to continue using the application. We can now implement all the functions we have created so far into our Code Bug Fixer application **index()** page.

### Implementing the Usage Counters <a href="#_idtextanchor065" id="_idtextanchor065"></a>

In this section, we will integrate all the functions that we created earlier into the **index()** page of our Code Bug Fixer application. By doing so, we will be able to keep track of the number of times a user has submitted a code error and whether they have reached the limit of three submissions, thus requiring them to pay to continue. Additionally, we will be able to associate each submission with a unique browser fingerprint to prevent users from submitting multiple errors using different aliases:

<pre><code>@app.route("/", methods=["GET", "POST"])
def index():
<strong>    initialize_database()
</strong><strong>    fingerprint = get_fingerprint()
</strong><strong>    usage_counter = get_usage_counter(fingerprint)
</strong></code></pre>

The preceding code snippet performs three essential tasks. Firstly, it initializes the database, then it retrieves the user’s browser fingerprint, and fetches their current usage counter from the database. The database table for users will be created if it does not already exist. The fingerprint variable uniquely identifies the user and allows us to track their usage counter.

After our initialization is completed, we need to set a rule that will pass the control to the payment page if the usage counter is higher than a specific number:

<pre><code>if request.method == "POST":
<strong>    if usage_counter > 3:
</strong><strong>        return render_template("payment.html")
</strong></code></pre>

After that, we check whether the HTTP request method is **POST**, which indicates that the user has submitted a form on the website. In our case, this means that the user has submitted code for fixing in the Code Bug Fixer. Then, our app will check whether the user’s usage counter is greater than **3**. If it is, it means the user has exceeded their limit of free usage and should be directed to the payment page. The function returns a rendered template of the **payment.html** page. We also add a **print()** statement so that we can verify the counter increment in our PyCharm logs.

After the usage counter is initialized and we have a mechanism to check whether it is greater than the allowed number of usages, the last step is to make sure that the usage counter increments every time the user utilizes the Code Bug Fixer:

<pre><code>fixed_code_prompt = (f"Fix this code: \n\n{code}\n\nError:\n\n{error}."
    f" \n Respond only with the fixed code."
)
fixed_code_completions = openai.Completion.create(
    engine=model_engine,
    prompt=fixed_code_prompt,
    max_tokens=1024,
    n=1,
    stop=None,
    temperature=0.9,
)
fixed_code = fixed_code_completions.choices[0].text
<strong>usage_counter += 1
</strong><strong>print(usage_counter)
</strong><strong>update_usage_counter(fingerprint, usage_counter)
</strong></code></pre>

You can add those increments after the second ChatGPT API completion code, as shown previously. We will first increment the **usage\_counter** variable by one, which means that the user has used the service one more time. After that, we will update the **usage\_counter** value in the database for the user, identified by their browser fingerprint. This ensures that the usage counter is persistent across user sessions and reflects the total number of times the user has used the service. We also add a **print()** statement so that we can verify the counter increment in our PyCharm logs.

You can now run the Code Bug Fixer application to verify that your usage tracking method works successfully. Once the Code Bug Fixer is up and running, you can place a sample buggy code and an error into the relevant fields, and then click the **Code Fix** button. Perform that operation twice so that your usage counter can increment twice. Once you get the response for ChatGPT API and the **Fixed Code** and **Explanation** fields in your Code Bug Fixer are populated, you can go back to the PyCharm **Run** window and verify that your fingerprint and usage counter are displayed (see _Figure 4.3_).

![Figure 4.3: The Browser Fingerprint and Usage Counter Logging](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_4.3\_B21110.jpg)

Figure 4.3: The Browser Fingerprint and Usage Counter Logging

**3ae64fc…** is your specific browser fingerprint, while the number represents the number of times you currently used the application. Since you performed two requests to the ChatGPT API, the counter incremented twice.

To confirm the creation of a new database, you can check for a file named **app.db** in your project directory. This file is where all user data will be stored and will persist even if you shut down and restart the application.

![Figure 4.4: The Database Display](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_4.4\_B21110.jpg)

Figure 4.4: The Database Display

This was the final step to add the main backend functionality to our Code Bug Fixer application. In the next section, you will learn how to build the **/charge** page, where users will be redirected when their free trial ends.

## Adding Payments to a ChatGPT Application <a href="#_idtextanchor066" id="_idtextanchor066"></a>

In this section, I will guide you through the process of creating the payment page and functions in the Code Bug Fixer. We will create a payments page connected with Stripe to offer users three different subscription plans:

* **Monthly plan**: Users will be billed $5 every month
* **Quarterly plan**: Users will be billed $12 every quarter
* **Annual plan**: Users will be billed $50 every year

We will also create a confirmation page that will confirm the plan that a user has purchased by using a simple statement such as _“You have successfully paid $12 for the quarterly plan for unlimited access to the Code Bug Fixer.”_

Next, you will learn how to create the **payment.html** file.

### Building the Payments Page <a href="#_idtextanchor067" id="_idtextanchor067"></a>

Here, we will create a complete HTML document that includes a form to collect payment information from users. We will use the **Bulma CSS** framework to style the page and include **jQuery** and the Stripe API to handle the payment processing.

The page will be divided into three columns, each displaying a different payment plan option. Each option includes a card with a title, subtitle, and description of the plan. The payment form is located in the footer of each card, and it includes hidden input fields for the plan type and payment amount. The Stripe API is used to generate a payment button that collects payment information and initiates payment processing (see _Figure 4.5_).

![Figure 4.5: The Payment Page](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_4.5\_B21110.jpg)

Figure 4.5: The Payment Page

To generate the **Payments** page, create two new files inside the **templates** folder. Those two files will be named **payments.html** and **charge.html**. Once you do that, the Code Bug Fixer project structure will be as follows:

```
CodeBugFixer/
├── templates/
│   ├── charge.html
│   ├── index.html
│   └── payment.html
├── venv/
├── app.db
├── app.py
└── config.py
```

We will start by building the head of our **payments.html** page:

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,         initial-scale=1.0">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/        bulma@0.9.0/css/bulma.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/        jquery/3.5.1/jquery.min.js"></script>
    <script src="https://js.stripe.com/v3/"></script>
    <title>Payment</title>
</head>
</html>
```

The head contains metadata and external resources that are necessary for a document to be displayed correctly. The character set specifies the character encoding used in the document, which is **UTF-8** in this case, and the viewport meta tag ensures that the document is displayed correctly on different devices with varying screen sizes.

The **link** tag is used to import external frameworks. We will use the Bulma CSS framework, which provides a set of pre-designed CSS styles to build responsive web pages quickly and easily.

Then, we will import the jQuery library, which is a popular JavaScript library that simplifies the process of manipulating HTML documents and handling events. The second import is the Stripe API library, which provides functionality to process online payments.

Now, under **\</head>**, we can move to build the main body of the HTML file, which is enclosed within the **\<body>** tags:

```
<body>
    <section class="section">
        <div class="container">
            <h1 class="title">Payment Options</h1>
            <div class="columns">
          </div>
        </div>
    </section>
</body>
```

We will use the **\<section>** element, indicating that it is a separate section of the page that can be styled independently of other elements. There is a **\<div>** element with a class of **columns**. This element is used to create a grid system to lay out content in columns. This is a common approach to creating responsive layouts, where the number of columns may vary depending on the screen size or device being used. The columns in this case will contain the different payment plan options that the user can select from, each with its own set of features and pricing.

Now, inside the **columns** **\<div>** element, we can create three columns that represent the three payment plans mentioned earlier:

You can find the complete **payments.html** file here: [https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/blob/main/Chapter04%20CodeBugFixer/templates/payment.html](https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/blob/main/Chapter04%20CodeBugFixer/templates/payment.html):

<pre><code>&#x3C;div class="column">
    &#x3C;div class="card">
        &#x3C;div class="card-content">
            &#x3C;p class="title">Monthly Plan&#x3C;/p>
            &#x3C;p class="subtitle">$5 par month&#x3C;/p>
            &#x3C;p>This plan will give you unlimited access
                to the code explanation and fixing services every                 month.
                You will be charged $5 every month.&#x3C;/p>
        &#x3C;/div>
        &#x3C;footer class="card_footer">
            &#x3C;form action="/charge" method="post">
                &#x3C;input type="hidden" name="plan" value="monthly">
                &#x3C;input type="hidden" name="amount" value="500">
                &#x3C;script
                    src="https://checkout.stripe.com/checkout.js"
                    class="stripe-button"
<strong>                    data-key="&#x3C;YOUR_PUBLIC_KEY>"
</strong>                    data-amount="500"
                    data-name="Monthly Plan"
                    data-description="$5 per month"
                    data-image="https://stripe.com/img/                        documentation/checkout/marketplace.png"
                    data-locale="auto"
                    data-zip-code="false">
                &#x3C;/script>
            &#x3C;/form>
        &#x3C;/footer>
    &#x3C;/div>
&#x3C;/div>
&#x3C;div class="column">
    &#x3C;div class="card">
        &#x3C;div class="card-content">
            &#x3C;p class="title">Quarterly Plan&#x3C;/p>
            &#x3C;p class="subtitle">$12 par quarter&#x3C;/p>
            &#x3C;p>This plan will give you unlimited access
                to the code explanation and fixing services every                 quarter.
                You will be charged $12 every quarter.&#x3C;/p>
        &#x3C;/div>
        &#x3C;footer class="card_footer">
            &#x3C;form action="/charge" method="post">
                &#x3C;input type="hidden" name="plan" value="quarterly">
                &#x3C;input type="hidden" name="amount" value="1200">
                &#x3C;script
                    src="https://checkout.stripe.com/checkout.js"
                    class="stripe-button"
<strong>                    data-key="&#x3C;YOUR_PUBLIC_KEY>"
</strong>                    data-amount="1200"
                    data-name="Quarterly Plan"
                    data-description="$12 per month"
                    data-image="https://stripe.com/img/documentation/                        checkout/marketplace.png"
                    data-locale="auto"
                    data-zip-code="false">
                &#x3C;/script>
            &#x3C;/form>
        &#x3C;/footer>
    &#x3C;/div>
&#x3C;/div>
&#x3C;div class="column">
    &#x3C;div class="card">
        &#x3C;div class="card-content">
            &#x3C;p class="title">Annual Plan&#x3C;/p>
            &#x3C;p class="subtitle">$50 par year&#x3C;/p>
            &#x3C;p>This plan will give you unlimited access
                to the code explanation and fixing services every                 year.
                You will be charged $50 every year.&#x3C;/p>
        &#x3C;/div>
        &#x3C;footer class="card_footer">
            &#x3C;form action="/charge" method="post">
                &#x3C;input type="hidden" name="plan" value="yearly">
                &#x3C;input type="hidden" name="amount" value="5000">
                &#x3C;script
                    src="https://checkout.stripe.com/checkout.js"
                    class="stripe-button"
<strong>                    data-key="&#x3C;YOUR_PUBLIC_KEY>"
</strong>                    data-amount="5000"
                    data-name="Yearly Plan"
                    data-description="$50 per month"
                    data-image="https://stripe.com/img/documentation/                        checkout/marketplace.png"
                    data-locale="auto"
                    data-zip-code="false">
                &#x3C;/script>
            &#x3C;/form>
        &#x3C;/footer>
    &#x3C;/div>
&#x3C;/div>
</code></pre>

Important Note

Ensure that you replace the **"\<YOUR\_PUBLIC\_KEY>"** tag with the public key obtained from your Stripe account.

The first **\<div>** element with a **column** class is responsible for creating a card-like element that presents information about the monthly plan offered to the user. The card contains information about the name of the plan, the subscription fee, and what the user can expect from this plan.

The **\<div>** element with a **card** class is used to create the card that presents information about the monthly subscription plan. Inside the card, the card content is defined with the **card-content** class. The card content consists of three paragraphs, the first containing the title of the plan, **Monthly Plan**, the second containing the subscription fee **$5 per month**, and the third providing a description of the plan, which highlights the benefits of subscribing to the plan.

Inside the footer, a **form** element is defined, which is used to submit the subscription request to the server. The form’s action attribute is set to **/charge**, which indicates that the subscription request will be sent to the **/charge** route on the server. We will build the **/charge** page backend function later. This function will ensure that a confirmation is shown to the users, once a payment plan has been purchased.

The form contains two hidden input fields used to send the plan’s name and value. In this case, the plan’s name is set to **monthly**, while the amount attribute has a value set to **500**, which represents the subscription amount in cents. This information will be used to render the confirmation page.

Finally, a script tag is included inside the form element, which loads a Stripe checkout script. This script is responsible for creating a **secure payment form** that allows the user to enter their payment details and complete the subscription process. The script is configured with various attributes, including the Stripe API key, the subscription amount, the plan name and description, and an image to be displayed on the payment form. The script also sets the **data-locale** attribute to **auto**, which ensures that the payment form’s language will be automatically set based on the user’s location. The **data-zip-code** attribute is set to **false**, which means that the payment form will not require the user to enter their zip code.

As you can see in the code snippet, the columns for the quarterly and yearly plans are built in the same way as the monthly plan. The only differences are the values for the plan’s name, subtitle, and cost, as well as the values for the hidden input fields for the plan and the amount to be charged.

You can verify that your **payment.html** page works properly by displaying it in any browser. This can be easily done with PyCharm. You can hover over the HTML file and choose your favorite browser from the preview options located in the top-right corner of the **Edit** window (see _Figure 4.6_). You should then see a payment page, similar to the one displayed in _Figure 4.5_.

![Figure 4.6: Displaying an HTML file in the Browser Using PyCharm](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_4.6\_B21110.jpg)

Figure 4.6: Displaying an HTML file in the Browser Using PyCharm

This is how you can build a payments page that includes a form to collect payment information from users. We styled the payments page using the Bulma CSS framework, and the payment processing is handled using jQuery and the Stripe API. The page is divided into three columns, each displaying a different payment plan option, and the payment form is in the footer of each card. The Stripe API is used to generate a payment button that collects payment information and initiates payment processing.

In the next section, you will learn how to create a charge function in your application that handles user payments, using the Stripe API, and returns a payment confirmation page.

### Confirming User Payments <a href="#_idtextanchor068" id="_idtextanchor068"></a>

In the previous section, you learned that when a user chooses to buy a payment plan to access your application, we will promptly trigger the **/charge** page and furnish it with the name of the selected plan, as well as the corresponding payment amount in cents.

We can build the **charge()** function in our **app.py** file under the **index()** function. This function is part of the Code Bug Fixer web application and handles the **charge** process when a user selects a pricing plan and submits their payment information. The function is triggered when the user clicks the **Pay with Card** button in the pricing plan section of **payment.html**:

<pre><code><strong>@app.route("/charge", methods=["POST"])
</strong><strong>def charge():
</strong><strong>    amount = int(request.form["amount"])
</strong><strong>    plan = str(request.form["plan"])
</strong>    customer = stripe.Customer.create(
<strong>        email=request.form["stripeEmail"],
</strong><strong>        source=request.form["stripeToken"]
</strong>    )
    charge = stripe.PaymentIntent.create(
        customer=customer.id,
        amount=amount,
<strong>        currency="usd",
</strong><strong>        description="App Charge"
</strong>    )
<strong>    return render_template("charge.html", amount=amount, plan=plan)
</strong></code></pre>

You can find the complete **app.py** file here: [https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/blob/main/Chapter04%20CodeBugFixer/app.py](https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/blob/main/Chapter04%20CodeBugFixer/app.py).

The **@app.route("/charge", methods=\["POST"])** decorator creates a route to handle a **POST** request sent to the **/charge** endpoint. This means that when the form in the HTML template is submitted, it will send a **POST** request to this endpoint.

Both the **amount** and **plan** variables are assigned values that were previously sent by the user via a payment form, and they are used later in the function to create a new customer and charge the customer the appropriate amount based on the selected plan.

Then, we can create a new Stripe customer object using the Stripe API. The **stripe.Customer.create()** method takes two arguments – the email address of the customer and the payment source. In this case, the email address is obtained from the **stripeEmail** parameter in the **POST** request sent by the Stripe checkout form, and the payment source is obtained from the **stripeToken** parameter.

The **stripeToken** parameter is a unique identifier for the payment information provided by the user in the checkout form, such as credit card details or a payment app. Stripe uses this token to securely charge the user’s payment method for the specified amount. By passing the **stripeToken** parameter to the source argument of **stripe.Customer.create()**, the payment information is associated with the newly created customer object in Stripe.

We can then use the Stripe API to create a charge object that is associated with the customer who provided their payment information. The **stripe.PaymentIntent.create()** method creates a new charge object in the Stripe API with the following arguments:

* **customer**: This is the ID of the Stripe customer object associated with the payment. The **customer.id** attribute is used to retrieve the ID of the customer object created in the previous step.
* **amount**: This is the amount of the charge in cents. The amount variable is set to the value passed in the **POST** request from the form.
* **currency**: This is the currency of the charge. In this case, it is set to **USD**.
* **description**: This is a brief description of the charge. In this case, it is set to **App Charge**.

After creating the charge, the function uses Flask’s **render\_template()** function to render the **charge.html** template and pass in the amount and plan variables. The **charge.html** template will be used to display a message to the user, indicating that their payment was successful.

Our final task when building the application is to create the **charge.html** file. This file will be used to display a confirmation message to the user after a successful charge has been made. The **render\_template** function used in the charge function of the **app.py** file specifies that the **charge.html** file will be used to render the message.

You can now open the **charge.html** file that we created in the **templates** folder and add the following code:

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Payment Confirmation</title>
</head>
<body>
<h1>Payment Confirmation</h1>
<p>You have successfully paid ${{ amount / 100 }} for the {{ plan }} plan for unlimited access to the Code Bug Fixer</p>
</body>
</html>
```

In this simple HTML page, the **\<body>** section contains a heading that says **Payment Confirmation**. The paragraph below the heading uses curly braces to display the amount and plan variables passed from the **charge()** function. Specifically, it displays the amount variable divided by **100** (because the amount variable is in cents) and the **plan** variable for the user to confirm the payment they have made.

When the **charge()** function is called and executed, it returns the **charge.html** file as a response, with the amount and plan variables passed as arguments to be rendered in the appropriate places in the HTML code.

Now that the payments infrastructure has been added to your app, you can test it by navigating to the relevant pages and clicking on the payment buttons. You can follow the following steps:

1. Run the **app.py** file to start up your Code Bug Fixer.
2. Create more than three bug-fixing requests to the ChatGPT API to be prompted to the **Payments** page (see _Figure 4.5_).
3. Click on the **Pay with Card** button on one of the payment plans.
4. Enter the following sample credit card details in the pop-up window (see _Figure 4.7_):
   * **Email**: **mrsmith@gmail.com**
   * **Card number**: **4242 4242 4242 4242**
   * **Expiry date**: **09 / 30**
   * **Security code**: **424**
5. Click the **Pay** button:

![Figure 4.7: Stripe Payment Information](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_4.7\_B21110.jpg)

Figure 4.7: Stripe Payment Information

Once you have submitted your payment, you should be redirected to a payment confirmation page that displays a message indicating that your payment has been successfully processed, as shown in _Figure 4.8_:

![Figure 4.8: The Confirmation Page](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_4.8\_B21110.jpg)

Figure 4.8: The Confirmation Page

In this section, you saw how to confirm user payments using the Stripe API in a Code Bug Fixer web application. We built **charge()** to handle the charge process when a user selects a pricing plan and submits their payment information. We also tested the payment infrastructure of the app using sample credit card details.

## Summary <a href="#_idtextanchor069" id="_idtextanchor069"></a>

This chapter focused on the implementation of a payment infrastructure into a web application using the Stripe API. It provided instructions on how to set up a Stripe account, create API keys, and configure the payment settings. You saw the importance of selecting the appropriate business strategy, such as subscription or one-time payment, before implementing payment options. You also saw how to track user visits and usage using a SQL database and how to create payment plans on a payment page. Additionally, the chapter outlined the functions required to retrieve and update the usage counter and described how to implement them to track a user’s payment status.

You learned how to build the **charge()** function, which handles the payment process when a user selects a pricing plan and submits their payment information. We covered the use of the Stripe API to create a new customer and charge object and render the **charge.html** template to display a confirmation message to the user. This section also provided instructions on how to test the payment feature using sample credit card details. The chapter provided a comprehensive guide on implementing a payment infrastructure in a web application, integrating the Stripe API and the ChatGPT API, from creating a Stripe account to handling payments and confirming user payments.

In [_Chapter 5_](https://learning.oreilly.com/library/view/building-ai-applications/9781805127567/B21110\_05.xhtml#\_idTextAnchor070), _Quiz Generation App the ChatGPT and Django_, you will learn how to integrate Cthe hatGPT API with **Django**, a full stack web framework that comes with many built-in features and is designed to handle larger and more complex web applications than Flask. Django includes everything from URL routing, database ORM, admin interface, to authentication and security features, providing a more comprehensive framework for web development. We will integrate Djnago with the powerful OpenAI GPT-3.5 turbo model for chat completions and explore how to keep track on the chat context.
