# 2. Building a ChatGPT Clone

## 2. Building a ChatGPT Clone <a href="#_idparadest-31" id="_idparadest-31"></a>

The first application in this chapter and in this book is going to be a ChatGPT clone that utilizes OpenAI’s powerful language model to generate human-like responses to user input. The application will be built using **Flask**, a lightweight web framework for Python, and will feature a simple and elegant frontend interface for users to interact with. With just a few lines of code, users will be able to input their text and receive a response generated by the OpenAI language model. Specifically, the application will be able to do the following:

* Render a simple browser chat interface to interact with a chatbot.
* The chatbot will accept user input and send it to the ChatGPT API.
* Display the response from the ChatGPT API to the user.
* Show chat history.

The clone app will be able to take in a user’s input, send it to OpenAI’s API, and receive a response, which will be displayed to the user in real time. The app will be customizable to allow for the use of different OpenAI models and other options such as the length of the generated text.

To keep our project simple, our chatbot will lack the ability to maintain a contextual conversation. While it will generate responses based on individual queries, it will not possess the memory to retain information from previous interactions. We will explore the ChatGPT API conversational context in [_Chapter 6_](https://learning.oreilly.com/library/view/building-ai-applications/9781805127567/B21110\_06.xhtml#\_idTextAnchor087), _Language Translation Desktop App with the ChatGPT API and Microsoft Word_, where we will use the GPT-3.5 turbo language model. There, we will explore techniques and tools that enable our chatbot to understand and respond coherently within the context of an ongoing dialogue.

In this chapter, we will cover the following topics:

* Creating a ChatGPT Clone using **Flask**.
* Generating frontend **HTML** for the ChatGPT clone.
* Intercepting ChatGPT API endpoints.
* OpenAI’s ChatGPT API for text generation.
* Passing user input from the frontend to the backend using AJAX.
* Displaying the generated text in the frontend.

When building a ChatGPT clone with **Flask**, there are a few things to keep in mind. It’s important to set up a Python virtual environment to keep your dependencies separate from other projects on your machine. This ensures that your project has all the necessary dependencies and won’t conflict with other projects. Additionally, make sure to securely store your ChatGPT API key to avoid unauthorized access. It’s also important to carefully manage your API requests, as the pricing is based on the number of tokens processed. Finally, Flask offers flexibility in terms of how you structure your application, but it’s important to keep your code organized and maintainable as your project grows.

## Technical Requirements <a href="#_idtextanchor039" id="_idtextanchor039"></a>

In order to fully benefit from this chapter, you will require some fundamental tools. In-depth explanations of all installations not covered in the preceding chapter will be provided.

You will require the following:

* Python 3.7 or later installed on your computer.
* An OpenAI API key, obtained from your OpenAI account
* A code editor, such as PyCharm (recommended)
* The Flask framework installed in your Python virtual environment

The code examples from this chapter can be found on GitHub at [https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/tree/main/Chapter02%20ChatGPTClone](https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/tree/main/Chapter02%20ChatGPTClone).

In the next section, we will start building the ChatGPT clone with Flask by setting up a backend that communicates with the ChatGPT API to generate responses to user input. You will create a simple Flask application and gradually enhance it by incorporating the ChatGPT API. We will also structure the code and store the ChatGPT API key as an environment variable to improve its security.

## Creating a ChatGPT Clone with Flask <a href="#_idtextanchor040" id="_idtextanchor040"></a>

To create a ChatGPT clone with Flask, you will need to set up a backend that communicates with the ChatGPT API to generate responses to user input. Flask is a popular Python web framework that can be used to create web applications, including ChatGPT clones. We will begin our project by creating a simple Flask application and gradually enhance it by incorporating the ChatGPT API, additional web pages, and the frontend.

To get started, initiate a new PyCharm project and give it the name **ChatGPT\_Clone**. Create a new file named **app.py** to serve as the backend of your application, where you’ll define your Flask application and interact with the ChatGPT API. Once you have created the project, you will need to install the Flask package using **pip**. You can do this by running the following command in your project’s terminal:

```
$ pip install flask
```

After installing Flask, you can start building your Flask application. To do this, you need to create a new Python file and import the Flask module. Then, you should create a new instance of the **Flask** class and pass your application’s name as an argument. Here’s how you can create a new Flask app in your **app.py** file:

```
from flask import Flask
app = Flask(__name__)
```

In Flask, a route is a URL path that a user can visit in your application. You can define routes using the **@app.route** decorator and a Python function. Let’s create a route that displays **Hello, World!** as follows:

```
@app.route("/")
def index():
    return "Hello, World!"
```

Finally, you can run your Flask app using the **app.run()** method. This will allow you to start a development server that you can access in your web browser:

```
if __name__ == "__main__":
    app.run()
```

Once you have created the run configuration, you can run your Flask application by clicking the **Run** button in PyCharm’s toolbar or by right-clicking on **app.py** and selecting the **Run** option. You will then see the URL to your **Flask** application in the **Run** window, as shown in _Figure 2.1_:

![Figure 2.1: Flask Application URL](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_2.01\_B21110.jpg)

Figure 2.1: Flask Application URL

With these steps, you can build a basic Flask application that displays **Hello, World!** when a user visits the root URL of the application. From here, you can add more routes, templates, and functionality to your Flask app to build more complex web applications with the ChatGPT API (see _Figure 2.2_).

![Figure 2.2: Flask Application Page](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_2.02\_B21110.jpg)

Figure 2.2: Flask Application Page

Every ChatGPT application starts with setting up your API key. When using ChatGPT API keys in a Python file, you would typically hardcode the keys directly into the file, just like you did when building _a simple ChatGPT API response_, which means the key is visible in the code itself. This can be a security risk if someone gains access to the code or if you accidentally push your code to a public repository.

On the other hand, adding the ChatGPT API key as an environment variable means that the key is stored outside the code base and can be accessed by the code at runtime. This makes it more secure because the key is not visible in the code itself and can be changed easily without modifying the code.

Another way to store your API key securely is by adding it to a separate file that is kept outside your Git repository. To follow that approach, let’s create the **config.py** and then use the **config** package to access it from the **app.py**. The following code is an example of how to structure both files accordingly:

config.py

```
API_KEY = "YOUR_API_KEY"
```

app.py

<pre><code>from flask import Flask
<strong>import config
</strong><strong>openai.api_key = config.API_KEY
</strong>app = Flask(__name__)
@app.route("/")
def index():
    return "Hello, World!"
if __name__ == "__main__":
    app.run()
</code></pre>

Important note

If you want to push your project to a **Git** repository, it is important to add the **config.py** file to your project’s **.gitignore** file to prevent accidentally committing your API key to version control.

Let’s modify the functionality of your **index()** function by configuring it to return an HTML template from the frontend:

<pre><code>@app.route("/")
def index():
<strong>    return render_template("index.html")
</strong></code></pre>

This code defines a Flask route for the root URL of the application, **("/")**. When a user navigates to the root URL, Flask will call the function decorated with **@app.route("/")**.

The function returns the result of **render\_template("index.html")**. The **render\_template** function is a Flask method that renders an HTML template. In this case, it renders the **index.html** template that will be created in the text section. You can also modify your imports to incorporate the **render** function:

<pre><code><strong>from flask import Flask, render_template
</strong></code></pre>

The purpose of this code is to serve the initial web page when a user navigates to the application. The **index.html** file is typically the first page that a user will see when they load a web application. This is where the user will enter their initial input to start the chat with the ChatGPT API.

The next step is to build a function that will get the response from the ChatGPT API, so you can use that response in your chat clone. You can do that easily, by building the **get\_bot\_response()** function, just under the **index()** function:

```
@app.route("/get")
def get_bot_response():
    userText = request.args.get('msg')
    response = openai.Completion.create(
        engine="text-davinci-003",
        prompt=userText,
        max_tokens=1024,
        n=1,
        stop=None,
        temperature=1,
    )
    answer = response["choices"][0]["text"]
    return str(answer)
```

This code sets up a **/get** route for the Flask app. When a user makes a request to this route, the **get\_bot\_response()** is called.

The **request.args.get()** method is used to retrieve the value of the **msg** parameter from the URL query string. This parameter is used as the input for the ChatGPT API. Later, we will create a button on our frontend that will activate the **/get** upon selection.

The **openai.Completion.create()** method is used to generate a response from the ChatGPT API. It takes in several parameters, such as the engine to use, the prompt to provide to the API, and the number of tokens to generate in the response.

After generating the response, the function extracts the response text from the API’s JSON response using dictionary keys. Finally, the response is returned as a string.

When a user types a message and hits send, the JavaScript code will make an HTTP request to this route to get the AI response and then display it on the web page.

To finalize the backend of your chatbot application, it’s important to update your imports and add any necessary packages for the **get\_bot\_response()**:

<pre><code><strong>from flask import Flask, request, render_template
</strong><strong>import openai
</strong>import config
</code></pre>

This is how you can efficiently create a Flask application by installing Flask, defining routes, setting up the API key, creating an HTML template, and building a function to get the response from the ChatGPT API. You also learned how to structure the configuration files and we emphasized the importance of securing the API key.

In the next section, you will learn how to connect the backend endpoints to the frontend of the chat application. We will also use jQuery to handle communication between the frontend and the backend, allowing for real-time messaging in the chat application.

## Frontend HTML Generation <a href="#_idtextanchor041" id="_idtextanchor041"></a>

Let’s start creating the HTML and **CSS** necessary to generate the frontend of our chat application. We will be using HTML, CSS, and **Bootstrap** to create the user interface and **jQuery** to handle the communication between the frontend and the backend. The HTML and CSS will be responsible for creating the structure and style of the user interface.

When creating a Flask web application, it is recommended to keep your HTML files in a separate folder called **templates**. This is because Flask uses the **Jinja2** template engine, which allows you to write reusable HTML code in a more modular way by separating it into smaller, reusable pieces called templates.

To create the **templates** folder, simply create a new directory in your project directory and name it **templates**. Inside the **templates** folder, you can create your HTML file, called **index.html** in this case. To do that, right-click on the **templates** folder and select **New** | **HTML file**. Here is what the project directory should look like:

```
ChatGPTChatBot/
├── config.py
├── app.py
├── templates/
│   └── index.html
```

Creating a **templates** folder is important because it allows you to organize your HTML files separately from your Python code, which makes it easier to manage and modify your web application. Additionally, the Flask framework is specifically designed to look for the templates folder in order to render HTML templates, so creating this folder is necessary for the proper functioning of your Flask application.

We can now create the frontend of our chat application using HTML and **Bootstrap**. Initially, our frontend code will contain a basic layout with a chat window, an input field, and a submit button. You can include the following code in your **index.html** file:

```
<!DOCTYPE html>
<html>
<head>
    <title>OpenAI GPT Chat</title>
</head>
<body>
    <div class="container">
        <h2>OpenAI GPT Chat</h2>
        <hr>
        <div class="panel panel-default">
            <div class="panel-heading">Chat Messages</div>
            <div class="panel-body" id="chat">
                <ul class="list-group">
                </ul>
            </div>
        </div>
        <div class="input-group">
            <input type="text" id="userInput" class="form-control">
            <span class="input-group-btn">
                <button class="btn btn-default" id="submit">Submit                    </button>
            </span>
        </div>
    </div>
</body>
</html>
```

The **\<!DOCTYPE html>** declaration at the beginning of the code indicates the document type and version. The **\<html>** tag indicates the start of the HTML document, and the **\<head>** tag contains information about the document, such as the title of the document, which is specified in the **\<title>** tag. The **\<body>** tag contains the visible content of the document that is displayed in the browser, which includes the chat history and user messages.

In HTML, the **div** element is a container that is used to group other HTML elements together and apply styles to them as a group. It does not have any inherent semantic meaning, but its flexibility allows web developers to create layouts and organize content in a structured manner.

The first **\<div>** elementhas a class attribute of container. The entire chat application will be contained within this container. We also have an **\<h2>** element with the text **"OpenAI GPT Chat"**. This is the title of the chat application.

Next, we have an **\<hr>** element, which is used to create a horizontal line to separate the title from the rest of the chat interface. Following that, we have another **\<div>** element with a class attribute of **panel panel-default**. The **panel** will construct a bordered container that encompasses the content within and provides additional space around it through padding. This class is used to create a panel that will contain the chat message history. In the chat history window, there are two more elements.

The first **\<div>** element has a class attribute of **panel-heading** and contains the text **"Chat Messages"**. This is the heading for the panel that will contain the chat messages.

The second **\<div>** element has a class attribute of **panel-body** and an **id** attribute of **chat**. This element will be used to display the chat messages. Inside this **\<div>** element, we have an unordered list **\<ul>** element with a class attribute of **list-group**, which will contain the individual chat messages.

Next, we will build the input box where users can enter their messages and a submit button to send the message to the server for processing. The input box is created using the **\<input>** tag with **type="text"**. The input box has a class of **"form-control"**, which is a Bootstrap class for styling the form control elements.

The submit button is created using the **\<button>** tag with an ID of **submit**. The **input-group** class is a Bootstrap class used to group the input box and the submit button together.

Once the basic HTML file is created, you can activate your application by running the **app.py** file (see _Figure 2.3_).

![Figure 2.3: Initial ChatGPT Clone Frontend](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_2.03\_B21110.jpg)

Figure 2.3: Initial ChatGPT Clone Frontend

The interface will have a heading that says **OpenAI GPT Chat**, a chat panel where messages will be displayed, and an input box at the bottom where the user can type their message. There will also be a **Submit** button next to the input box. However, the chat functionality will not be working yet as the backend endpoints are not connected to the frontend of the application.

In this section, we discussed how to create the frontend of a chat application using HTML. We created the **templates** folder in Flask for reusable HTML templates for a basic chat interface with a chat window, input field, and a submit button. We can now explore different ways to customize the application’s appearance, such as changing fonts and adding icons, to make it even more visually appealing.

## Enhancing the ChatGPT Clone Design <a href="#_idtextanchor042" id="_idtextanchor042"></a>

In order to enhance the design and aesthetics of the ChatGPT Clone, we will be applying some CSS code. By applying CSS modifications, we can improve the overall visual appeal of the chat application and create a more user-friendly interface.

Let’s first add an external style sheet provided by the Bootstrap framework. To do that, under the page title, you can add the following:

```
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
```

When added to the HTML code, it allows the use of the various classes provided by Bootstrap to style the web page. This link points to version **3.3.7** of the Bootstrap framework, and it includes various CSS rules for styling common HTML elements such as headings, paragraphs, forms, and buttons, among others. Using Bootstrap can help to ensure consistency in the design of the web page while also simplifying the task of styling and making the page responsive to different screen sizes.

Next, under the Bootstrap link, we can include the CSS code that includes customizing the background color and text color of the body element, setting the **margin-top** property of the **container** class, adjusting the height and overflow properties of the chat messages area, and styling the submit button and input field:

```
    <style>
        body {
            background-color: #35372D;
            color: #ededf2;
        }
        .container {
            margin-top: 20px;
        }
        #chat {
            height: 400px;
            overflow-y: scroll;
            background-color: #444654;
        }
        .list-group-item {
            border-radius: 5px;
            background-color: #444654;
        }
        . submit {
            background-color:#21232e;
            color: white;
            border-radius: 5px;
        }
        .input-group input {
            background-color: #444654;
            color: #ededf2;
            border: none;
        }
}
    </style>
```

The **body** rule sets the background color of the page to a dark greenish-gray color and the text color to a light gray color. The **.container** rule applies a 20-pixel margin on top of the container element, which will push the chat interface down a bit from the top of the page. The **#chat** rule sets the height of the chat message display area to 400 pixels and applies a vertical scrollbar to the area when the content exceeds the height limit.

The **.list-group-item** block sets the border radius and background color of the list items displayed in the chat panel. The **.submit** block sets the background color, text color, and border radius of the submit button. The **.input-group** input block styles the input field within the input group, setting the background color and text color and removing the border.

Those styles contribute to a cohesive and visually appealing design. You can now rerun the application to see the finalized style of the ChatGPT clone application.

In this section, we improved the design of the ChatGPT clone using CSS code, including an external style sheet from Bootstrap and custom CSS modifications. In the next section, you will learn how to intercept ChatGPT API endpoints using Flask. This will allow you to create custom routes to send and receive HTTP requests between the frontend of the ChatGPT clone application and the backend server.

## Intercepting ChatGPT API Endpoints <a href="#_idtextanchor043" id="_idtextanchor043"></a>

Our ChatGPT clone needs to use JavaScript to handle user interactions with the chat application in real time. To do that, we can use a jQuery script that listens for a click on the submit button, gets the user input from the input field, sends a **GET** request to the server with the user input as a query parameter, and then receives a response from ChatGPT. The use of JavaScript in this way will enable the chat application to update and display new chat messages without the need for a page refresh, making for a more seamless and user-friendly experience.

We can write the JavaScript code just under the **input-group** class, as shown here:

<pre><code>        &#x3C;div class="input-group">
            &#x3C;input type="text" id="userInput" class="form-control">
            &#x3C;span class="input-group-btn">
                &#x3C;button class="btn btn-default" id="submit">Submit
                   &#x3C;/button>
            &#x3C;/span>
        &#x3C;/div>
    &#x3C;/div>
<strong>    &#x3C;script src="https://ajax.googleapis.com/ajax/libs/        jquery/3.2.1/jquery.min.js">&#x3C;/script>
</strong><strong>    &#x3C;script>
</strong><strong>        $("#submit").click(function(){
</strong><strong>            var userInput = $("#userInput").val();
</strong><strong>            $.get("/get?msg=" + userInput, function(data){
</strong><strong>                $("#chat").append("&#x3C;li class='list-group-item'>&#x3C;b>You:                     &#x3C;/b> " + userInput + "&#x3C;/li>");
</strong><strong>                $("#chat").append("&#x3C;li class='list-group-item'>&#x3C;b>                     OpenAI:&#x3C;/b> " + data + "&#x3C;/li>");
</strong><strong>            });
</strong><strong>        });
</strong><strong>    &#x3C;/script>
</strong>&#x3C;/body>
&#x3C;/html>
</code></pre>

Firstly, we included the jQuery library from the Google **Content Delivery Network** (**CDN**). The jQuery library is used to add an event listener to the submit button. The **$("#submit")** selector is used to select the HTML element with the ID of **submit**, which is the submit button in the chat application. The **.click()** method is then used to attach a click event listener to this element. Every time the user clicks the submit button, the rest of the code in the JavaScript function will take action.

The **function()** code block that follows is the event handler function that is executed when the submit button is clicked. Within this function, the **var userInput** variable is used to retrieve the value entered by the user in the chat input field. This value is obtained using the jQuery selector **$("#userInput")** to select the HTML element with the ID of **userInput**, which is the chat input field. The **.val()** method is then used to get the value entered by the user in this field and store it in the **userInput** variable.

Then a **GET** request is sent to the server with the user input message as a parameter using the jQuery library’s **$.get()** method. The response from the server is received as the data parameter in the anonymous function.

Once the response is received, the code appends two new list items to the chat area, **(#chat)**, in the HTML document using the jQuery library’s **append()** method. The first list item shows the user’s input message as **"You: \<message>"** in bold. This item will record and show the user input in the chat history. The second list item shows the response from the ChatGPT API as **"OpenAI: \<response>"** in the chat history.

Once this step is done, you’ll be all set to utilize the ChatGPT clone application and easily exchange responses with the ChatGPT API through a user-friendly interface. To get started, simply run the **app.py** file and begin chatting. Feel free to ask any question, and the answer will be saved in the chat history window. Here are a few examples (see _Figure 2.4_):

* Who invented the light bulb?
* Is the Panda a type of bear?
* Is it possible to divide a number by zero?
* If I have two apples and I eat a half apple, how many apples will I have left?

![Figure 2.4: ChatGPT Clone Responses](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_2.04\_B21110.jpg)

Figure 2.4: ChatGPT Clone Responses

Important note

The screenshot displayed here shows the application in the light color mode for clarity and visibility purposes. Please note that the actual application will be in dark mode, as per its default settings.

Going back to the PyCharm **Run** window, you can verify that all get requests were properly sent to ChatGPT. As you can see, we have received a response with a **code 200**, which means that the HTTP request was successful, and the server has returned the requested data. The server sends this code as a part of the HTTP response when it can process the client’s request and deliver the requested data:

```
127.0.0.1 - - [11/Apr/2023 14:37:04] "GET / HTTP/1.1" 200 –
127.0.0.1 - - [11/Apr/2023 14:37:26] "GET /get?msg=Who%20invented%20the%20lightbulb? HTTP/1.1" 200 –
127.0.0.1 - - [11/Apr/2023 14:37:53] "GET /get?msg=Is%20the%20Panda%20a%20type%20of%20bear? HTTP/1.1" 200 –
127.0.0.1 - - [11/Apr/2023 14:38:24] "GET /get?msg=Is%20it%20possible%20to%20divide%20a%20number%20by%20zero? HTTP/1.1" 200 –
127.0.0.1 - - [11/Apr/2023 14:44:39] "GET /get?msg=If%20I%20have%20two%20apples%20and%20I%20eat%20a%20half%20apple,%20how%20many%20apples%20will%20I%20have%20lest? HTTP/1.1" 200 –
```

Those are the instructions on how to use JavaScript to handle user interactions with a chat application. We used a jQuery script to listen to user inputs and send GET requests to the server with user input as a query parameter, then receive a response from the ChatGPT API. We also completed a few examples of how to use the ChatGPT clone and verify that all get requests were properly sent to ChatGPT, with a response code of 200. You are now ready to build more functional AI applications.

## Summary <a href="#_idtextanchor044" id="_idtextanchor044"></a>

In this chapter of the book, you were introduced to the process of building a ChatGPT clone, which is a chatbot that utilizes OpenAI’s language model to generate human-like responses to user input. The application was built using Flask, a lightweight web framework for Python, and was customizable to allow for the use of different OpenAI models and other options such as the length of the generated text.

We also covered topics such as creating and generating the frontend HTML for the ChatGPT clone, intercepting ChatGPT API endpoints, passing user input from the frontend to the backend using AJAX, and displaying the generated text in the frontend.

In [_Chapter 3_](https://learning.oreilly.com/library/view/building-ai-applications/9781805127567/B21110\_03.xhtml#\_idTextAnchor046), you will learn how to create and deploy an AI-powered code bug fixing SaaS application using Flask and the ChatGPT language model. You will become proficient in using the ChatGPT API. You will learn how to create a web form that accepts user inputs, deploy the application to the Azure cloud platform, and integrate it with a WordPress website. After completing the chapter, you will have the necessary skills to make a ChatGPT application accessible to individuals worldwide.
