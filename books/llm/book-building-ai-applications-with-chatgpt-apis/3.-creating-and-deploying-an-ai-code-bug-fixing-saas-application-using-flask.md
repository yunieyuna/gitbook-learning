# 3. Creating and Deploying an AI Code Bug Fixing SaaS Application Using Flask

## 3. Creating and Deploying an AI Code Bug Fixing SaaS Application Using Flask <a href="#_idparadest-40" id="_idparadest-40"></a>

In this chapter, we will dive into the creation and deployment of an AI-powered code bug-fixing SaaS application using **Flask**. This application will leverage OpenAI’s GPT-3 language model to provide code error explanations and fixes to users. With the rapid growth of software development, the need for effective and efficient error-debugging solutions has become more important than ever. By building this SaaS application, we aim to provide developers with a powerful tool to speed up their debugging process and improve the quality of their code.

To develop this SaaS application, we will be utilizing a tool that you may already be well acquainted with, namely, the Flask framework for building web applications in Python. Our aim is to become proficient in utilizing this framework to build an effective and scalable web application that can deliver efficient code error solutions to its users. Furthermore, we will be utilizing OpenAI’s GPT-3 language model to provide natural language explanations and code fixes.

In this chapter, we will learn about the following:

* Building a code bug-fixing SaaS application using Flask.
* Using the ChatGPT API to generate explanations and solutions to code errors.
* Creating a web form that accepts user input for code and error messages
* Designing a web interface to display the generated explanations and solutions.
* Deploying an application to the Azure cloud platform.
* Integrating an application with a WordPress website.

Upon completing this chapter, you will have the necessary skills to make your ChatGPT application accessible to individuals worldwide.

## Technical Requirements <a href="#_idtextanchor048" id="_idtextanchor048"></a>

The technical requirements for this project are as follows:

* Python 3.7 or later installed on your machine.
* A code editor, such as PyCharm (recommended).
* A Python virtual environment.
* The Flask web framework installed in the virtual environment
* An OpenAI API key.
* Access to Microsoft Azure.

The code examples from this chapter can be found on GitHub at [https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/tree/main/Chapter03%20CodeBugFixer](https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/tree/main/Chapter03%20CodeBugFixer).

## Performing Multiple ChatGPT API Requests <a href="#_idtextanchor050" id="_idtextanchor050"></a>

Let’s first dive into the ChatGPT API requests and learn how to build your project and the **app.py** file. In this project, we will explore how to make multiple ChatGPT API requests to get the explanations and fixed code for our input queries. We will go through each step of the process and provide clear examples, so you can follow along with ease.

To fix users’ code, ChatGPT needs two key components: some buggy code and the error provided by the system. The idea behind the Code Bug-Fixing application is that you provide ChatGPT with two separate requests simultaneously (see _Figure 3.1_):

* **Request 1**: ChatGPT uses the buggy code and the error to fix the code.
* **Request 2**: ChatGPT uses the buggy code and the error to explain the error to the user in plain English.

![Figure 3.1: Code Bug Fixer Request/Response Map](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_3.01\_B21110.jpg)

Figure 3.1: Code Bug Fixer Request/Response Map

As shown in _Figure 3.2_, the design of the code bug-fixing app is a web application with a clean and modern interface. It contains a form that allows the user to enter the code and the associated error. Upon submission of the form, the app sends the code and error to the server and displays the resulting explanation and fixed code in two separate text areas.

The design of the user interface is simple and intuitive, with two text areas for code and error input, and two read-only text areas for displaying the generated explanation and fixed code. The app’s layout is clean, with a blue and white color scheme and a centered header that displays the app’s name. The app is designed to provide a seamless user experience for identifying and fixing code errors.

![Figure 3.2: Code Bug Fixer App User Interface](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_3.02\_B21110.jpg)

Figure 3.2: Code Bug Fixer App User Interface

Our application will take buggy code and an error and provide two requests simultaneously: one to fix the code and the other to explain the error to the user. The app will have an efficient interface with a simple layout, allowing for a seamless user experience. Now, we can go over creating the necessary files and folders for the **CodeBugFixer** project in PyCharm, including the **templates** folder, which will hold the HTML templates for the Flask app, and the **config.py** and **app.py** files to establish the foundation for utilizing the ChatGPT API in the **CodeBugFixer** app.

## Setting Up the Code Bug Fixer Project <a href="#_idtextanchor051" id="_idtextanchor051"></a>

Creating a PyCharm project is an essential first step in any Python development process. By following a few simple steps, you can create a new PyCharm project in just a few minutes. Once you’ve set up your project, you’ll be ready to start building and testing your code:

1. Open PyCharm: Double-click on the **PyCharm** icon on your desktop or search for it in your applications folder to open it.
2. On the PyCharm welcome screen, click on **Create New Project** or go to **File** | **New Project**.
3. Choose the directory where you want to save your project. You can either create a new directory or select an existing one.
4. Select the Python interpreter: Choose the version of Python you want to use for your project.
5. Configure project settings: Give your project the name **CodeBugFixer**, and choose a project location.
6. Once you’ve configured all the settings, click **Create** to create your new PyCharm project.

After creating a new PyCharm project, the next step is to create the necessary files and folders for the **CodeBugFixer** project.

Firstly, create two new Python files, called **app.py** and **config.py**, in the root directory of the project. The **app.py** file is where the main code for the **CodeBugFixer** app will be written, and the **config.py** file will contain any sensitive information such as API keys and passwords.

Next, create a new folder called **templates** in the root directory of the project. This folder will contain the HTML templates that the Flask app will render. Inside the **templates** folder, create a new file called **index.html**. This file will contain the HTML code for the home page of the **CodeBugFixer** app.

The project structure should look like the following:

```
CodeBugFixer/
├── config.py
├── app.py
├── templates/
│   └── index.html
```

By following these steps, you have created the necessary files and folders for your **CodeBugFixer** project in your PyCharm project. You can now start writing the code for your Flask app in the **app.py** file and the HTML code in the **index.html** file.

Once you have the correct interpreter, you can open the terminal within PyCharm by going to **View** | **Tool Windows** | **Terminal**. Check your terminal and ensure that you can see the **(venv)** indicator to confirm that you are working within your virtual environment. This is an essential step to prevent conflicting package installations between projects and guarantee that you are using the correct set of dependencies.

In the terminal window, you can install any necessary libraries as follows:

```
(venv)$ pip install flask
(venv)$ pip install openai
```

Finally, in order to establish the foundation for utilizing the ChatGPT API in your **CodeBugFixer** app, you’ll need to add the following code to **config.py** and **app.py**:

config.py

```
API_KEY = <Your API Key>
```

app.py

```
from flask import Flask, request, render_template
import openai
import config
app = Flask(__name__)
# API Token
openai.api_key = config.API_KEY
@app.route("/")
def index():
    return render_template("index.html")
if __name__ == "__main__":
    app.run()
```

The **config.py** file will securely hold your OpenAI API key. Make sure to replace **\<Your API Key>** with the actual API key that you obtained from OpenAI.

The **app.py** file is a Python script that defines a Flask application. It imports the **Flask** module and the necessary libraries for the **CodeBugFixer** project. It takes the API key provided in the **config.py** file. The script defines a route for the home page and renders the **index.html** template using Flask’s **render\_template** function.

To set up the **CodeBugFixer** project, you had to create a new PyCharm project, configure project settings, create necessary files and folders for the project, install Flask and OpenAI libraries, and add code to the **config.py** and **app.py** files. The **config.py** file securely holds the OpenAI API key, while the **app.py** file defines a Flask application and renders the **index.html** template.

In the next section, we will modify the **index()** function in the backend of the Code Bug-Fixing application to ensure that it can distinguish between **GET** and **POST** requests. We will also use the OpenAI GPT-3 API to generate explanations and fixed code for the user’s input, which we will then pass to the **index.html** template using the **render\_template** function.

## Implementing the Code Bug Fixer Backend <a href="#_idtextanchor052" id="_idtextanchor052"></a>

The backend of the Code Bug-Fixing application should ensure that we properly send our buggy code to ChatGPT and, on the other side, receive the correct response. For this reason, you need to make sure that the **index()** function is able to clearly distinguish between **GET** and **POST** requests. You can add the following modification to the **index()** function to achieve that:

```
@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        # Code Errr
        code = request.form["code"]
        error = request.form["error"]
        prompt = (f"Explain the error in this code without fixing it:"
                  f"\n\n{code}\n\nError:\n\n{error}")
        model_engine = "text-davinci-003"
```

This function checks the HTTP request method – whether it is a **GET** or **POST** request. If the request method is **POST**, it means that the user has submitted a form from the **index.html** template. In that way, you can make sure that the ChatGPT API is invoked only after the user has submitted the form and clicked on the **Code Fix** button, which we will construct in the upcoming section.

The function then retrieves the user’s input in the **Error Code** and **Enter Error** fields from the form and stores them in the **code** and **error** variables, respectively. Those variables will hold the code that the user wants to fix and the error code received. The extracted **code** and **error** variables are then used to create a prompt that is passed to the OpenAI GPT-3 API. Those variables are formatted using **f-strings** in Python.

For instance, let’s say the **code** and **error** variables take the following values:

```
code = print(1
error = SyntaxError: '(' was never closed
```

In this case, our prompt will be displayed as follows:

```
Explain the error in this code without fixing it:
print(1
Error:
SyntaxError: '(' was never closed
The API is instructed to generate an explanation for the error in the code.
```

The **prompt** variable provides a clear and specific task for the ChatGPT model to perform and ensures that the output generated by the model will be relevant to the user’s input.

You can set the **text-davinci-003** string value to the **model\_engine** variable. This variable is later used to specify the OpenAI language model to be used for both text completions. In this case, **text-davinci-003** is one of the most capable and versatile models provided by OpenAI.

Inside the **if** statement, you can now call the ChatGPT API to construct both **explanation\_completion** and **fixed\_code\_completion** for the user:

```
       explanation_completions = openai.Completion.create(
           engine=model_engine,
           prompt=prompt,
           max_tokens=1024,
           n=1,
           stop=None,
           temperature=0.2,
        )
        explanation = explanation_completions.choices[0].text
        fixed_code_prompt = 
            (f"Fix this code: \n\n{code}\n\nError:\n\n{error}."
            f" \n Respond only with the fixed code."
        )
        fixed_code_completions = openai.Completion.create(
            engine=model_engine,
            prompt=fixed_code_prompt,
            max_tokens=1024,
            n=1,
            stop=None,
            temperature=0.2,
        )
        fixed_code = fixed_code_completions.choices[0].text
```

The preceding code makes use of the ChatGPT API to generate completions based on a given prompt. The **openai.Completion.create()** function is called twice in this code snippet to generate two different completions: **explanation\_completions** and **fixed\_code\_completions**.

After the **openai.Completion.create()** function is called twice, the **explanation** and **fixed\_code** variables are assigned the generated text from the choices attribute of the two objects, respectively. These generated texts will be used in the next steps of the code to display the explanations and fixed code to the user.

Finally, you can use the **render\_template** function to update an HTML template with the ChatGPT response:

```
        return render_template("index.html",
                               explanation=explanation,
                               fixed_code=fixed_code)
```

The function takes two parameters: the first is the name of the template to render, and the second is a dictionary of variables that will be used in the template. The variables passed to the template are **explanation** and **fixed\_code**. Now, **explanation** is the text generated by the ChatGPT API that explains the error in the user’s code, and **fixed\_code** is the text generated by the ChatGPT API that represents the fixed version of the user’s code.

The variables are passed to the **index.html** template so that they can be displayed to the user. The template will use these variables to dynamically update the page content with the explanation and fixed code generated by the API.

After executing your Flask application, no error should be displayed. Nevertheless, your browser will show a completely blank screen since our **index.html** file is empty. Our next task is to create that file, and this will be discussed in the following section.

That is how you can modify the **index()** function to ensure that the ChatGPT API is only invoked after the user has submitted the form and clicked on the **Code Fix** button. We also saw how to generate explanations and fixed code using the ChatGPT API based on user input and how to update an HTML template with the ChatGPT response using the **render\_template** function.

In the next section, you will learn how to create an **index.html** file and construct the **Code Fix** button, which allows users to submit their code for debugging. You will also learn how to use JavaScript and AJAX to handle the form submission and display the response from the Flask application without reloading the page.

## Using Text Areas and Containers <a href="#_idtextanchor053" id="_idtextanchor053"></a>

In this section, you will learn how to create a simple user interface for your **CodeBugFixer** application using HTML and CSS. We will walk through the process of designing a simple form for users to input their code and error message and display the results of the ChatGPT API call. By the end of this section, you will have a fully functional web application that can help users fix errors in their code.

To modify the **index.html** file, first, you need to open the file located in the **templates** folder of your project. You can open this file in any text editor, or you can use the built-in HTML editor in PyCharm. Once you have the file open, you add the basic HTML structure:

```
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Code Bug Fixer</title>
</head>
<body>
<div class="header">
    <h1>Code Bug Fixer</h1>
</div>
</body>
</html>
```

The **\<title>** tag sets the title of the HTML page to **Code Bug Fixer**. This is the text that will appear on the browser tab when the page is loaded. It is also used by search engines to display the title of the page in search results.

Then, you can use the **\<h1>** tag to create a header on the web page with the text **Code Bug Fixer** in large font.

Next, we will add an input form to our **index.html** file. This form will allow the user to input their code and the corresponding error message, and then hit the **Code Fix** button to trigger the ChatGPT API to fix their code and provide an explanation. You can place the form just under the header **\<div>** tag:

```
<div class="header">
    <h1>Code Bug Fixer</h1>
</div>
<form action="/" method="post">
    <button class="submit-button" type="submit">Code Fix</button>
    <div class="container">
        <div class="left-column">
            <textarea name="code" placeholder="Enter Code"></textarea>
            <textarea name="error" placeholder="Enter Error">                </textarea>
        </div>
        <div class="right-column">
            <textarea class="fixed-code" name="fixed-code"                placeholder="Fixed Code" readonly>{{ fixed_code }}                </textarea>
            <textarea class="explanation" name="explanation"                placeholder="Explanation" readonly>{{ explanation }}                </textarea>
        </div>
    </div>
</form>
```

The form is enclosed in HTML **\<form>** tags, with the **action** attribute set to **"/"** and the **method** attribute set to **post**. This means that when the user submits the form, the data will be sent to the server at the root URL **("/")** using the HTTP **POST** method. This refers to our **index()** function in the **app.py** file.

Inside the form, we have two text areas with the **name** attributes set to **code** and **error**, respectively. These will allow the user to input their code and error message.

The form also contains a **submit** button with the **submit-button** class. When the user clicks this button, the form will be submitted and the data will be sent to the backend server.

The form is divided into two columns using a **\<div>** tag with the **container** class. The left column contains the code and error message text areas, while the right column contains the fixed code and explanation text areas.

The fixed code and explanation text areas have the **name** attributes set to **fixed-code** and **explanation**, respectively. They are also set to **readonly**, so the user cannot modify their content. These text areas will be updated with the fixed code and explanation generated by the ChatGPT API after the user submits the form.

Now that you have added the necessary HTML code for the **index** page, let’s run the Flask app and see how it looks in the browser. When you run the Flask app, you should see a page with a header that says **Code Bug Fixer** and a form with two text areas to enter your code and the error message. There is also a submit button labeled **Code Fix**. On the right side of the form, you will see two more text areas that will display the fixed code and the explanation. However, these text areas will be initially empty until the user enters the code and error message and clicks the **Code Fix** button (see _Figure 3.3_).

Currently, the app’s appearance might not be visually appealing since we have not incorporated any styling into the HTML.

![Figure 3.3: HTML-based frontend of the Code Bug Fixer app](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_3.03\_B21110.jpg)

Figure 3.3: HTML-based frontend of the Code Bug Fixer app

Finally, we will add some CSS to our application to style the HTML elements. The CSS code will define the fonts, colors, sizes, and positions of the elements on the page. We will add CSS code to our **index.html** file to enhance the look and feel of our application. With these styling improvements, our app will become more visually appealing and easier to use for our users.

You can add your CSS code under the **title** inside the **head** of the **index.html** file:

```
    <title>Code Bug Fixer</title>
    <style type="text/css">
        body {
            font-family: Arial sans-serif;
            background-color: #f6f7f9;
        }
```

Firstly, let’s open the CSS style block. It indicates that the following code is CSS and will be applied to the HTML elements in the web page.

The CSS code targets a **\<body>** element in the HTML. In CSS, you can target elements using their tag name, class name, or ID. Here, we are targeting the entire body of the web page.

Here, we can also set **font-family** to **Arial sans-serif**, which means that any text inside the **body** element will be displayed using the Arial font, or a similar sans-serif font if Arial is not available. We can also set the background color of the body to a light grayish-blue color:

```
        .header {
            background-color: #3b5998;
            color: #ffffff;
            padding: 15px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: bold;
        }
        .container {
            display: flex;
            justify-content: space-between;
            padding: 15px;
        }
```

The **.header** class specifies the background color, text color, padding, and alignment for the header. Here, the text is centered using the **text-align** property.

The **.header h1** class **font-size** property is set to **28** pixels, **font-weight** is set to **bold**, and **margin** is set to **0**, so there is no space between the top of the page and the header.

The **.container** class’ **display** property is set to **flex** to allow us to use Flexbox for layout, and **justify-content** is set to **space-between** to evenly distribute the contents of the container across the horizontal axis:

```
        .left-column, .right-column {
            width: 49%;
            padding: 15px;
        }
        textarea {
            width: 100%;
            height: 200px;
            font-size: 16px;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #cccccc;
            border-radius: 5px;
            resize: none;
        }
        .fixed-code, .explanation {
            background-color: #e9ebee;
            color: #3b5998;
            font-weight: bold;
        }
```

Next, let’s design the two-column layout, where the left column contains the input fields for the user to enter their code and error, while the right column displays the output of the program.

The **.left-column** and **.right-column** classes were given a width of **49%** so that they take up almost an equal amount of space on the page. The **textarea** elements were styled to have a fixed width of **100%** and a height of **200px** to create a clear input field. The **resize: none** property ensures that the user cannot resize the input fields.

The **.fixed-code** and **.explanation** classes were given **bold** for **font-weight** to make them stand out from the input fields. This helps the user to quickly identify the output fields:

```
        .submit-button {
            background-color: #3b5998;
            color: #ffffff;
            font-size: 18px;
            font-weight: bold;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            margin-top: 15px;
            cursor: pointer;
        }
        .submit-button:hover {
            background-color:  #4b76be;
        }
    </style>
```

Our final goal is to make the **submit** button visually appealing and to give feedback to the user when they hover over it. We set the background color to a dark blue color (**#3b5998**) and the font color to white (**#ffffff**) to create contrast. We also added padding and a border radius to make the button more noticeable and attractive.

The **margin-top** property adds some space between the button and the text areas. Finally, we added the **:hover** pseudo-class to change the background color of the button when the user hovers over it, which provides visual feedback to the user that the button is interactive.

You have now completed the **index.html** file for the **CodeBugFixer** application. You can now run the **app.py** file and test the application to make sure everything is working correctly. In the next section, we will provide some examples of how to use the application to fix code bugs. Alternatively, you can try out your own code examples to see how the app performs.

That is how we can create a user interface for the **CodeBugFixer** application using HTML and CSS. We walked through designing a form for users to input their code and error message and display the results of the ChatGPT API call.

In the next section, you will learn how to test the **CodeBugFixer** application by writing test cases and verifying that it handles different scenarios correctly. You will also see examples of how the Code Bug Fixer app can fix code written in two different programming languages, Java and Python, and learn how to test the fixed code to confirm its accuracy.

## Testing the Code Bug Fixer App <a href="#_idtextanchor054" id="_idtextanchor054"></a>

Now, we will learn how to test our Code Bug Fixer application. We will write some test cases to ensure that the application is functioning correctly and handling different scenarios appropriately. Testing is a critical part of software development, as it ensures that the application works as intended and meets the user’s requirements.

The Code Bug Fixer app can fix any programming language, making it a versatile tool. Therefore, we will demonstrate its effectiveness by using examples written in two different programming languages: Java and Python.

The Python example has the following properties:

*   Code:

    ```
    def factorial(n):
        if n == 0:
            return 1
        else:
            return n * factorial(n-1)
    print("The factorial of 5 is: " + factorial(5))
    ```
* Error: **Type Error:**

This code is returning an error because it is attempting to concatenate a string and an integer in the **print** statement. The **factorial** function returns an integer, but it is being concatenated to the string **"The factorial of 5 is: "**.

To fix this code in the Code Bug Fixer app, you can follow these steps:

1. Paste the code inside the **Enter Code** field.
2. Paste the error inside the **Enter Error** field.
3. Left-click on the **Code Fix** button.

Once you complete the steps listed, the fixed code and the explanation generated by ChatGPT API will be displayed in the corresponding field. As depicted in _Figure 3.4_, the response from ChatGPT appears in bold font and is not editable. You can also see that the explanation is accurate.

![Figure 3.4: Code Bug Fixer processing some Python code](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_3.04\_B21110.jpg)

Figure 3.4: Code Bug Fixer processing some Python code

To ensure that the fixed code is functioning correctly, you can test it by running it in a Python IDE such as PyCharm or any other online Python compiler. By examining the explanation provided alongside the fixed code, you can confirm that it provides an accurate and detailed explanation of the error.

Finally, to verify that the Code Bug Fixer app works with any programming language, let’s try to fix the following Java code:

1.  Code:

    ```
    public class ComplexError {
        public static void main(String[] args) {
            String str = "Hello, World!";
            int length = str.length();
            for (int i = 0; i <= length; i++) {
                System.out.println(str.charAt(i));
            }
        }
    }
    ```
2.  Error:

    <pre><code><strong>Exception in thread "main" java.lang.StringIndexOutOfBoundsException
    </strong></code></pre>

The code is returning an error because the **for** loop is iterating from **0** to **length**, which is the length of the string. However, the index of the last character in the string is length **-1**, so when **i** equals **length**, the program will try to access an index that is out of bounds and throw an **IndexOutOfBoundsException** message.

Once you run the code through the Code Bug Fixer, you will get a response similar to the one depicted in _Figure 3.5_. You can verify that the fixed code and the description are correct. ChatGPT fixed the error because it changed the condition in the **for** loop from **i <= length** to **i < length**. By changing the condition to **i < length**, the loop only iterates up to the last index of the string and avoids accessing an index that does not exist.

This confirms that your Code Bug Fixer has the ability to differentiate between two distinct programming languages and was able to repair the code within a matter of seconds.

![Figure 3.5: Code Bug Fixer processing some Java code](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_3.05\_B21110.jpg)

Figure 3.5: Code Bug Fixer processing some Java code

This section explained how to test the Code Bug Fixer application by providing examples in the Python and Java programming languages. The application can fix any programming language, and the fixed code can be verified by running it in a Python or Java IDE. We saw how the application can differentiate between two programming languages and fix code within seconds.

In the next section, you will learn how to set up an Azure account, install the Azure CLI, and deploy your application to the cloud using the CLI. You will also learn how to create a **requirements.txt** file in the root directory of your project, listing all the Python packages and their specific versions that your app needs to run.

## Deploying the ChatGPT App to the Azure Cloud <a href="#_idtextanchor055" id="_idtextanchor055"></a>

Now let’s upload our Code Bug Fixer application to the **Azure** cloud platform. Azure is a cloud computing service provided by Microsoft that allows developers to host, manage, and scale their applications in the cloud. By hosting our application on Azure, we can make our application accessible to a wider audience. We will go through the steps required to create an Azure account, set up our application for deployment, and deploy it to Azure using the Azure CLI.

You can create your Azure account by following these steps:

1. Go to the Azure website at [https://azure.microsoft.com/free/](https://azure.microsoft.com/free/) and click on **Start free**.
2. Sign in with your Microsoft account or create one if you don’t have one.
3. Enter your personal information and payment details. You won’t be charged unless you upgrade to a paid plan.
4. Choose your subscription type and agree to the terms and conditions.
5. Verify your account by entering a phone number and entering the code you receive.
6. You can log in to your account at [https://signup.azure.com/](https://signup.azure.com/).
7. Once you log in, on the **Welcome** page, left-click on **Use an existing subscription in your account**. You will be automatically redirected to **portal.azure.com/#home**, where you can start using Azure services (see _Figure 3.6_).

![Figure 3.6: Azure home page](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_3.06\_B21110.jpg)

Figure 3.6: Azure home page

Important note

When deploying the Code Bug Fixer app to the Azure cloud, it is important to name the file containing the Flask app **app.py**. This is because Azure expects the main file to be named **app.py** for deployment to work properly.

To deploy our application on Azure, we need to install the Azure **command-line interface** (**CLI**). The CLI provides us with an efficient way to automate and manage our Azure resources. Next, you can find the steps to install the Azure CLI.

These are the steps for macOS users ([https://learn.microsoft.com/en-us/cli/azure/install-azure-cli-macos](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli-macos)):

1. Open your macOS Terminal.
2.  Install **brew**. Homebrew is a popular package manager for macOS:

    <pre><code><strong>$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    </strong></code></pre>
3.  Once Homebrew is installed, run the following command to install Azure CLI:

    <pre><code><strong>$ brew update &#x26;&#x26; brew install azure-cli
    </strong></code></pre>
4.  Verify that the installation was successful by running the following command:

    <pre><code><strong>$ az --version
    </strong></code></pre>
5.  This should display the version number of the Azure CLI that you just installed:

    <pre><code><strong>azure-cli                         2.47.0
    </strong><strong>core                              2.47.0
    </strong><strong>telemetry                          1.0.8
    </strong><strong>Dependencies:
    </strong><strong>msal                              1.20.0
    </strong><strong>azure-mgmt-resource               22.0.0
    </strong><strong>Python location '/opt/homebrew/Cellar/azure-cli/2.47.0/libexec/bin/python'
    </strong><strong>Extensions directory '/Users/martinyanev/.azure/cliextensions'
    </strong><strong>Python (Darwin) 3.10.11 (main, Apr  7 2023, 07:24:47) [Clang 14.0.0 (clang-1400.0.29.202)]
    </strong><strong>Legal docs and information: aka.ms/AzureCliLegal
    </strong><strong>Your CLI is up-to-date.
    </strong></code></pre>

These are the steps for Windows users ([https://learn.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli):](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli\):)

1. Open a web browser and navigate to [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows).
2. Scroll down to the section titled **Install or update** and click on the **Microsoft Installer (MSI)** tab.
3. Click on the **Latest release of the Azure CLI** button to start the MSI package download.
4. Once the MSI package has downloaded, double-click on the file to begin the installation process.
5. Follow the prompts in the installation wizard to complete the installation process.
6.  Once the installation is complete, open a Command Prompt window or PowerShell window and type the following:

    <pre><code><strong>$ az –version
    </strong></code></pre>

For Linux users ([https://learn.microsoft.com/en-us/cli/azure/install-azure-cli-linux?pivots=script](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli-linux?pivots=script)), you can type the following in the Terminal:

```
curl -L  | bash
```

This line will automatically download the installation script and you can follow all steps for setting up your Azure CLI.

Important note

After installing the Azure CLI, you may need to close and re-open your Terminal window to ensure that the CLI is fully recognized and operational.

You should now be able to use the Azure CLI on your Linux machine.

Before deploying your app to Azure using the CLI, you’ll need to log in to your Azure account from the CLI. This will enable you to manage your resources and perform other tasks related to your account.

To log in to your Azure account using the Azure CLI, you can type the following in the Terminal window:

```
$ az login
```

A pop-up window will appear asking you to enter your Azure account credentials. Enter your account email and password and click on the **Sign in** button. Once you are successfully logged in, you will see a message in the Command Prompt indicating that you are authenticated.

To prepare our app for deployment, we need to create a file called **requirements.txt** in the root directory of our **CodeBugFixer** project. This file will list all the Python packages and their specific versions that our app needs to run. Using a **requirements.txt** file is a common practice in Python projects to document and manage the project’s dependencies. It lists all the external packages and their versions that are necessary for the application to function properly. Each line in the **requirements.txt** file typically represents a separate package and may include a specific version number or a version range. Azure will use this file to install the dependencies in the server where our app will be hosted.

The project structure should look like the following:

```
CodeBugFixer/
├── config.py
├── app.py
├── requirements.txt
├── templates/
│   └── index.html
```

To create a **requirements.txt** file in your PyCharm project, follow these steps:

1. Right-click on your **CodeBugFixer** project folder in the project explorer on the left-hand side of PyCharm.
2. Select **New** | **File** from the **Context** menu.
3. In the **New File** dialog box, type **requirements.txt** as the filename.
4. Click the **Create** button.

Once the file is created, you can add the necessary libraries to it. To include Flask and OpenAI libraries, add the following lines to your **requirements.txt** file:

```
Flask==2.2.3
openai==0.27.4
```

Now that we have everything set up, it’s time to deploy the app to Azure. We’ll be using the Azure CLI to accomplish this. First, navigate to the root directory of your project, where the **app.py** and **requirements.txt** files are located.

Next, run the following command in the CLI:

```
$ az webapp up --name <app_name>
```

In this command, **webapp up** deploys the web app to Azure. Replace **\<app-name>** with a unique name of your choice.

After deploying the app, if everything is set up correctly, you should see a JSON output in the Azure CLI terminal. This output will contain information about the deployed app, such as the app name, URL, location, resource group, and other details. It will also include the status of the deployment, such as whether it was successful or whether there were any errors:

```
{
  "URL": "http://<app_name>.azurewebsites.net",
  "appserviceplan": "martinyanev94_asp_7277",
  "location": "location",
  "name": "Your App Name",
  "os": "Linux",
  "resourcegroup": "resourcegroup",
  "runtime_version": "python|3.10",
  "runtime_version_detected": "-",
  "sku": "PREMIUMV2",
  "src_path": "//Local/app/path"
}
```

After successfully deploying your app on Azure, you can access it from anywhere around the world using the URL provided in the JSON output. Simply copy the URL and paste it into your web browser’s address bar to open the app. You can also share this URL with others to let them use your Code Bug Fixer app.

If you want to upload the Code Bug Fixer app to your WordPress website, you can easily do so by using an **iframe**. Simply copy and paste the following code into the text editor, replacing **\<your\_app\_url>** with the URL of your deployed app:

```
<iframe src="<your_app_url> " width="100%" height="1000"></iframe>
```

This will embed the app into your website and allow your visitors to access it directly from your page.

Finally, you can access your deployed application from the Azure web portal. To access your app from your Azure web account, follow these steps:

1. Sign in to the Azure portal at [https://portal.azure.com/#home](https://portal.azure.com/#home).
2. In the left-hand menu, click on **App Services**.
3. From there, you will be able to manage the app that you deployed.

Here, you can modify or delete the deployment from your Azure web account (see _Figure 3.7_):

* To modify the deployment, you can upload a new version of your code using the Azure CLI or Azure portal.
* To delete the deployment, simply click on the **Delete** button on the **Overview** page of your app in the Azure portal.

![Figure 3.7: Azure cloud app management](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/Figure\_3.07\_B21110.jpg)

Figure 3.7: Azure cloud app management

That is how you can deploy your app on the Azure cloud using the Azure CLI. We listed all steps to create an Azure account, install the Azure CLI, and prepare the app for deployment. This section also emphasized that the main file of the app should be named **app.py** for proper deployment, and a **requirements.txt** file was needed to list all the Python packages required by the app to run. The steps to install the Azure CLI for macOS and Windows users were also listed.

## Summary <a href="#_idtextanchor056" id="_idtextanchor056"></a>

This chapter described the creation and deployment of an AI-powered SaaS application, Code Bug Fixer, which uses OpenAI’s GPT-3 language model to provide code error explanations and fixes to users. It covered building the application using Flask, creating a web form that accepts user input for code and error messages, and designing a web interface for displaying the generated explanations and solutions. The chapter also provided instructions on how to test and deploy the application to the Azure cloud platform, offering security and scalability features to the application.

Furthermore, you learned how to create a user interface for Code Bug Fixer using HTML and CSS, adding a basic HTML structure, a header, an input form, and two columns containing text areas for the user to enter their code and error message. The testing process involved running test cases for the application in two different programming languages, Python and Java. By following the given steps, users can check whether the application is repairing the code accurately or not. This chapter provided a comprehensive guide to building, testing, and deploying an AI-powered SaaS application that can help users fix errors in their code.

In [_Chapter 4_](https://learning.oreilly.com/library/view/building-ai-applications/9781805127567/B21110\_04.xhtml#\_idTextAnchor057), _Integrating the Code Bug Fixing Application with a Payment Service_, you will learn how to integrate the popular Stripe payment service into your web application using the Stripe API. The chapter will cover the step-by-step process of setting up a Stripe account, configuring the API keys, creating a form to collect user payment information, and processing payments securely through Stripe. Additionally, the chapter will explain how to track and store user data securely for future transactions and analysis.
