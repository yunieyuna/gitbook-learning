# 5. Quiz Generation App with ChatGPT and Django

## 5. Quiz Generation App with ChatGPT and Django <a href="#_idparadest-63" id="_idparadest-63"></a>

In this chapter, we will delve into the exciting world of combining the power of **ChatGPT**, a cutting-edge language model, with **Django**, the widely acclaimed Python framework for app development. Together, we will explore how to build a dynamic and interactive exam generation application that leverages artificial intelligence.

In the previous chapters, we primarily focused on Flask, a lightweight and basic web framework. However, in this chapter, we will focus on Django, a robust and advanced framework that has been instrumental in constructing some of the most renowned and widely used applications, including Instagram, Dropbox, and Pinterest. You will have the opportunity to explore the capabilities of Django, which include features such as database management, authentication system, admin interface, and form handling.

You will learn how to build a Django project from scratch, including setting up the environment and creating the foundational components for your application. We will focus on creating the framework and views for a quiz generation app. You will explore the integration of ChatGPT and Django, enabling you to use AI for quiz generation. To ensure a comprehensive learning experience, we will cover two essential views within the application. One view will allow users to generate quizzes by inputting study material and executing the ChatGPT API, resulting in the generation of relevant questions that will be stored in a database. The other view will enable users to conveniently download any previously generated tests.

In this chapter, you will explore the following:

* Installing Django and creating your first running project
* Building Django views for an exam generation application
* Integrating the ChatGPT API with Django and intercepting ChatGPT responses in the Django backend
* Utilizing Bootstrap templates to create a visually appealing interface
* Storing and fetching ChatGPT responses in a secure database
* Adding file download functionality to your application

By the end of this chapter, you will have the knowledge and skills to employ the ChatGPT API to generate examination questions derived from any provided study material.

## Technical Requirements <a href="#_idtextanchor072" id="_idtextanchor072"></a>

You will need to cover some basic software installations before continuing with this chapter. In addition, the installation of the Django web framework will be demonstrated in the next section.

The project entails the following technical prerequisites:

* Python version 3.7 or higher installed on your local machine
* A code editor, with PyCharm recommended for an optimal experience
* An OpenAI API key to access the necessary API functionalities

You can access the code examples used in this chapter on GitHub at the provided repository: [https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/tree/main/Chapter05%20QuizApp/quiz\_project](https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/tree/main/Chapter05%20QuizApp/quiz\_project)

## Building a Django Project <a href="#_idtextanchor073" id="_idtextanchor073"></a>

In this section, we will embark on the exciting journey of building a Django project that forms the foundation of our quiz generation application. We will guide you through the step-by-step process of setting up and structuring your Django project, ensuring that you have solid groundwork to build upon. By the end of this section, you will have a fully functional Django project that can facilitate the automated generation of quizzes based on study materials.

Our adventure begins with the installation of Django and the creation of a new Django project. We will walk you through the process of setting up your development environment, including the installation of Python and the Django framework. With Django in place, we will use the command-line interface to generate a new Django project, providing you with the necessary directory structure and initial configuration files.

We can start by launching PyCharm and clicking on **New Project** or going to **File** | **New Project** to create a new project. You will be prompted to the **New Project** window, in which you name your project **QuizApp** and click **Create**.

To create your PyCharm project, you can follow these steps (see _Figure 5.1_):

1. Launch PyCharm.
2. Click on **New Project** or navigate to **File** | **New Project** to create a new project.
3. The **New Project** window will appear.
4. Provide a name for your project, such as **QuizApp**.
5. Click on **Create** to proceed.

![Figure 5.1: The PyCharm File Menu](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/B21110\_05\_1.jpg)

Figure 5.1: The PyCharm File Menu

You can now install Django in your local Python environment. To do so, look for the **Terminal** tab located at the bottom of the PyCharm window. If you don’t see it, go to the menu bar and click on **View** | **Tool Windows** | **Terminal** to enable it. From the terminal, run the following command to install Django using **pip**:

```
$pip install Django
```

Next, you run the following command to create a new Django project in the terminal:

```
$django-admin startproject quiz_project
```

When you run this command, Django’s command-line utility, called **django-admin**, creates a new project directory with the specified name **quiz\_project**. This directory will contain the necessary files and folders to start a Django project.

The **startproject** command initializes the project structure by generating the following files:

* **manage.py**: A command-line utility that allows you to interact with various Django commands and manage your project.
* **quiz\_project**: The project directory, which will have the same name as the one specified in the command. This directory serves as the root of your Django project and contains configuration files and other project-specific components.

Inside the project directory, you will find the following files and directories:

* **\_\_init\_\_.py**: An empty file that marks the directory as a Python package
* **settings.py**: The configuration file where you define various settings for your Django project, including database settings, middleware, installed apps, and more
* **urls.py**: The URL configuration file that defines the mapping between URLs and views for your project
* **wsgi.py**: The **Web Server Gateway Interface** (**WSIG**) configuration file used for deployment

You can further customize and develop your Django project by defining models, views, and templates and configuring settings based on your application’s requirements.

In Django, a project is a collection of settings, configurations, and multiple apps that work together to create a web application. An app, on the other hand, is a modular component within a Django project that serves a specific purpose or functionality. For this reason, in our **quiz\_project** we can create a new application as follows.

```
$cd quiz_project
$python manage.py startapp quiz_app
```

The purpose of our newly created application will be to generate AI questions and enable users to download them. A new directory is generated with the specified app name **quiz\_app**. This directory contains the necessary files and folders to develop your Django app. Let’s explore the typical project structure and files within the app directory:

* **admin.py**: This file is used to register your app’s models with the Django admin interface. You can customize how your models are displayed and interacted with on the admin site.
* **apps.py**: This file defines the app configuration, including the name of the app, and uses initialization functions when the application is started.
* **models.py**: Here, you define your app’s data models using Django’s **object-relational mapping** (**ORM**). Models represent the structure of your data and define the tables in your database.
* **tests.py**: This file is used to write tests for your app. You can create test cases and run them to ensure the functionality of your app.
* **views.py**: This file contains the views for your app, which define the logic to process user requests and return responses. Its views handle user interactions and provide the necessary data to render templates.
* **migrations/**: The folder is used to store database migration files. Migrations are a way to manage changes to your database schema over time. They allow you to track and apply incremental changes to your database structure, such as creating new tables, modifying existing tables, and adding or removing columns.

The complete high-level project structure of the Quiz Generation app is as follows:

```
quiz_project/
├── quiz_app
│   ├── migrations/
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── quiz_project/
│   ├── settings.py
│   ├── urls.py
│   ├── wsgi.py
│   └── __init__.py
└──  manage.py
```

By default, Django includes several built-in apps such as **auth**, **admin**, **contenttypes**, and **sessions**. These apps have their own migrations that need to be applied to create the required tables holding the default user data in the database.

Django utilizes a default SQLite database to store data. We can run the following command to initialize the database with all existing models:

```
$python manage.py migrate
```

When you run the command, Django will check for any pending migrations in these default apps and apply them if necessary. This ensures that the database schema is properly set up to support Django’s built-in functionality, verified by the command output:

```
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying sessions.0001_initial... OK
```

Once the migrations are all set, you can start the development server to run your Django project locally:

```
$python manage.py runserver
Watching for file changes with StatReloader
Performing system checks...
System check identified no issues (0 silenced).
May 26, 2023 - 18:59:08
Django version 4.2.1, using settings quiz_project.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
```

When you run this command in the terminal, Django’s **manage.py** script launches a lightweight web server, allowing you to run and test your Django application locally. To access your app, you can click on the link provided in the termina[l output (http://127.0](http://127.0.0.1:8000/).0.1:8000/) or type it in your browser. This link includes a local IP address and a port on which you can access your new app (see _Figure 5.2_).

![Figure 5.2: The Django Welcome Screen](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/B21110\_05\_2.jpg)

Figure 5.2: The Django Welcome Screen

Seeing the Django welcome page in our browser means that we successfully created our Django project and application. In the next section, we will begin building our application by defining models, views, and templates and configuring the URL routing, according to your project requirements.

## Creating the Exam App Frame and Views <a href="#_idtextanchor074" id="_idtextanchor074"></a>

In this section, we will focus on building the fundamental structure of your Django application. We will begin by exploring the Django settings, where you will learn how to configure important aspects such as database connections and middleware components. Understanding and properly setting these configurations is essential for the smooth operation of your application.

We will also learn URL handling in Django. You will discover how to define URL patterns using the **urls.py** file, enabling seamless navigation within your application. We will also cover dynamic URLs using regular expressions, allowing flexible and dynamic routing. Additionally, we will guide you through the process of incorporating a base template, which will provide consistent menus, sidebars, and views throughout your application.

### Connecting Django Views and URLs <a href="#_idtextanchor075" id="_idtextanchor075"></a>

In Django, the relations between views, app URLs, and project URLs form a crucial structure to handle and route web requests. The flow begins with views, which are Python functions or classes responsible for processing specific HTTP requests and returning appropriate responses. Each view corresponds to a particular functionality or page within your application. Those views can be shown to users by being assigned a unique URL. Since, in Django, a project can have more than one application, those URLs are first defined on an app level in **quiz\_app/urls.py**. Those URLs are then passed to the project-level **urls.py** file located in the **quiz\_project** directory for our project (see _Figure 5.3_).

![Figure 5.3: Django Views/URLs Architecture](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/B21110\_05\_3.jpg)

Figure 5.3: Django Views/URLs Architecture

By default, Django automatically generates the **quiz\_project/urls.py** file when you initialize your project. However, it is important to note that we will need to manually create a new **urls.py** file inside the **quiz\_app** folder. Unlike the project-level **urls.py** file, the **urls.py** file at the app level is not generated automatically, and it is essential to organize and define the URL patterns specific to the functionalities within **quiz\_app**.

Now, you can open **quiz\_app/views.py** and write the following Python code:

```
from django.shortcuts import render
def home(request):
    return render(request, 'base.html')
```

This code demonstrates a simple Django view function named **home**. This view function is responsible for handling a specific type of request, typically an HTTP **GET** request, and generating an appropriate response.

Within the function, the Django shortcut **render** function is used to render an HTML template. The first parameter, **request**, represents the incoming HTTP request object. This object contains information about the request, such as headers, data, and user session details. The second parameter, **base.html**, specifies the template to be rendered.

Before building the **base.html** file, we need to ensure that the **home** view can be accessed by the user. To achieve that, we need to specify a unique URL in our **quiz\_app/urls.py** file:

```
from django.urls import path
from . import views
urlpatterns = [
    path('', views.home, name='home'),
]
```

Here, the **urlpatterns** variable is a list that holds the defined URL patterns for the application. In this case, there is a single URL pattern specified for now. The **path** function is used to define a URL pattern. It takes three arguments – the first argument is the URL pattern itself, which is represented by an empty string, **''** , in this case. This empty string signifies the root URL or the base URL of the application.

The second argument, **views.home**, refers to the view function that will handle the request for this URL pattern. The third argument, **name='home'**, provides a unique name for this URL pattern. This name can be used to reference the URL pattern from other parts of the application, such as templates or other URL configurations.

Finally, we can import this application-level URL into the project level by modifying **quiz\_project/urls.py**:

```
from django.contrib import admin
from django.urls import include, path
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('quiz_app.urls')),
]
```

The provided code showcases the configuration of URL patterns in our Django project. Just like in the application-level URL file, here the **urlpatterns** variable holds a list of URL names for the project. In this case, there are two URL patterns specified.

The first URL pattern is defined using the **path** function with the **admin/** argument. This associates the **admin/** URL pattern with the Django admin interface, enabling access to the admin dashboard and related functionalities. The Django admin page is usually set by default and is not related to the functionality of our quiz application.

The path function **path('', include('quiz\_app.urls'))**takes the app-level URLs from **quiz\_app/urls.py**. The first argument, an empty string, **''**, signifies the root URL or base URL of the application. This means that when a user accesses the root URL of the project, this URL pattern will be matched.

The second argument, **include('quiz\_app.urls')**, instructs Django to include the URL patterns defined in the **quiz\_app.urls** module. This means that any URLs specified within the **quiz\_app** application will be matched and handled accordingly.

This is what the hierarchical structure of URL handling looks like. We started from views that process requests to app-level URLs that define specific URL patterns, and finally, to project-level URLs that route requests to the appropriate app-level URLs. The process was illustrated with code examples, highlighting the significance of correctly configuring URLs at both the app and project levels for smooth navigation and functionality within a Django application.

In the upcoming section, we will delve into building HTML templates, including the essential **base.html** file. Templates play a crucial role in defining the visual structure and layout of web pages in a Django application. By constructing and customizing HTML templates, we can create a consistent and visually appealing user interface for our quiz application.

### Developing Django Templates <a href="#_idtextanchor076" id="_idtextanchor076"></a>

In this section, we will focus on building the **base.html** template and incorporating CSS into our Django application. The **base.html** template serves as the foundation for the visual structure and layout of our web pages. To enhance the design and styling of our application, we will utilize external CSS resources. One valuable resource is the Bootstrap framework, which offers a wide range of pre-designed templates and components. We will go through the process of finding suitable templates from the official Bootstrap website ([https://getbootstrap.com/docs/5.3/examples/](https://getbootstrap.com/docs/5.3/examples/)), where you can explore various examples and choose the ones that align with your desired aesthetics and functionality.

You can easily access the code behind any of the Bootstrap templates if you use **Google Chrome**. For instance, for this project, we can use the **Dashboard template** that [you can access here: https://getbootstrap.com/docs/5](https://getbootstrap.com/docs/5.3/examples/dashboard/).3/examples/dashboard/. As you can see in _Figure 5.4_, the HTML code can be accessed by right-clicking on the **Dashboard** template and choosing the **View Page Source** option.

![Figure 5.4: Viewing the Page Source in Chrome](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/B21110\_05\_4.jpg)

Figure 5.4: Viewing the Page Source in Chrome

By following this approach, you can extract specific sections from this template and incorporate them into your own application, allowing for easy customization and extension. This process establishes a solid foundation for your Django app.

To begin, you can create a **templates** folder in a separate location outside of both your application and project folders, adhering to the recommended structure outlined as follows. This organized setup ensures efficient management of your template files:

```
quiz_project/
├── quiz_app
├── quiz_project/
└──  templates
```

Within the **templates** directory, you will create a new HTML file named **base.html**, serving as the foundation for your application’s structure. In this file, you can begin by including relevant links and defining the header section that sets the overall context for your application:

```
{% raw %}
{% load static %}
<html lang="en" data-bs-theme="auto">
<head>
  <script src="/docs/5.3/assets/js/color-modes.js"></script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Quiz App</title>
  <!-- Bootstrap CSS -->
  <link href="{% static 'css/bootstrap.min.css' %}" rel="stylesheet" />
<!--  ; Custom styles for this template &ndash;&gt;-->
  <link href="{% static 'css/dashboard.css' %}
{% endraw %}" rel="stylesheet" />
</head>
```

The first line, **\{% load static %\}**, is a Django template tag that allows us to load static files, such as CSS style sheets and JavaScript scripts, into our HTML template. It enables us to access and utilize these files within our Django project. Later in this section, we will create the **.css** files, and they will be automatically passed to the HTML.

Then, the **data-bs-theme** attribute is used for automatic theme handling. This attribute is often used with Bootstrap, a popular CSS framework, to automatically switch between light and dark themes based on the user’s device settings.

The **head** section contains various meta tags and external script and style sheet references. These meta tags provide information about the character encoding and viewport settings for the web page. They ensure that the web page is rendered properly and adjusts its layout to fit different screen sizes.

Next, we include external CSS style sheets. The **\{% static 'css/bootstrap.min.css' %\}** and **\{% static 'css/dashboard.css' %\}** tags refer to the static CSS files that we will create in our Django project. These CSS files provide styling rules and formatting instructions that define the visual appearance of elements on the web page.

Once the header is completed, we can now enter the following code snippet to build the body of our page:

```
<body>
  <header class="navbar navbar-dark sticky-top bg-dark flex-md-nowrap       p-0 shadow">
    <a class="navbar-brand col-md-3 col-lg-2 me-0 px-3 fs-6" href="#">        Quiz App</a>
    <div class="navbar-nav">
    </div>
  </header>
  <div class="container-fluid">
    <div class="row">
      <nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block           bg-body-tertiary sidebar collapse">
      <div class="position-sticky pt-3 sidebar-sticky">
        <ul class="nav flex-column">
          <li class="nav-item">
            <a class="nav-link active" aria-current="page" href="">
              <span data-feather="home" class="align-text-bottom">                  </span>
              Questions Generator
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link active" aria-current="page"                 href="/history">
              <span data-feather="file" class="align-text-bottom">                  </span>
              My Quiz
            </a>
          </li>
        </ul>
      </div>
    </nav>
    </div>
  </div>
  </body>
</html>
```

Here, the body consists of a **\<header>** section that contains a navigation bar. The navigation bar includes a brand name for the quiz app. The **\<div class="navbar-nav">** element can be used to add additional navigation items if needed.

Inside this navigation, there is a **\<nav id="sidebarMenu">** element that serves as a sidebar menu. It contains a list of navigation items that can be customized as needed. Each navigation item is represented by **\<li class="nav-item">** with an associated link. We will have two main links inside the sidebar:

* The **Questions Generator** tab: This shows the ChatGPT quiz generation tool
* The **My Quiz** tab: This shows all the quizzes that the user created so far, ready to be downloaded

Now that your **base.html** has been completed, we can add the style files. To do that, create two new directories called **static** and **css** inside your **quiz\_project**, as shown here:

```
quiz_project/
├── quiz_app
├── quiz_project/
│   ├── static/
│   └── css/
│      ├── dashboard.css
│      └── bootstrap.min.css
└──  templates
```

Instead of writing the style files on our own, we can simply download the CSS files from the **Dashboard** template source code discussed earlier. Once downloaded, you can paste them into your **css** folder. You can find the links to each of the CSS files required for our pro[ject here:](https://getbootstrap.com/docs/5.3/examples/dashboard/dashboard.css)

* [**dashboard.css**: https://getbootstrap.com/docs/5.3/examp](https://getbootstrap.com/docs/5.3/examples/dashboard/dashboard.css)les/dashboard/dashboard.css
* **bootstrap.min.css**:[ https://getbootstrap.com/docs/5.3/dist/css/bootstrap.min.css](https://getbootstrap.com/docs/5.3/dist/css/bootstrap.min.css)

Alternatively, you can access all project files at our GitHub repository: [https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs](https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs).

Now, let’s see how to integrate these HTML and CSS files into our Django project. By modifying the **settings.py** file, we can specify the directories where Django should look for static files, including HTML templates and CSS files. This configuration will ensure that our Django application can access and utilize the desired templates and CSS styles, providing a visually appealing and cohesive user experience throughout the entire application.

Firstly, to add the HTML files to your project, you can simply reference the **templates** directory inside the **settings.py** file. To do that, find the **TEMPLATES** dictionary and edit the **DIRS** key, as follows:

<pre><code>TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
<strong>        'DIRS': [os.path.join(BASE_DIR, 'templates')],
</strong>        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
</code></pre>

This is used to construct the absolute path to the **templates** directory within your Django project. **BASE\_DIR** refers to the base directory of your Django project, and **templates** is the name of the directory where your template files are stored.

By setting the **DIRS** key, you tell Django to include the **templates** directory as one of the locations to search for template files. This allows you to organize your template files separately from your application directories and provides a central location to store your HTML templates.

We will also need to import the **os** library at the beginning of the **setting.py** file:

<pre><code><strong>import os
</strong>from pathlib import Path
</code></pre>

Secondly, to pass all CSS files to your Django project, you can scroll to the bottom of **settings.py** and add the following:

<pre><code># Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/
STATIC_URL = 'static/'
<strong>STATICFILES_DIRS = [os.path.join(BASE_DIR, 'quiz_project /static')]
</strong><strong>STATIC_ROOT = os.path.join(BASE_DIR, 'static')
</strong># Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
</code></pre>

Here, **STATICFILES\_DIRS** tells Django where to find static files during development, while **STATIC\_ROOT** specifies the directory where static files will be collected for deployment. These settings ensure that your static files are organized and accessible, both during development and in a production environment. This will allow us to pick those CSS files for our project.

This section explained the process of developing Django templates by building a **base.html** template, incorporating CSS resources such as Bootstrap, and configuring the **settings.py** file to manage static files and templates in a Django project. After completing the steps outlined, you are now ready to run your Django application in the next section.

### Running Your Django Application <a href="#_idtextanchor077" id="_idtextanchor077"></a>

Once you have completed the steps covered in the previous section, you can now run your Django project. To run a Django application, you will need to access again your PyCharm terminal or navigate to the root directory, **quiz\_project**, of your Django project. This is the directory that contains the **manage.py** file. Once you’re in the correct directory, execute the following command:

```
$python manage.py runserver
```

This command starts the development server, which allows you to run your Django application locally for testing and development purposes.

Important Note

An important note to keep in mind is that Django’s development server has a useful feature called **auto-reloading**. This means that you can leave the server running while you make changes to your code, and the server will automatically detect these changes and apply them without requiring a manual restart.

Once the Django development server is running, you can access your application by opening a web browser a[nd entering the follow](http://127.0.0.1:8000/)ing URL: http://127.0.0.1:8000/ (see _Figure 5.5_). By default, Django runs the server on localhost **127.0.0.1** and uses port **8000**. The preceding URL will point your browser to the home page of your Django application.

![Figure 5.5: The Quiz App Initial Page View](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/B21110\_05\_5.jpg)

Figure 5.5: The Quiz App Initial Page View

In our Django application, we can observe three distinct sections. Firstly, at the top, we have the header area displaying the name **Quiz App** against a dark background. On the left-hand side, we find a navigation bar with two tabs that we incorporated into the **base.html** file – **Questions Generator** and **My Quiz**. These tabs facilitate easy navigation between different features of our application. The **Questions Generator** tab directs users to a section where they can construct quizzes, while the **My Quiz** tab presents a view to download quizzes. Finally, on the right-hand side of the navigation bar, we have the working area, where users can interact with and explore the contents of the **My Quiz** and **Questions Generator** functionalities.

This is what the initial view of your application looks like, with a sleek and modern interface showcasing a user-friendly design. In the next section, our attention can now be directed toward developing the fundamental aspect of the app, which involves creating the core ChatGPT quiz generation component.

## Integrating ChatGPT and Django for Quiz Generation <a href="#_idtextanchor078" id="_idtextanchor078"></a>

In this section, we will explore the exciting task of generating questions using the ChatGPT API within your Django application. This powerful functionality will allow you to create interactive quizzes based on user-provided text input. By handling **POST** requests from the user and leveraging the capabilities of the ChatGPT API, you will be able to dynamically generate insightful questions that enhance user engagement and knowledge acquisition.

The process begins by incorporating a field in your Django application where users can input text. Once the user submits the text by clicking the submit button, the magic unfolds as your application utilizes the ChatGPT API to generate relevant and contextually accurate questions based on the provided text. These questions are seamlessly displayed to the user, enabling an interactive and educational experience. By automating the question generation process, you can save time and effort while providing valuable content to your users. So, let’s dive in and explore the steps involved in handling **POST** requests, building the ChatGPT API function for question creation, and ultimately, displaying the generated questions to your users in a user-friendly and intuitive manner.

### Building the Quiz Generation Text Area and Submit Button <a href="#_idtextanchor079" id="_idtextanchor079"></a>

In a slight departure from the chronological order, we will begin by making modifications to the **base.html** file to incorporate the necessary components for our question generation feature. Specifically, we will add a text area where users can input their desired text, and a submit button that triggers the question generation process. You can add those fields under the navigation bar menu code (under the **\</nav>** tag), as shown in the following code:

base.html

<pre><code>    &#x3C;/nav>
<strong>      &#x3C;main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
</strong><strong>        {% block content %}
</strong><strong>          &#x3C;h1>Create a Quiz&#x3C;/h1>
</strong><strong>          &#x3C;form method="post" action="">
</strong><strong>            {% csrf_token %}
</strong><strong>            &#x3C;textarea name="text" rows="5" cols="50"              placeholder="Enter some text...">&#x3C;/textarea>
</strong><strong>            &#x3C;br>
</strong><strong>            &#x3C;input type="submit" value="Generate Questions">
</strong><strong>          &#x3C;/form>
</strong><strong>              {% if questions %}
</strong><strong>                  &#x3C;h2>Generated Questions:&#x3C;/h2>
</strong><strong>                          {{ questions|linebreaks }}
</strong><strong>              {% endif %}
</strong><strong>        {% endblock %}
</strong><strong>      &#x3C;/main>
</strong>    &#x3C;/div>
  &#x3C;/div>
  &#x3C;/body>
&#x3C;/html>
</code></pre>

This represents the section of the **base.html** file that is responsible for displaying the user interface elements related to the question generation feature in our Quiz Generation application.

In the code, we can observe the usage of HTML tags and Django template syntax. The **\<main>** tag defines the main content area. Inside the **\<main>** tag, we have a Django template block defined by **\{% block content %\}** and **\{% endblock %\}**, which allows dynamic content insertion. This will ensure that we can connect this block with our Django views later.

In this block, we begin by displaying a heading, **Create a Quiz**, to provide a clear title for the question generation section. Next, we encounter a form that is responsible for handling the user’s input and submitting it for question generation. The **\{% csrf\_token %\}** template tag ensures the security of the form submission.

Inside the form, we find **textarea**, which serves as the input field where users can enter the text from which they want questions to be generated. It has specified rows and columns attributes to define the size of the text input area. Additionally, there is placeholder text, **Enter some text...**, to provide instructions to the user.

Following **textarea**, we have a submit button with the title **Generate Questions**, which users can click to initiate the question generation process. When the form is submitted, the user’s input will be sent to the appropriate view for further processing.

After the form, there is a**\{% if questions %\}** statement, which checks whether there are generated questions available. If there are, a heading, **Generated Questions**, is displayed, followed by the generated questions themselves, which are rendered using **\{{ questions|linebreaks \}}**. This syntax ensures that line breaks within the generated questions are properly displayed under the text field.

Finally, wecan add a new style sheet, which we will build later, to the **base.html** file inside its **head**:

<pre><code>&#x3C;!--  &#x26;lt;!&#x26;ndash; Custom styles for this template &#x26;ndash;&#x26;gt;-->
  &#x3C;link href="{% static 'css/dashboard.css' %}" rel="stylesheet" />
<strong>  &#x3C;link rel="stylesheet" type="text/css" href="{% static 'css/quiz_    style.css' %}">
</strong>&#x3C;/head>
</code></pre>

When you launch your Quiz Generator at this point, you will see that while all the fields are visible, their visual presentation may not be aesthetically pleasing. This is because we have only incorporated HTML elements thus far. To enhance their appearance, we need to introduce some CSS styling. To do that, you can create a new CSS file called **quiz\_style.css** inside the **quiz\_project/static/css** directory. You can find the CSS file content here: [https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/blob/main/Chapter05%20QuizApp/quiz\_project/quiz\_project/static/css/quiz\_style.css](https://github.com/PacktPublishing/Building-AI-Applications-with-ChatGPT-APIs/blob/main/Chapter05%20QuizApp/quiz\_project/quiz\_project/static/css/quiz\_style.css)

Here, we define the styles for the **body**, **container**, and **main** elements. The body element is set to use the Arial font family and has a white background. The container class specifies a maximum width of **960px**, while the main element that holds our application also has a box shadow effect and a border radius of **5px**.

Then, we can define the styles for the **textarea** and **submit** button elements. The **textarea** element is set to have a width of **70%** of its parent container with a light gray color. The **input\[type="submit"]** element, which represents a submit button, has a blue background color, and the cursor changes to a pointer when hovering over it.

The **Responsive styles** section uses media queries to apply specific styles when the maximum width of the viewport is **767px** or less. In this case, it reduces the padding of the **.container** and **main** elements, decreases the font size of headings to **20px**, and adjusts the padding of the **textarea** and **input\[type="submit"]** elements. These styles ensure that the Quiz Generator application is visually appealing and adapts well to different screen sizes, providing a better user experience.

So far, we have successfully constructed the entire user interface for the Quiz Generation feature of our application. Our next step is to integrate the ChatGPT API service and implement the necessary views.

### Creating ChatGPT API Views with Django <a href="#_idtextanchor080" id="_idtextanchor080"></a>

Now that we have completed the frontend, we will explore how to incorporate this powerful ChatGPT API into our Django views, enabling us to harness the capabilities of ChatGPT to generate quiz questions.

Asking ChatGPT to generate a response in a specific structure can be a challenging task, as we need to define very specific instructions about how the questions in our quiz should be generated. Having that in mind, our ChatGPT prompt should meet the following requirements:

* A variable holding the text that we want to create questions for should be passed as a separate variable. That will enable our app to work with different types of text.
* The prompt should consist of instructions that specify the following:
  * The number of questions
  * Where and how the correct answer should be displayed
  * What type of question ChatGPT should generate (multiple-choice, open-answer, etc)

It is a good practice to create such requirements every time you want to design a ChatGPT prompt and test whether the API response meets the expected response, based on your prompt definition.

Inside the **quiz\_app** folder of your Django project, you will need to create two essential files – **config.py** and **services.py**. The **config.py** file serves as a container for your ChatGPT API key, allowing you to securely store and access it within your application. This key is crucial to establish a connection with the ChatGPT API service. The **services.py** file, on the other hand, plays a pivotal role in housing the necessary functions that will enable you to interact with the ChatGPT API within your Django views. These functions will facilitate communication with the API, allowing you to generate quiz questions dynamically based on user input:

services.py

```
import openai
from . import config
# API Token
openai.api_key = config.API_KEY
def generate_questions(text):
    # Define your prompt for generating questions
    prompt = f"Create a practice test with multiple choice questions                  on the following text:\n{text}\n\n" \
             f"Each question should be on a different line. Each                  question should have 4 possible answers. " \
             f"Under the possible answers we should have the correct                  answer."
    # Generate questions using the ChatGPT API
    response = openai.Completion.create(
        engine='text-davinci-003',
        prompt=prompt,
        max_tokens=3500,
        stop=None,
        temperature=0.7
    )
    # Extract the generated questions from the API response
    questions = response.choices[0].text
    return questions
```

config.py

```
API_KEY = "YOUR_API_KEY"
```

Here, we have a Python function that utilizes the OpenAI library to interact with the ChatGPT API to generate quiz questions. First, the necessary dependencies are imported, including the OpenAI library and the local **config** module, which holds the API key. The API key is set using the imported **config.API\_KEY** value to establish a connection with the ChatGPT API.

The **generate\_questions** function takes a text input as a parameter, which represents the content or context from which questions will be generated. The function prepares a prompt by incorporating the provided text into a specific format that instructs the AI model to create multiple-choice questions, based on the given content.

As you can see, the design of the given ChatGPT prompt focuses on providing clear instructions to generate a practice test with multiple-choice questions, based on a given text. Here’s the reasoning behind the design:

* **Clear instructions**: The prompt begins by clearly stating the purpose of the task – to create a practice test with multiple-choice questions. This helps set the context and expectations for the generated content.
* **Introduction to the text**: The prompt includes the placeholder **{text}** to indicate that the given text should be inserted at that point. This allows the user to provide the specific text on which the questions will be based.
* **Structured format**: The prompt specifies that each question should be on a separate line. This helps create a structured layout for the practice test, making it easier to read and be understood by humans and other Python scripts.
* **Multiple-choice format**: The prompt states that each question should have four possible answers. This indicates that the generated questions should follow the multiple-choice question format commonly used in tests and quizzes.
* **Indicating the correct answer**: The prompt mentions that under the possible answers, the correct answer should be provided. This ensures that the generated questions include the correct answer along with the options, allowing learners to easily identify the correct response.

Using the ChatGPT API, the function sends a request to the API with the prepared prompt. The API response contains the generated questions. The function extracts these questions from the API response and returns them as a string variable.

The **questions** variable can be now used inside the **views.py** file to pass the generated questions to be displayed in our **base.html** frontend file:

views.py

<pre><code>from django.shortcuts import render
<strong>from .services import generate_questions
</strong>def home(request):
<strong>    if request.method == 'POST':
</strong><strong>        text = request.POST['text']
</strong><strong>        questions = generate_questions(text)
</strong><strong>        context = {'questions': questions}
</strong><strong>        return render(request, 'base.html', context)
</strong>    return render(request, 'base.html')
</code></pre>

Here, we upgrade the **home** function that handles the rendering of the home page and the generation of quiz questions based on user input. Upon receiving a request, the view function checks the HTTP method of the request. If it is a **POST** request, indicating that the user has submitted a form, the function proceeds to extract the text input from the request’s **POST** data using the **text** key. In fact, the submission is initiated by selecting the **Submit** button while the text is inside the **text** files of our Question Generation app.

The extracted text is then passed as an argument to the **generate\_questions** function, which we previously defined in the **services.py** file. This function utilizes the ChatGPT API to generate quiz questions based on the provided text. The generated questions are stored in the **questions** variable.

To display the generated questions on the web page, a dictionary called **context** is created with the **questions** key and the corresponding value containing the generated questions. This context dictionary is passed as an argument to the **render** function, along with the request object and the template file, **base.html**. The rendered page will have access to the **questions** variable and can display it appropriately.

By implementing this code in your Django application’s **views.py** file, the **home** view function will handle the generation of quiz questions, based on user input, and render the home page with the generated questions displayed if a **POST** request is received.

Before testing your Django application and utilizing the ChatGPT API, you need to ensure that the OpenAI library is installed. The OpenAI library provides the necessary tools and functionalities to interact with the ChatGPT API. To install the library, you can type the following command in the terminal window:

```
pip install openai
```

To test your Quiz Generator application, follow these steps:

1.  Ensure that your Django development server is running. If it’s not already running, navigate to the root directory of your Django project in the terminal or Command Prompt and execute the following command:

    <pre><code><strong>$python manage.py runserver.
    </strong></code></pre>
2. Open a web browser and enter the URL **http://127.0.0.1:8000/**. This will direct you to the home page of your Quiz Generator application.
3. On the home page, you will see a text area where you can enter some text. Paste or type the desired text for which you want to generate quiz questions (see _Figure 5.5_).

![Figure 5.6: Adding Text to the Quiz Generation App](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/B21110\_05\_6.jpg)

Figure 5.6: Adding Text to the Quiz Generation App

1. Once you have entered the text, click the **Generate Questions** button. This will submit the form and trigger a **POST** request to the server.
2. The server will process the request and generate quiz questions based on the provided text, using the ChatGPT API. The generated questions will be displayed below the text area (see _Figure 5.7_).

![Figure 5.7: Questions Displayed by the Quiz Generation App](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/B21110\_05\_7.jpg)

Figure 5.7: Questions Displayed by the Quiz Generation App

By following these steps, you can now test your Quiz Generator application and see how it generates questions based on the text input. Feel free to experiment with different inputs to explore the capabilities of your application.

In this section, we explored the integration of ChatGPT and Django for quiz generation. We covered the creation of a user interface for question generation, incorporating CSS styling for visual appeal, implementing ChatGPT API views using Django, and testing the Quiz Generator application by entering text and generating questions based on it. We can now build a database to store the generated questions and enable users to download them, which we will cover in the next section.

## Storing and Downloading Generated Quizzes <a href="#_idtextanchor081" id="_idtextanchor081"></a>

In this next section, you will learn how to build the quiz download functionality for your Quiz Generation app. By incorporating a database and creating a dedicated page for downloading quizzes, you will empower your users to access and utilize the quizzes they generate. This feature will enhance the overall user experience by providing a seamless way to save and retrieve quizzes, enabling users to revisit and share their generated content effortlessly.

We will explore the process of saving generated quizzes in a database using Django’s models and database management capabilities. By defining the appropriate database structure and implementing the necessary views and templates, you will be able to create a user-friendly page where users can browse and download their generated quizzes. With this functionality in place, your Quiz Generation App will offer a comprehensive solution to generate, store, and access quizzes, further enriching the interactive and educational experience for your users.

### Saving the Quizzes in an SQLite Database <a href="#_idtextanchor082" id="_idtextanchor082"></a>

One of the key aspects of building the quiz download functionality is the ability to save the generated quizzes in a database. SQLite provides a simple and efficient solution for this purpose. SQLite is a lightweight, serverless, and self-contained database engine that requires minimal setup and configuration. It is ideal for smaller-scale applications and offers seamless integration with Python.

To begin, you will need to modify the **generate\_questions()** function to incorporate database functionality. Within this function, you can include code to save the generated quiz questions and options into the SQLite database. By defining appropriate table structures using Django’s models, you can easily map the quiz data to the corresponding fields in the database.

In addition to modifying the **generate\_questions()** function, you will also need to create a separate function to initialize the database. This function will handle tasks such as creating the necessary tables and establishing a database connection. To create it, open your **services.py** file, where you can write the initialization function under your **API\_KEY** definition:

```
import sqlite3
import openai
from . import config
# API Token
openai.api_key = config.API_KEY
def initialize_database():
    # Connect to the SQLite database
    conn = sqlite3.connect('questions.db')
    cursor = conn.cursor()
    # Create the table if it doesn't exist
    cursor.execute('''CREATE TABLE IF NOT EXISTS questions
                      (id INTEGER PRIMARY KEY, key TEXT UNIQUE, value                       TEXT)''')
    conn.commit()
    conn.close()
```

The **initialize\_database()** function is responsible for setting up the SQLite database to store the generated quizzes. It begins by establishing a connection to the SQLite database named **questions.db**. Then, the cursor serves as a handle for executing SQL statements and fetching results from the database. It allows us to execute SQL commands and retrieve data from the database.

The function then checks whether a table named **questions** exists in the database. This statement creates a table with three columns – **id**, **key**, and **value**. The **key** column will later take the first two words from the text you pass to ChatGPT and use them as a quiz name, while the **value** column will hold the complete quiz.

After executing the table creation statement, the changes are committed to the database using **conn.commit()**. This ensures that the table creation is finalized and persisted in the database before the connection to the database is closed, using **conn.close()** to free up system resources and maintain good coding practices.

Additionally, make sure to import the SQLite package to enable the utilization of the database functionalities.

Now, we can modify our **generate\_questions()** function to incorporate the database:

```
def generate_questions(text):
    initialize_database()
    # Connect to the SQLite database
    conn = sqlite3.connect('questions.db')
    cursor = conn.cursor()
    # Define your prompt for generating questions
    prompt = f"Create a practice test with multiple choice questions                  on the following text:\n{text}\n\n" \
             f"Each question should be on a different line. Each                  question should have 4 possible answers. " \
             f"Under the possible answers we should have the correct                  answer."
    # Generate questions using the ChatGPT API
    response = openai.Completion.create(
        engine='text-davinci-003',
        prompt=prompt,
        max_tokens=3500,
        stop=None,
        temperature=0.7
    )
    # Extract the generated questions from the API response
    questions = response.choices[0].text
    # Generate a unique key for the question
    base_key = ' '.join(text.split()[:2])
    key = base_key
    index = 1
    while key_exists(cursor, key):
        key = f"{base_key} {index}"
        index += 1
    # Insert the questions into the database
    value = questions
    cursor.execute("INSERT INTO questions (key, value) VALUES (?, ?)",                    (key, value))
    conn.commit()
    return questions
def key_exists(cursor, key):
    cursor.execute("SELECT COUNT(*) FROM questions WHERE key = ?",                    (key,))
    count = cursor.fetchone()[0]
    return count > 0
```

Firstly, the function establishes a connection to the SQLite database named **questions.db** using the **sqlite3.connect()** method, similar to the previous function.

To ensure the uniqueness of each question, the function generates a unique key by combining the first two words of the input text. If a question with the same key already exists in the database, it appends a numerical index to the key until a unique key is obtained. We verify the key by using the **key\_exists()** method.

The function then inserts the generated questions into the SQLite database using the **cursor.execute()** method. The key and value (**questions**) are passed as parameters to the SQL query. Once the insertion is complete, the function calls **conn.commit()** to save the changes made to the database.

The **key\_exists()** function takes a cursor object and a key as parameters, executes an SQL query to count the number of rows with the given key in the **questions** table, and returns **True** if a key exists in the table, or **False** otherwise. This function provides a convenient way to check for the existence of a key in the database before inserting new data or performing other operations.

To fetch the database, we can create the **print\_all\_questions()** function. It retrieves all the rows from the **questions** table in the SQLite database and returns them as a result:

```
def print_all_questions():
    initialize_database()
    conn = sqlite3.connect('questions.db')
    cursor = conn.cursor()
    # Retrieve all rows from the database
    cursor.execute("SELECT * FROM questions")
    rows = cursor.fetchall()
    return rows
```

First, the function executes an **SQL SELECT** statement using the the **SELECT \* FROM questions** query. This query selects all the columns from the **questions** table.

After executing the **SELECT** statement, the function retrieves all the rows returned by the query. The **fetchall()** method returns the result as a list of tuples, where each tuple represents a row from the table. Later, we will use this function as a part of the download functionality to download our quizzes from the database.

### Building the Download Quiz View <a href="#_idtextanchor083" id="_idtextanchor083"></a>

Now, it’s time to explore the process of integrating download quiz views into your Django application. The download quiz views are essential to enable users to access and obtain the quizzes generated by the Quiz Generation app. First, navigate to the **views.py** file and add the following code under the **home** function:

```
def history(request):
    return render(request, 'download.html')
data = print_all_questions()
class TestListView(TemplateView):
    template_name = 'download.html'
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['data'] = data
        return context
def download(request, test_id):
    test = next((t for t in data if t[0] == test_id), None)
    if test:
        header = test[1]
        questions = test[2]
        filename = f'test_{test_id}.txt'
        with open(filename, 'w') as f:
            f.write(questions)
        file_path = os.path.join(os.getcwd(), filename)
        response = HttpResponse(open(file_path, 'rb'),             content_type='text/plain')
        response['Content-Disposition'] = f'attachment;            filename="{header}.txt"'
        return response
    else:
        return HttpResponse("Test not found.")
```

The provided code demonstrates the additional functions included in the **views.py** file of our Django Quiz Generator. Let’s go through each function and its purpose:

1. The **history** function is a view function that renders the **download.html** template, which we will build in the next section. When a user visits the specified URL associated with this function, the template will be displayed, allowing them to view the history of quizzes available to download.
2. The **data** variable is assigned the value returned by the **print\_all\_questions()** function. This function retrieves all the rows from the database containing the generated quizzes. By storing the data in the data variable, it can be used later to populate the context for the **TestListView** view.
3. The **TestListView** class is a subclass of **TemplateView**, which provides a generic class-based view. It defines the template that will be used to display the downloaded quizzes – in this case, the **download.html** template. The **get\_context\_data()** method is overridden to add the **data** variable to the context, making it available in the template for rendering.
4. The **download()** function handles the download functionality for a specific quiz, identified by its **test\_id**. It first searches for the quiz in the **data** variable using the **test\_id**. If the quiz is found, the header, questions, and filename are extracted. The questions are then written to a text file with the appropriate filename. The file path is determined, and an **HttpResponse** object is created with the file content and content type. The Content Disposition header is set to specify the filename for the downloaded file. Finally, the response is returned to initiate the file download. If the quiz is not found, an **HttpResponse** object is returned, with a message indicating that the test was not found.

Finally, at the beginning of the **views.py** file, you can add all the necessary imports for those functions to operate properly:

```
import os
from django.http import HttpResponse
from django.shortcuts import render
from django.views.generic import TemplateView
from .services import generate_questions, print_all_questions
```

As you can see, the **HttpResponse** and **render** functions are imported from the Django framework. These functions are essential to generate and return HTTP responses. The **HttpResponse** class allows you to create custom HTTP responses, while the **render** function is used to render HTML templates and return the result as an **HttpResponse** object. The **TemplateView** class will be used later as a class-based view that will render the templates for the download view.

By adding these functions to your **views.py** file, you enable the rendering of the download history page and the listing of quizzes in the **download.html** template. In the next section, we will create the download template and add all necessary URLs to make the **My Quiz** download page accessible to the users.

### Designing the Download Template <a href="#_idtextanchor084" id="_idtextanchor084"></a>

If you have a close look at your **base.html** file, you will see that there are two buttons displayed inside the navigation bar – **Questions Generator** and **My Quiz**. We already ensured that once the user clicks on **Questions Generator**, they can see the **home** view, allowing them to generate quizzes using the ChatGPT API. In this section, we will focus on the **My Quiz** page. We will ensure that once the user clicks the **My Quiz** button, they are sent to the **127.0.0.1/history** page. This page will show all views related to our download functionality, which we built in the previous section.

To do that, we need to create a new HTML file that will be rendered once the user clicks on the **MyQuiz** button. This HTML will be almost an exact copy of the **base.html**, with the only difference being that it will run a different set of functions (the download functions) in its **main** area. You can create your **downloads.html** file inside the **templates/** directory:

<pre><code>{% load static %}
&#x3C;html lang="en" data-bs-theme="auto">
&#x3C;head>
  &#x3C;script src="/docs/5.3/assets/js/color-modes.js">&#x3C;/script>
  &#x3C;meta charset="utf-8">
  &#x3C;meta name="viewport" content="width=device-width, initial-scale=1">
  &#x3C;title>Quiz App&#x3C;/title>
  &#x3C;!-- Bootstrap CSS -->
  &#x3C;link href="{% static 'css/bootstrap.min.css' %}" rel="stylesheet" />
  &#x3C;!-- Custom styles for this template -->
  &#x3C;link href="{% static 'css/dashboard.css' %}" rel="stylesheet" />
&#x3C;/head>
&#x3C;body>
  &#x3C;header class="navbar navbar-dark sticky-top bg-dark flex-md-nowrap     p-0 shadow">
    &#x3C;a class="navbar-brand col-md-3 col-lg-2 me-0 px-3 fs-6"      href="#">Quiz App&#x3C;/a>
    &#x3C;div class="navbar-nav">
    &#x3C;/div>
  &#x3C;/header>
  &#x3C;div class="container-fluid">
    &#x3C;div class="row">
      &#x3C;nav id="sidebarMenu" class="col-md-3 col-lg-2 d-md-block         bg-body-tertiary sidebar collapse">
      &#x3C;div class="position-sticky pt-3 sidebar-sticky">
        &#x3C;ul class="nav flex-column">
          &#x3C;li class="nav-item">
            &#x3C;a class="nav-link active" aria-current="page" href="/">
              &#x3C;span data-feather="home" class="align-text-bottom">                &#x3C;/span>
              Questions Generator
            &#x3C;/a>
          &#x3C;/li>
          &#x3C;li class="nav-item">
            &#x3C;a class="nav-link active" aria-current="page"               href="/history">
              &#x3C;span data-feather="file" class="align-text-bottom">                &#x3C;/span>
              My Quiz
            &#x3C;/a>
          &#x3C;/li>
        &#x3C;/ul>
      &#x3C;/div>
      &#x3C;/nav>
<strong>      &#x3C;main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
</strong><strong>        &#x3C;h1>Download Quiz&#x3C;/h1>
</strong><strong>        &#x3C;ul>
</strong><strong>        {% for test in data %}
</strong><strong>          &#x3C;li>&#x3C;a href="/download/{{ test.0 }}" class="test-header">            {{ test.1 }}&#x3C;/a>&#x3C;/li>
</strong><strong>        {% endfor %}
</strong><strong>        &#x3C;/ul>
</strong><strong>      &#x3C;/main>
</strong>    &#x3C;/div>
  &#x3C;/div>
  &#x3C;/body>
&#x3C;/html>
</code></pre>

After the navigation bar, where our working area is located, we can create a section where users can download quizzes. We can generate a list of quiz download links based on the data provided, displaying the quiz headers as clickable links for users to access and download the quizzes.

Inside the **\<main>** element, there is an **\<h1>** heading tag that displays the text **Download Quiz**. This heading provides a clear title for the section, indicating its purpose to the users.

Below the heading, there is a **\<ul>** element that represents an unordered list. Within this list, there is a loop construct using Django’s template syntax, denoted by **\{% for test in data %\}** and **\{% endfor %\}**. This loop iterates over the **data** variable, which contains a list of quizzes or test data.

For each iteration of the loop, a new list item, **\<li>**, is generated. Inside the list item, there is an anchor (**\<a>**) tag that serves as a hyperlink. The **href** attribute of the anchor tag is dynamically generated using Django’s template syntax and the **test** variable. This link points to the **/download/** URL, followed by the test.

This section of **download.html** generates a main content area with a heading and a list of quiz download links. The loop ensures that each quiz in the **data** variable is represented as a separate list item with an appropriate hyperlink and display text.

As a final step to set up the **My Quiz** page in your Django project, we need to modify the **urls.py** files. Those files are responsible for routing requests to the appropriate views. You need to define a URL pattern that maps to the history view, which will display the **My Quiz** page. By updating the **urls.py** files, users will be able to access the **My Quiz** page and view their downloaded quizzes:

quiz\_project/urls.py

```
from django.contrib import admin
from django.urls import include, path
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('quiz_app.urls')),
    path('history/', include('quiz_app.urls')),
]
```

quiz\_app/urls.py

```
from django.urls import path
from . import views
from .views import TestListView, download
urlpatterns = [
    path('', views.home, name='home'),
    path('history/', TestListView.as_view(), name='test_list'),
    path('download/<int:test_id>', download, name='test_download'),
]
```

In the **quiz\_project/urls.py** file, we define the URL patterns for the entire project. The **history/** path is mapped to the **quiz\_app.urls** module, which contains the URL patterns specific to the quiz application. This configuration allows users to access the **My Quiz** page.

In the **quiz\_app/urls.py** file, we define the URL patterns for the quiz application specifically. We add the **history/** path that is mapped to the **TestListView** view class, which is responsible for displaying the **My Quiz** page. Additionally, the **download/\<int:test\_id>** path is mapped to the download view function, which handles the downloading of specific quizzes that the user selects.

By configuring the URL patterns in these files, you enable users to navigate to different pages of your Quiz app, such as the **Question Generator** page or the **My Quiz** page, from which the download page can be activated by accessing the corresponding URLs.

Configuring the URL files marks the final stage in the creation of your application. To test the Django quiz app, you can run it from the terminal using the following command:

```
$python manage.py runserver
```

Once the application is up and running, you can access it through your web browser. Start by navigating to the **Question Generator** page, where you can generate a few quizzes by providing the necessary inputs. After generating the quizzes, you can reboot the application by restarting the server.

Next, navigate to the **My Quiz** tab, which should be available in the navigation menu. Clicking on this tab will take you to the page where you will see the names of all the quizzes you previously generated. This list will be populated based on the quizzes stored in the database. It provides a convenient overview of the quizzes you have created (see _Figure 5.8_).

![Figure 5.8: Downloading Quizzes from the My Quiz Page](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781805127567/files/image/B21110\_05\_8.jpg)

Figure 5.8: Downloading Quizzes from the My Quiz Page

To download a specific quiz as a text file, simply click on the desired quiz from the list. This action will trigger the download functionality implemented in the application. The quiz will be downloaded as a text file, which you can save to your local machine. This allows you to access and review the quiz offline, print it, or share it with others if needed.

This is how we integrated the download quiz views into our Django application. We added functions to the **views.py** file, such as **history** to render the download history page, **TestListView** to display downloaded quizzes, and **download** to handle quiz downloads. These functions enable users to access and obtain quizzes generated by the Quiz Generation app. We also created the **downloads.html** template, modified from **base.html**, to display the download functionality. The **urls.py** files were modified to define URL patterns, allowing access to the **My Quiz** page and quizzes to be downloaded. To test the application, we generated quizzes using the **Question Generator** page, and then we navigated to the **My Quiz** page to view and download our quizzes.

## Summary <a href="#_idtextanchor085" id="_idtextanchor085"></a>

In this chapter, the focus was on building a Django project for a quiz generation application. We provided a step-by-step guide to set up and structure the project, including the installation of Django and important aspects such as database initialization, running a development server, and understanding the flow of views and URLs in Django. We also explored the concept of templates and demonstrated how to incorporate external CSS resources such as the Bootstrap framework.

We also explained how to integrate ChatGPT and Django for quiz generation. We illustrated the process of adding a text input field and a submit button to the application’s interface, enabling users to generate relevant questions using the ChatGPT API. We also discussed how to test the Quiz Generator application and outlined the next steps, which involve building a database to store the generated questions. You learned how to store the generated quizzes in an SQLite database, using Django’s models and database management capabilities, and download the stored quizzes.

This project was a comprehensive guide to building a Django-based quiz generation application, integrating ChatGPT for question generation, and implementing the functionality to download generated quizzes. You gained valuable experience to create your own interactive applications with Django.

In the next chapter, called _Language Translation Desktop App with ChatGPT API and Microsoft Word_, you will learn how to create a language translation desktop app using Python and the ChatGPT API. We will explain how to integrate the ChatGPT API with Microsoft Word to translate Word documents into different languages. The chapter will cover the creation of a user interface using the **Tkinter** library, allowing users to choose a target language and view real-time translations. It will also provide information on implementing language selection and file-browsing features, emphasizing the use of the powerful GPT-3.5 turbo language model for accurate translations.
