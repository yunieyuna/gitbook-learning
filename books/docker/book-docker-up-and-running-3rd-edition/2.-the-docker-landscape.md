# 2. The Docker Landscape

## Chapter 2. The Docker Landscape

Before you dive into configuring and installing Docker, a broad survey is in order to explain what Docker is and what it brings to the table. It is a powerful technology but not a tremendously complicated one at its core. In this chapter, we’ll cover the generalities of how Docker and Linux containers work, what makes them powerful, and some of the reasons you might use them. If you’re reading this, you probably have your reasons to use containers, but it never hurts to augment your understanding before you jump in.

Don’t worry—this chapter should not hold you up for too long. In the next chapter, we’ll dive right into getting Docker installed and running on your system.

## Process Simplification

Because Docker is a piece of software, it may not be obvious that it can also have a big positive impact on company and team processes if it is adopted and implemented well. So, let’s dig in and see how Docker and Linux containers can simplify both workflows and communication. This usually starts with the deployment story. Traditionally, the cycle of getting an application to production often looks something like the following (illustrated in [Figure 2-1](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch02.html#figure2-1)):

1. Application developers request resources from operations engineers.
2. Resources are provisioned and handed over to developers.
3. Developers script and tool their deployment.
4. Operations engineers and developers tweak the deployment repeatedly.
5. Additional application dependencies are discovered by developers.
6. Operations engineers work to install the additional requirements.
7. Loop over steps 4 through 6 _n_ more times.
8. The application is deployed.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0201.png" alt="A Non-Docker deployment workflow" height="417" width="600"><figcaption></figcaption></figure>

**Figure 2-1. A traditional deployment workflow (without Docker)**

Our experience has shown that when you are following traditional processes, deploying a brand-new application into production can take the better part of a week for a complex new system. That’s not very productive, and even though DevOps practices work to alleviate many of the barriers, it often still requires a lot of effort and communication between teams of people. This process can be both technically challenging and expensive, but even worse, it can limit the kinds of innovation that development teams will undertake in the future. If deploying new software is hard, time-consuming, and dependent on resources from another team, then developers may just build everything into the existing application in order to avoid suffering the new deployment penalty, or even worse, they may simply avoid solving problems that require new development efforts.

Push-to-deploy systems like [Heroku](https://www.heroku.com/) have shown developers what the world can look like if you are in control of your application and a majority of your dependencies. Talking with developers about deployment will often turn up discussions of how easy things are on Heroku or similar systems. If you’re an operations engineer, you’ve probably heard complaints about how much slower your internal systems are compared with “push-button” solutions like Heroku, which are built on top of Linux container technology.

Heroku is a whole environment, not just a container engine. While Docker doesn’t try to be everything that is included in Heroku, it provides a clean separation of responsibilities and encapsulation of dependencies, which results in a similar boost in productivity. Docker also allows even more fine-grained control than Heroku by putting developers in control of everything, down to the exact files and package versions that ship alongside their application. Some of the tooling and orchestrators that have been built on top of Docker (e.g., Kubernetes, Docker Swarm mode, and Mesos) aim to replicate the simplicity of systems like Heroku. But even though these platforms wrap more around Docker to provide a more capable and complex environment, a simple platform that uses only Docker still provides all of the core process benefits without the added complexity of a larger system.

As a company, Docker adopts an approach of “batteries included but removable.” This means that its tools come with everything most people need to get the job done while still being built from interchangeable parts that can easily be swapped in and out to support custom solutions. By using an image repository as the hand-off point, Docker allows the responsibility of building the application image to be separated from the deployment and operation of the container. What this means in practice is that development teams can build their application with all of its dependencies, run it in development and test environments, and then just ship the exact same bundle of application and dependencies to production. Because those bundles all look the same from the outside, operations engineers can then build or install standard tooling to deploy and run the applications. The cycle described in [Figure 2-1](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch02.html#figure2-1) then looks somewhat like this (illustrated in [Figure 2-2](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch02.html#figure2-2)):

1. Developers build the Docker image and ship it to the registry.
2. Operations engineers provide configuration details to the container and provision resources.
3. Developers trigger deployment.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0202.png" alt="A Docker deployment workflow" height="360" width="600"><figcaption></figcaption></figure>

**Figure 2-2. A Docker deployment workflow**

This is possible because Docker allows all of the dependency issues to be discovered during the development and test cycles. By the time the application is ready for its first deployment, that work has already been done. And it usually doesn’t require as many handoffs between the development and operations teams. In a well-refined pipeline, this can completely alleviate the need for anyone other than the development team to be involved in the creation and deployment of a new service. That’s a lot simpler and saves a lot of time. Better yet, it leads to more robust software through testing of the deployment environment before release.

## Broad Support and Adoption

Docker is well supported, with the majority of the large public clouds offering some direct support for it. For example, Docker and Linux containers have been used in Amazon Web Services (AWS) via multiple products like Amazon Elastic Container Service (Amazon ECS), Amazon Elastic Kubernetes Service (Amazon EKS), Amazon Fargate, and Amazon Elastic Beanstalk. Linux containers can also be used on Google App Engine (GAE), Google Kubernetes Engine, Red Hat OpenShift, IBM Cloud, Microsoft Azure, and many more. At DockerCon 2014, Google’s Eric Brewer announced that Google would be supporting Docker as its primary internal container format. Rather than just being good PR for these companies, what this meant for the Docker community was that a lot of money began to back the stability and success of the Docker platform.

Further building its influence, Docker’s image format for Linux containers has become the lingua franca among cloud providers, offering the potential for “write once, run anywhere” cloud applications. When Docker released its `libswarm` development library, an engineer from Orchard demonstrated deploying a Linux container to a heterogeneous mix of cloud providers at the same time. This kind of orchestration had not been easy before because every cloud provider offered a different API or toolset for managing instances, which were usually the smallest item you could manage with an API. What was only a promise from Docker in 2014 has since become fully mainstream as the largest companies continue to invest in the platform, support, and tooling. With most providers offering some form of Docker and Linux container orchestration as well as the container runtime itself, Docker is well supported for nearly any kind of workload in common production environments. If all of your tooling is built around Docker and Linux containers, then your applications can be deployed in a cloud-agnostic manner, allowing for new flexibility that was not previously possible.

In 2017, [Docker donated its `containerd` runtime](https://thenewstack.io/docker-donate-container-runtime-containerd-cloud-native-computing-foundation) to the [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/), and in 2019, it was elevated to the graduated project status.

Today, the use of Linux containers in development, delivery, and production is bigger than ever. In 2022, we saw that Docker started to lose a share of the server market to the newest versions of Kubernetes that no longer require the Docker daemon, but even these releases of Kubernetes rely very heavily on the `containerd` runtime, which was initially developed by Docker. Docker also continues to have a very strong presence in many developer and CI/CD workflows.

So, what about OS vendor support and adoption? The Docker client runs directly on most major operating systems, and the server can run on Linux or Windows Server. The vast majority of the ecosystem is built around Linux servers, but other platforms are increasingly being supported. The beaten path is and will likely continue to revolve around Linux servers running Linux containers.

**NOTE**

It is possible to run Windows containers natively (without a VM) on 64-bit versions of Windows Server 2016+. However, 64-bit versions of Windows 10+ Professional still require Hyper-V to provide the Windows Server kernel that is used for Windows containers. We will dive into a little more detail about this in [“Windows Containers”](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#windows\_containers).

It is also worth noting here that Windows can run Linux containers outside a virtual machine by leveraging WSL 2 (Windows Subsystem for Linux, version 2).

To support the growing demand for Docker tooling in development environments, Docker has released easy-to-use implementations for macOS and Windows. These appear to run natively but are still utilizing a small Linux virtual machine to provide the Docker server and Linux kernel. Docker has traditionally been developed on the Ubuntu Linux distribution, but most Linux distributions and other major operating systems are now supported where possible. Red Hat, for example, has gone all in on containers, and all of its platforms have first-class support for Docker. With the near-ubiquity of containers in the Linux realm, we now have distributions like Red Hat’s Fedora CoreOS, which is built entirely for Linux container workloads.

In the first years after Docker’s release, a set of competitors and service providers voiced concerns about Docker’s proprietary image format. Containers on Linux did not have a standard image format, so Docker, Inc., created its own according to the needs of its business.

Service providers and commercial vendors were particularly reluctant to build platforms that might be subject to the whims of a company with overlapping interests to their own. Docker as a company faced some public challenges in that period as a result. To gain some goodwill and support wider adoption in the marketplace, Docker, Inc., decided to help sponsor [the Open Container Initiative (OCI)](https://www.opencontainers.org/) in June of 2015. The first full specification from that effort was released in July 2017 and was based in large part on version 2 of the Docker image format. It is now possible to apply for OCI certification for both container images and container runtimes.

This is the primary high-level OCI-certified runtime:

* [`containerd`](https://containerd.io/), which is the default high-level runtime in modern versions of Docker and Kubernetes.

These lower-level OCI-certified runtimes can be used by `containerd` to manage and create containers:

* [`runc`](https://github.com/opencontainers/runc) is often used as the default lower-level runtime by `containerd`.
* [`crun`](https://github.com/containers/crun) is written in C and designed to be fast and have a small memory footprint.
* [Kata Containers](https://katacontainers.io/) from Intel, Hyper, and the OpenStack Foundation is a virtualized runtime that can run a mix of containers and virtual machines.
* [gVisor](https://github.com/google/gvisor) from Google is a sandboxed runtime, implemented entirely in user space.
* [Nabla Containers](https://nabla-containers.github.io/) provide another sandboxed runtime designed to significantly reduce the attack surface of Linux containers.

The space around deploying containers and orchestrating entire systems of containers continues to expand, too. Many of these are open source and available both on premises and as cloud or software as a service (SaaS) offerings from various providers, either in their clouds or yours. Given the amount of investment continuing to pour into the Linux container space, it’s likely that Docker will continue to have an important role in the modern internet.

## Architecture

Docker is a powerful technology, and that often indicates both tools and processes that come with a high level of complexity. And, under the hood, Docker is fairly complex; however, its fundamental user-facing structure is indeed a simple client/server model. Several pieces are sitting behind the Docker API, including `containerd` and `runc`, but the basic system interaction is a client talking over an API to a server. Underneath this simple exterior, Docker heavily leverages kernel mechanisms such as iptables, virtual bridging, Linux control groups (cgroups), Linux namespaces, Linux capabilities, secure computing mode, various filesystem drivers, and more. We’ll talk about some of these in [Chapter 11](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch11.html#advanced\_topics). For now, we’ll go over how the client and server work and give a brief introduction to the network layer that sits underneath a Linux container in Docker.

### Client/Server Model

It’s easiest to think of Docker as consisting of two parts: the client and the server/daemon (see [Figure 2-3](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch02.html#figure2-3)). Optionally there is a third component called the _registry_, which stores Docker images and their metadata. The server does the ongoing work of building, running, and managing your containers, and you use the client to tell the server what to do. The Docker [daemon](https://en.wikipedia.org/wiki/Daemon\_\(computing\)) can run on any number of servers in the infrastructure, and a single client can address any number of servers. Clients drive all of the communication, but Docker servers can talk directly to image registries when told to do so by the client. Clients are responsible for telling servers what to do, and servers focus on hosting and managing containerized applications.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0203.png" alt="Docker Client/Server Model" height="252" width="600"><figcaption></figcaption></figure>

**Figure 2-3. Docker client/server model**

Docker is a little different in structure from some other client/server software. It has a `docker` client and a `dockerd` server, but rather than being entirely monolithic, the server then orchestrates a few other components behind the scenes on behalf of the client, including `containerd-shim-runc-v2`, which is used to interact with `runc` and `containerd`. Docker cleanly hides any complexity behind the simple server API, though, so you can just think of it as a straightforward client and server for most purposes. Each Docker host will normally have one Docker server running that can manage any number of containers. You can then use the `docker` command-line tool to talk to the server, either from the server itself or, if properly secured, from a remote client. We’ll talk more about that shortly.

### Network Ports and Unix Sockets

The `docker` command-line tool and `dockerd` daemon can talk to each other over Unix sockets and network ports. Docker, Inc., has registered three ports with the [Internet Assigned Numbers Authority (IANA)](https://www.iana.org/) for use by the Docker daemon and client: TCP port 2375 for unencrypted traffic, port 2376 for encrypted SSL connections, and port 2377 for Docker Swarm mode. Using a different port is easily configurable for scenarios where you need to use different settings. The default setting for the Docker installer is to only use a Unix socket for communication with the local Docker daemon. This ensures that the system defaults to the most secure installation possible. This is also easily configurable, but it is highly recommended that network ports are not used with Docker, due to the lack of user authentication and role-based access controls within the Docker daemon. The Unix socket can be located in different paths on different operating systems, but in most cases, it can be found here: _/var/run/docker.sock_. If you have strong preferences for a different location, you can usually specify this at install time or simply change the server configuration afterward and restart the daemon. If you don’t, then the defaults will probably work for you. As with most software, following the defaults will save you a lot of trouble if you don’t need to change them.

**TIP**

Recent versions of Docker Desktop may create the _docker.sock_ file in the user’s home directory inside _.docker/run/_ and then simply link _\_/var/run/docker.sock_ to this location.

### Robust Tooling

Among the many things that have led to Docker’s strong adoption is its simple and powerful tooling. Since its initial release, its capabilities have been expanding ever wider, thanks to efforts from the Docker community at large. The tooling that Docker ships with supports building Docker images, basic deployment to individual Docker daemons, a distributed mode called Swarm mode, and all the functionality needed to manage a remote Docker server. Beyond the included Swarm mode, community efforts have focused on managing whole fleets (or clusters) of Docker servers and scheduling and orchestrating container deployments.

**NOTE**

When we talk about [Docker Swarm or Swarm mode](https://docs.docker.com/engine/swarm) in this book, we are referring to the built-in Swarm functionality in the Docker client and server, which leverages another underlying library called SwarmKit. When searching for articles on the internet, you may find references to an older standalone version of Docker Swarm, which is often referred to as [Docker Swarm “Classic”](https://github.com/docker-archive/classicswarm) nowadays.

Docker has also launched its own orchestration toolset, including [Compose](https://github.com/docker/compose), [Docker Desktop](https://www.docker.com/products/docker-desktop), and [Swarm mode](https://docs.docker.com/engine/swarm), which creates a cohesive deployment story for developers. Docker’s offerings in the production orchestration space have been largely overshadowed by Google’s Kubernetes, although it should be noted that [Kubernetes relied heavily on Docker until v1.24 was released in early 2022](https://kubernetes.io/blog/2020/12/02/dockershim-faq). But Docker’s orchestration tools remain useful, with Compose being particularly handy for local development.

Because Docker provides both a command-line tool and a remote REST API, it is easy to add further tooling in any language. The command-line tool lends itself well to shell scripting, and anything the client can do can also be done programmatically via the REST API. The Docker CLI is so well-known that many other Linux container CLI tools, like [`podman`](https://podman.io/) and [`nerdctl`](https://github.com/containerd/nerdctl), mimic its arguments for compatibility and easy adoption.

### Docker Command-Line Tool

The command-line tool `docker` is the main interface that most people will have with Docker. The Docker client is a [Go program](https://golang.org/) that compiles and runs on all common architectures and operating systems. The command-line tool is available as part of the main Docker distribution on various platforms and also compiles directly from the Go source. Some of the things you can typically do with the Docker command-line tool include, but are not limited to, the following:

* Building a container image
* Pulling images from a registry to a Docker daemon or pushing them up to a registry from the Docker daemon
* Starting a container on a Docker server either in the foreground or background
* Retrieving the Docker logs from a remote server
* Interactively running a command inside a running container on a remote server
* Monitoring statistics about your container
* Getting a process listing from your container

You can probably see how these can be composed into a workflow for building, deploying, and observing applications. But the Docker command-line tool is not the only way to interact with Docker, and it’s not necessarily the most powerful.

### Docker Engine API

Like many other pieces of modern software, the Docker daemon has an API. This is in fact what the Docker command-line tool uses to communicate with the daemon. But because the API is documented and public, it’s quite common for external tooling to use the API directly. This provides a convenient mechanism that allows any tool to create, inspect, and manage all of the images and containers that are under the Docker daemon’s management. While it’s unlikely that beginners will initially want to talk directly to the Docker API, it’s a great tool to have available. As your organization embraces Docker over time, you will increasingly find the API to be a good integration point for this tooling.

Extensive documentation for the [API](https://dockr.ly/2wxCHnx) is on the Docker site. As the ecosystem has matured, robust implementations of Docker API libraries have emerged for all popular languages. Docker maintains [SDKs for Python and Go](https://dockr.ly/2wxCHnx), and there are additional libraries maintained by third parties that are worth considering. For example, over the years we have used these [Go](https://github.com/fsouza/go-dockerclient) and [Ruby](https://github.com/upserve/docker-api) libraries and have found them to be both robust and rapidly updated as new versions of Docker are released.

Most of the things you can do with the Docker command-line tooling are supported relatively easily via the API. Two notable exceptions are the endpoints that require streaming or terminal access: running remote shells or executing the container in interactive mode. In these cases, it’s often easier to use one of these solid client libraries or the command-line tool.

### Container Networking

Even though Linux containers are largely made up of processes running on the host system itself, they usually behave quite differently from other processes at the network layer. Docker initially supported a single networking model but now supports a robust assortment of configurations that handle most application requirements. Most people run their containers in the default configuration, called _bridge mode_. So let’s take a look at how it works.

To understand bridge mode, it’s easiest to think of each of your Linux containers as behaving like a host on a private network. The Docker server acts as a virtual bridge, and the containers are clients behind it. A bridge is just a network device that repeats traffic from one side to another. So you can think of it like a mini virtual network, with each container acting like a host attached to that network. The actual implementation (see [Figure 2-4](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch02.html#figure02-1)) is that each container has a virtual Ethernet interface connected to the Docker bridge and an IP address allocated to the virtual interface. Docker lets you bind and expose individual or groups of ports on the host to the container so that the outside world can reach your container on those ports. The traffic is largely managed by the [vpnkit](https://github.com/moby/vpnkit) library.

Docker allocates the private subnet from an unused [RFC 1918](https://www.rfc-editor.org/rfc/rfc1918) private subnet block. It detects which network blocks are unused on the host and allocates one of those to the virtual network. That is bridged to the host’s local network through an interface on the server called `docker0`. This means that, by default, all of the containers are on a network together and can talk to one another directly. But to get to the host or the outside world, they go over the `docker0` virtual bridge interface.

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0204.png" alt="The network on a typical Docker server" height="289" width="600"><figcaption></figcaption></figure>

**Figure 2-4. The network on a typical Docker server**

There is a dizzying array of ways in which you can configure Docker’s network layer, from allocating your own network blocks to configuring your own custom bridge interface. People often run with the default mechanisms, but there are times when something more complex or specific to your application is required. You can find much more detail about Docker networking in the [documentation](https://dockr.ly/2otp461), and we will cover more details in [Chapter 11](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch11.html#advanced\_topics).

**NOTE**

When developing your Docker workflow, you should get started with the default networking approach. You might later find that you don’t want or need this default virtual network. Networking is configurable per container, and you can switch off the whole virtual network layer entirely for a container using the `--net=host` switch to `docker container run`. When running in that mode, Linux containers use the host’s own network devices and addresses, and no virtual interfaces or bridges are provisioned. Note that host networking has security implications you might need to consider. Other network topologies are possible and discussed in [Chapter 11](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch11.html#advanced\_topics).

## Getting the Most from Docker

Like most tools, Docker has a number of great use cases, and others that aren’t so good. You can, for example, open a glass jar with a hammer. But that has its downsides. Understanding how to best use the tool, or even simply determining if it’s the right tool, can get you on the correct path much more quickly.

To begin with, Docker’s architecture is aimed squarely at applications that are either stateless or where the state is externalized into data stores like databases or caches. Those are the easiest to containerize. Docker enforces some good development principles for this class of application, and we’ll talk later about how that’s powerful. But this means that doing things like putting a database engine inside Docker is a bit like swimming against the current. It’s not that you can’t do it, or even that you shouldn’t do it; it’s just that this is not the most obvious use case for Docker, so if it’s the one you start with, you may find yourself disappointed early on. Databases that run well in Docker are now often deployed this way, but this is not the simple path. Some good applications for beginning with Docker include web frontends, backend APIs, and short-running tasks like maintenance scripts that might normally be handled by `cron`.

If you focus first on building an understanding of running stateless or externalized-state applications inside containers, you will have a foundation on which to start considering other use cases. We strongly recommend starting with stateless applications and learning from that experience before tackling other use cases. The community is continuously working on how to better support stateful applications in Docker, and there are likely to be many developments in this area.

### Containers Are Not Virtual Machines

A good way to start shaping your understanding of how to leverage Docker is to think of Linux containers not as virtual machines (VMs) but as very lightweight wrappers around a single Unix process. During actual implementation, that process might spawn other processes, but on the other hand, one statically compiled binary could be all that’s inside your container (see [“Outside Dependencies”](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch09.html#dependencies) for more information). Containers are also ephemeral: they may come and go much more readily than a traditional virtual machine.

Virtual machines are by design a stand-in for real hardware that you might throw in a rack and leave there for a few years. Because a real server is what they’re abstracting, virtual machines are often long-lived in nature. Even in the cloud where companies often spin virtual machines up and down on demand, they usually have a running life span of days or more. On the other hand, a particular container might exist for months, or it may be created, run a task for a minute, and then be destroyed. All of that is OK, but it’s a fundamentally different approach than the one virtual machines are typically used for.

To help drive this differentiation home, if you run Docker on a mac or Windows system, you are leveraging a Linux virtual machine to run `dockerd`, the Docker server. However, on Linux, `dockerd` can be run natively, and therefore there is no need for a virtual machine to be run anywhere on the system (see [Figure 2-5](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch02.html#figure2-4)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0205.png" alt="Typical Docker Installations" height="231" width="600"><figcaption></figcaption></figure>

**Figure 2-5. Typical Docker installations**

### Limited Isolation

Containers are isolated from one another, but that isolation is probably more limited than you might expect. While you can put limits on their resources, the default container configuration just has them all sharing CPU and memory on the host system, much as you would expect from colocated Unix processes. This means that unless you constrain them, containers can compete for resources on your production machines. That might be fine for your use case, but it impacts your design decisions. Limits on CPU and memory use are encouraged through Docker, but in most cases, they are not the default like they would be with a virtual machine.

It’s often the case that many containers share one or more common filesystem layers. That’s one of the more powerful design decisions in Docker, but it also means that if you update a shared image, you may also need to rebuild and redeploy containers that are still utilizing the older image.

Containerized processes are just processes on the Docker server itself. They are running on the same instance of the Linux kernel as the host operating system. All container processes show up in the normal `ps` output on the Docker server. That is utterly different from a hypervisor, where the depth of process isolation usually includes running an entirely separate instance of the operating system kernel for each virtual machine.

This light containment can lead to the tempting option of exposing more resources from the host, such as shared filesystems to allow the storage of state. But you should think hard before further exposing resources from the host into the container unless they are used exclusively by the container. We’ll talk about the security of containers later, but generally, you might consider helping to enforce isolation further by applying [Security-Enhanced Linux (SELinux)](https://www.redhat.com/en/topics/linux/what-is-selinux) or [AppArmor](https://apparmor.net/) policies rather than compromising the existing barriers.

**WARNING**

By default, many containers use UID 0 to launch processes. Because the container is _contained_, this seems safe, but in reality, it isn’t very safe. Because everything is running on the same kernel, many types of security vulnerabilities or simple misconfiguration can give the container’s `root` user unauthorized access to the host’s system resources, files, and processes. Refer to [“Security”](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch11.html#security) for a discussion of how to mitigate this.

### Containers Are Lightweight

We’ll get more into the details of how this works later, but creating a new container can take up very little disk space. A quick test reveals that a newly created container from an existing image takes a whopping 12 kilobytes of disk space. That’s pretty lightweight. On the other hand, a new virtual machine created from a golden image might require hundreds or thousands of megabytes, since at a minimum it requires a full operating install to exist on that disk. The new container, on the other hand, is so small because it is just a reference to a layered filesystem image and some metadata about the configuration. By default, no copy of the data is allocated to the container. Containers are just processes on the existing system that may only need to read information from the disk, so there may not be a need to copy any data for the exclusive use of the container, until a time when it needs to write data that is unique to that container instance.

The lightness of containers means that you can use them for situations where creating another virtual machine would be too heavyweight or where you need something to be truly ephemeral. You probably wouldn’t, for instance, spin up an entire virtual machine to run a `curl` command to a website from a remote location, but you might spin up a new container for this purpose.

### Toward an Immutable Infrastructure

By deploying most of your applications within containers, you can start simplifying your configuration management story by moving toward an immutable infrastructure, where components are replaced entirely rather than changed in place. The idea of an immutable infrastructure has gained popularity in response to how difficult it is, in reality, to maintain a truly idempotent configuration management codebase. As your configuration management codebase grows, it can become as unwieldy and unmaintainable as large, monolithic legacy applications.

With Docker, it is possible to deploy a very lightweight Docker server that needs almost no configuration management, or in many cases, none at all. You handle all of your application management simply by deploying and redeploying containers to the server. When the server needs an important update to something like the Docker daemon or the Linux kernel, you can simply bring up a new server with the changes, deploy your containers there, and then decommission or reinstall the old server.

Container-based Linux distributions like [Red Hat’s Fedora CoreOS](https://getfedora.org/en/coreos) are designed around this principle. But rather than requiring you to decommission the instance, Fedora CoreOS can entirely update itself and switch to the updated OS. Your configuration and workload largely remain in your containers, and you don’t have to configure the OS very much at all.

Because of this clean separation between deployment and configuration of your servers, many container-based production systems are using tools such as [HashiCorp’s Packer](https://www.packer.io/intro/index.html) to build cloud virtual server images, and then leveraging Docker to nearly or entirely avoid configuration management systems.

### Stateless Applications

A good example of the kind of application that containerizes well is a web application that keeps its state in a database. Stateless applications are normally designed to immediately answer a single self-contained request and have no need to track information between requests from one or more clients. You might also run something like ephemeral [Memcached](https://memcached.org/) instances in containers. If you think about your web application, though, it probably has some local state that you rely on, like configuration files. That might not seem like a lot of state, but if you bake that configuration into your images, it means that you’ve limited the reusability of your image and made it more challenging to deploy into different environments, without maintaining multiple images for different deployment targets.

In many cases, the process of containerizing your application means that you move configuration state into environment variables that can be passed to your application at runtime. Rather than baking the configuration into the container, you apply the configuration to the container when it is deployed. This allows you to easily do things like use the same container to run in either production or staging environments. In most companies, those environments would require many different configuration settings like the connection URLs for various external services that the application utilizes.

With containers, you might also find that you are always decreasing the size of your containerized application as you optimize it down to the bare essentials required to run. We have found that thinking of anything that you need to run in a distributed way as a container can lead to some interesting design decisions. If, for example, you have a service that collects some data, processes it, and returns the result, you might configure containers on many servers to run the job and then aggregate the response on another container.

### Externalizing State

If Docker works best for stateless applications, how do you best store state when you need to? Configuration is typically passed by environment variables, for example. Docker supports environment variables natively, and they are stored in the metadata that makes up a container configuration. This means that restarting the container will ensure that the same configuration is passed to your application each time. It also makes the configuration of the container easily observable while it’s running, which can make debugging a lot easier, although there are some security concerns around exposing secrets in environment variables. It is also possible to store and retrieve your application configuration inside an external datastore, like [Consul](https://www.consul.io/) or [PostgreSQL](https://www.postgresql.org/).

Databases are often where scaled applications store state, and nothing in Docker interferes with doing that for containerized applications. Applications that need to store files, however, face some challenges. Storing things to the container’s filesystem is not performant, will be limited by space, and will not preserve state when a container is re-created. If you redeploy a stateful service without utilizing storage external to the container, you will lose all of that state. Applications that need to store filesystem state should be carefully considered before you put them into Docker. If you decide that you can benefit from Linux containers in these cases, it’s best to design a solution where the state can be stored in a centralized location that could be accessed regardless of which host a container runs on. In certain cases, this might mean using a service like Amazon Simple Storage Service (Amazon S3), OpenStack Swift, or a local block store, or even mounting EBS volumes or iSCSI disks inside the container. [Docker volume plug-ins](https://docs.docker.com/engine/extend/plugins\_volume) provide some additional options and are briefly discussed in [Chapter 11](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch11.html#advanced\_topics).

**TIP**

Although it is possible to externalize state on the host’s local filesystem, it is not generally encouraged by the community and should be considered an advanced use case. It is strongly recommended that you start with applications that don’t need persistent state. There are multiple reasons why this is typically discouraged, but in almost all cases it is because it introduces dependencies between the container and the host that interfere with using Docker as a truly dynamic, horizontally scalable application delivery service. If your container maintains state on the local host filesystem, then it can only be deployed to the system that houses that local filesystem. Remote volumes that can be dynamically attached are a good solution but also an advanced use case.

## The Docker Workflow

Like many tools, Docker strongly encourages a particular workflow. It’s a very enabling workflow that maps well to how many companies are organized, but it’s probably a little different than what you or your team are doing now. Having adapted our own organizations’ workflows to the Docker approach, we can confidently say that this is a change that can have a wide-reaching positive impact on many teams in your organization. If the workflow is implemented well, it can help you realize the promise of reduced communication overhead between teams.

### Revision Control

The first thing that Docker gives you out of the box is two forms of revision control. One of them is used to track the filesystem layers that each Docker image is comprised of, and the other is a tagging system for those images.

#### Filesystem layers

Linux containers are made up of stacked filesystem layers, each identified by a unique hash, where each new set of changes made during the build process is laid on top of the previous changes. That’s great because it means that when you do a new build, you only have to rebuild the layers that follow the change you’re deploying. This saves time and bandwidth because containers are shipped around as layers, and you don’t have to ship layers that a server already has stored. If you’ve done deployments with many classic deployment tools, you know that you can end up shipping hundreds of megabytes of the same data to a server over and over with each deployment. That’s incredibly inefficient, and worse, you can’t be sure exactly what changed between deployments. Because of the layering effect, and because Linux containers include all of the application dependencies, with Docker you can be more confident about the changes that you are shipping to production.

To simplify this a bit, remember that a Docker image contains everything required to run your application. If you change one line of code, you certainly don’t want to waste time rebuilding every dependency that your code requires into a new image. Instead, by leveraging the build cache, Docker can ensure that only the layers affected by the code change are rebuilt.

#### Image tags

The second kind of revision control offered by Docker makes it easy to answer an important question: what was the previous version of the application that was deployed? That’s not always easy to answer. There are a lot of solutions for non-containerized applications, from Git tags for each release, to deployment logs, to tagged builds for deployment, and many more. If you’re coordinating your deployment with [Capistrano](https://capistranorb.com/), for example, it will handle this for you by keeping a set number of previous releases on the server and then using symlinks to make one of them the current release.

But what you find in any scaled production environment is that each application has a unique way of handling deployment revisions. Many of them do the same thing, but some may be different. Worse, in heterogeneous language environments, the deployment tools are often entirely different between applications, and very little is shared. So the question “What was the previous version?” can have many answers depending on whom you ask and which application you’re referring to. Docker has a built-in mechanism for handling this: image tagging a standard build step. You can easily leave multiple revisions of your application on the server so that performing a rollback is trivial. This is not rocket science, and it’s not functionality that is hard to find in other deployment tooling, but with container images, it can easily be made standard across all of your applications, and everyone can have the same expectations about how things will be tagged for all applications. This makes communication easier between teams, and it makes tooling much simpler because there is one source of truth for application releases.

**WARNING**

In many examples online and in this book, you will see people use the `latest` tag for a container image. This is useful when you’re getting started and when you’re writing examples, as it will always grab the most recent build of an image. But since this is a floating tag, it is a really bad idea to use `latest` in most production workflows, as your dependencies can get updated out from under you, and it is impossible to roll back to `latest` because the old version is no longer the one tagged `latest`. It also makes it hard to verify if the same image is running on different servers. The rule of thumb is: don’t use the `latest` tag in production. It’s not even a good idea to use the `latest` tag from upstream images, for the same reasons.

It is highly recommended that you tag your CI/CD builds with something that uniquely identifies the exact source code commit that was used to build them. In a `git` workflow, this could be the git hash related to the commit. Once you are ready to release an image, the recommendation is that you use [semantic versioning](https://semver.org/) and provide your image with tags, like 1.4.3, 2.0.0, etc.

Pinning versions requires a bit more work to keep them current, but it will also prevent many unfortunate and poorly timed surprises during builds and deployments.

### Building

Building applications is a black art in many organizations, where a few people know all the levers to pull and knobs to turn to spit out a well-formed, shippable artifact. Part of the heavy cost of getting a new application deployed is getting the build just right. Docker doesn’t solve all of these problems, but it does provide a standardized tool configuration and toolset for builds. That makes it a lot easier for people to learn how to build your applications and to get new builds up and running.

The Docker command-line tool contains a `build` flag that will consume a _Dockerfile_ and produce a Docker image. Each command in a _Dockerfile_ generates a new layer in the image, so it’s easy to reason about what the build is going to do by looking at the _Dockerfile_ itself. The great part of all of this standardization is that any engineer who has worked with a _Dockerfile_ can dive right in and modify the build of any other application. Because the Docker image is a standardized artifact, all of the tooling behind the build will be the same regardless of the development language or base image that is being used or the number of layers needed. The _Dockerfile_ is usually checked into a revision control system, which also means that tracking changes to the build is simplified. Modern multistage Docker builds also allow you to define the build environment separately from the final artifact image. This provides huge “configure ability” for your build environment just like you’d have for a production container.

Many Docker builds are a single invocation of the `docker image build` command and generate a single artifact, the container image. Because it’s usually the case that most of the logic about the build is wholly contained in the _Dockerfile_, it’s easy to create standard build jobs for any team to use in build systems like [Jenkins](https://jenkins-ci.org/). As a further standardization of the build process, many companies—eBay, for example—have standardized Linux containers to do the image builds from a _Dockerfile_. SaaS build offerings like [Travis CI](https://travis-ci.com/) and [CodeShip](https://codeship.com/) also have first-class support for Docker builds.

It is also possible to automate the creation of multiple images that support different underlying compute architectures, like x86 and ARM, by utilizing the newer [BuildKit](https://github.com/moby/buildkit) support in Docker.

### Testing

While Docker itself does not include a built-in framework for testing, the way containers are built lends some advantages to testing with Linux containers.

Testing a production application can take many forms, from unit testing to full integration testing in a semi-live environment. Docker facilitates better testing by guaranteeing that the artifact that passed testing will be the one that ships to production. This can be guaranteed because we can either use the Docker SHA for the container, or a custom tag to make sure we’re consistently shipping the same version of the application.

Since, by design, containers include all of their dependencies, tests run on containers are very reliable. If a unit test framework says tests were successful against a container image, you can be sure that you will not experience a problem with the versioning of an underlying library at deployment time, for example. That’s not easy with most other technologies, and even Java WAR (Java Web application ARchive) files, for example, don’t include testing of the application server itself. That same Java application deployed in a Linux container will generally also include an application server like Tomcat, and the whole stack can be smoke tested before shipping to production.

A secondary benefit of shipping applications in Linux containers is that in places where there are multiple applications that talk to one another remotely via something like an API, developers of one application can easily develop against a version of the other service that is currently tagged for the environment they require, like production or staging. Developers on each team don’t have to be experts in how the other service works or is deployed just to do development on their own application. If you expand this to a service-oriented architecture with innumerable microservices, Linux containers can be a real lifeline to developers or QA engineers who need to wade into the swamp of inter-microservice API calls.

A common practice in organizations that run Linux containers in production is for automated integration tests to pull down a versioned set of Linux containers for different services, matching the current deployed versions. The new service can then be integration-tested against the very same versions it will be deployed alongside. Doing this in a heterogeneous language environment would previously have required a lot of custom tooling, but it becomes reasonably simple to implement because of the standardization provided by Linux containers.

### Packaging

Docker builds produce an image that can be treated as a single build artifact, although technically they may consist of multiple filesystem layers. No matter which language your application is written in or which distribution of Linux you run it on, you get a layered Docker image as the result of your build. And it is all built and handled by the Docker tooling. That build image is the shipping container metaphor that Docker is named for: a single, transportable unit that universal tooling can handle, regardless of what it contains. Like oceanic cargo ships that package everything into steel containers, your Docker tooling will only ever have to deal with one kind of package: the Docker image. That’s powerful, because it’s a huge facilitator of tool reuse between applications, and it means that someone else’s off-the-shelf container tools will work with your build images.

Applications that traditionally took a lot of custom configuration to deploy onto a new host or development system become very portable with Docker. Once a container is built, it can easily be deployed on any system with a running Docker server on the same architecture.

### Deploying

Deployments are handled by so many kinds of tools in different shops that it would be impossible to list them here. Some of these tools include shell scripting, [Capistrano](https://capistranorb.com/), [Fabric](https://www.fabfile.org/), [Ansible](https://www.ansible.com/), and in-house custom tooling. In our experience with multiteam organizations, there are usually one or two people on each team who know the magical incantation to get deployments to work. When something goes wrong, the team is dependent on them to get it running again. As you probably expect by now, Docker makes most of that a nonissue. The built-in tooling supports a simple, one-line deployment strategy to get a build onto a host and up and running. The standard Docker client handles deploying only to a single host at a time, but there is a large array of tools available that make it easy to deploy into a cluster of Docker or other compatible Linux container hosts. Because of the standardization Docker provides, your build can be deployed into any of these systems, with low complexity on the part of the development teams.

### The Docker Ecosystem

Over the years, a wide community has formed around Docker, driven by both developers and system administrators. Like the DevOps movement, this has facilitated better tools by applying code to operations problems. Where there are gaps in the tooling provided by Docker, other companies and individuals have stepped up to the plate. Many of these tools are also open source. That means they are expandable and can be modified by any other company to fit its needs.

**NOTE**

Docker is a commercial company that has contributed much of the core Docker source code to the open source community. Companies are strongly encouraged to join the community and contribute back to the open source efforts. If you are looking for supported versions of the core Docker tools, you can find out more about its offerings at the [Docker website](https://www.docker.com/support).

#### Orchestration

The first important category of tools that add functionality to the core Docker distribution and Linux container experience contains orchestration and mass deployment tools. Early mass deployment tools like [New Relic’s Centurion](https://github.com/newrelic/centurion), [Spotify’s Helios](https://github.com/spotify/helios), and the [Ansible Docker tooling](https://oreil.ly/V8X\_f)[1](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch02.html#idm46803169305904) still work largely like traditional deployment tools but leverage the container as the distribution artifact. They take a fairly simple, easy-to-implement approach. You get a lot of the benefits of Docker without much complexity, but many of these tools have been replaced by more robust and flexible tools, like Kubernetes.

Fully automatic schedulers like [Kubernetes](https://kubernetes.io/) or [Apache Mesos](https://mesos.apache.org/) with the [Marathon scheduler](https://mesosphere.github.io/marathon) are more powerful options that take nearly complete control of a pool of hosts on your behalf. Other commercial entries are widely available, such as [HashiCorp’s Nomad](https://www.nomadproject.io/), [Mesosphere’s DC/OS (Datacenter Operating System)](https://dcos.io/), and [Rancher](https://rancher.com/).[2](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch02.html#idm46803169292128) The ecosystems of both free and commercial options continue to grow rapidly.

#### Immutable atomic hosts

One additional idea that you can leverage to enhance your Docker experience is immutable atomic hosts. Traditionally, servers and virtual machines are systems that an organization will carefully assemble, configure, and maintain to provide a wide variety of functionality that supports a broad range of usage patterns. Updates must often be applied via nonatomic operations, and there are many ways in which host configurations can diverge and introduce unexpected behavior into the system. Most running systems are patched and updated in place in today’s world. Conversely, in the world of software deployments, most people deploy an entire copy of their application, rather than trying to apply patches to a running system. Part of the appeal of containers is that they help make applications even more atomic than traditional deployment models.

What if you could extend that core container pattern down into the operating system? Instead of relying on configuration management to try to update, patch, and coalesce changes to your OS components, what if you could simply pull down a new, thin OS image and reboot the server? And then if something breaks, easily roll back to the exact image you were previously using?

This is one of the core ideas behind Linux-based atomic host distributions, like [Red Hat’s Fedora CoreOS](https://getfedora.org/en/coreos), [Bottlerocket OS](https://github.com/bottlerocket-os/bottlerocket), and others. Not only should you be able to easily tear down and redeploy your applications, but the same philosophy should apply for the whole software stack. This pattern helps provide very high levels of consistency and resilience to the whole stack.

Some of the typical characteristics of an immutable or [atomic host](https://gist.github.com/jzb/0f336c6f23a0ba145b0a) are a minimal footprint, a design focused on supporting Linux containers and Docker, and atomic OS updates and rollbacks that can easily be controlled via multihost orchestration tools on both bare-metal and common virtualization platforms.

In [Chapter 3](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch03.html#installing\_docker), we will discuss how you can easily use these immutable hosts in your development process. If you are also using these hosts as deployment targets, this process creates a previously unheard-of amount of software stack symmetry between your development and production environments.

#### Additional tools

Docker is not just a standalone solution. It has a massive feature set, but there is always a case where someone needs more than it can deliver on its own. There is a wide ecosystem of tools to either improve or augment Docker’s functionality. Some good production tools leverage the Docker API, like [Prometheus](https://prometheus.io/) for monitoring and [Ansible](https://www.ansible.com/) for simple orchestration. Others leverage Docker’s plug-in architecture. Plug-ins are executable programs that conform to a specification for receiving and returning data to Docker.

**WARNING**

Many of the Docker plug-ins are considered legacy and are being replaced with better approaches. Make sure that you perform adequate research before deciding on a plug-in that you are going to utilize, to ensure that it is the best option and is not going to be unsupported or quickly replaced.

There are many more good tools that either talk to the API or run as plug-ins. Many of these have sprung up to make life with Docker easier on the various cloud providers. These help with seamless integration between Docker and the cloud. As the community continues to innovate, the ecosystem continues to grow. There are new solutions and tools available in this space on an ongoing basis. If you find you are struggling with something in your environment, look to the ecosystem!

## Wrap-Up

There you have it: a quick tour through Docker. We’ll return to this discussion later on with a slightly deeper dive into the architecture of Docker, more examples of how to use the community tooling, and an exploration of some of the thinking behind designing robust container platforms. But you’re probably itching to try it all out, so in the next chapter, we’ll get Docker installed and running.

[1](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch02.html#idm46803169305904-marker) Full URL: [_https://docs.ansible.com/ansible/latest/collections/community/docker/docsite/scenario\_guide.html#ansible-collections-community-docker-docsite-scenario-guide_](https://docs.ansible.com/ansible/latest/collections/community/docker/docsite/scenario\_guide.html#ansible-collections-community-docker-docsite-scenario-guide)

[2](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch02.html#idm46803169292128-marker) Some of these commercial offerings have free editions of their platforms.
