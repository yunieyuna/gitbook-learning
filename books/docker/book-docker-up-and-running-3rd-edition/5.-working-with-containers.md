# 5. Working With Containers

Featured5. Working with Containers7h 17m remaining

## Chapter 5. Working with Containers

In the previous chapter, we learned how to build a Docker image and the very basic steps required for running the resulting image within a container. In this chapter, we’ll first take a look at the history of container technology and then dive deeper into running containers and exploring the Docker commands that control the overall configuration, resources, and privileges that your container receives.

## What Are Containers?

You might be familiar with virtualization systems like VMware or KVM that allow you to run a complete Linux kernel and operating system on top of a virtualized layer, commonly known as a _hypervisor_. This approach provides very strong isolation between workloads because each VM hosts its own operating system kernel that sits in a separate memory space on top of a hardware virtualization layer.

Containers are fundamentally different since they all share a single kernel, and isolation between workloads is implemented entirely within that one kernel. This is called _operating system virtualization_.

The [`libcontainer` README](https://github.com/opencontainers/runc/blob/main/libcontainer/README.md) provides a good, short definition of a container:

> A container is a self-contained execution environment that shares the kernel of the host system and is (optionally) isolated from other containers in the system.

One of the major advantages of containers is resource efficiency, because you don’t need a whole operating system instance for each isolated workload. Since you are sharing a kernel, there is one fewer layer of indirection between the isolated task and the real hardware underneath. When a process is running inside a container, there is only a little bit of code that sits inside the kernel managing the container. Contrast this with a VM, where a second layer would be running. In a VM, calls by the process to the hardware or hypervisor would require bouncing in and out of privileged mode on the processor twice, thereby noticeably slowing down many calls.

**NOTE**

[libcontainer](https://github.com/opencontainers/runc/tree/main/libcontainer) is a Go library that is designed to provide a standard interface for managing Linux containers from applications.

But the container approach does mean that you can only run processes that are compatible with the underlying kernel. For example, unlike hardware virtualization provided by technologies like VMware or KVM, Windows applications cannot run natively inside a Linux container on a Linux host. Windows applications can, however, run inside Windows containers on a Windows host. So containers are best thought of as an OS-specific technology where you can run any of your favorite applications or daemons that are compatible with the container server’s kernel. When thinking of containers, you should try very hard to throw out what you might already know about VMs and instead conceptualize a container as a wrapper around a normal process that runs on the server.

**NOTE**

In addition to being able to run containers inside VMs, it is completely feasible to run a VM inside a container. If you do this, then it is indeed possible to run a Windows application inside a Windows VM that is running inside a Linux container.

### History of Containers

It is often the case that a revolutionary technology is an older technology that has finally arrived in the spotlight. Technology goes in waves, and some of the ideas from the 1960s are back in vogue. Similarly, Docker is a newer technology, and it has an ease of use that has made it an instant hit, but it doesn’t exist in a vacuum. Much of what underpins Docker comes from work done over the last 30 years in a few different areas. We can easily trace the conceptual evolution of containers from a simple system call that was added to the Unix kernel in the late 1970s to the modern container tooling that powers many huge internet firms, like Google, Twitter, and Meta. It’s worth taking some time for a quick tour through how the technology evolved and led to the creation of Docker, because understanding this helps you place it within the context of other things that you might be familiar with.

Containers are not a new idea. They are a way to isolate and encapsulate a part of the running system. The oldest technology in this area includes the very first batch processing systems. When using these early computers, the system would only run one program at a time, switching to run another program once the previous program had finished or a predefined time span had elapsed. With this design there was enforced isolation: you could make sure your program didn’t step on anyone else’s program because it was only possible to run one thing at a time. Although modern computers still switch tasks constantly, it is incredibly fast and completely unnoticeable to most users.

We would argue that the seeds for today’s containers were planted in 1979 with the addition of the `chroot` system call to Version 7 Unix. `chroot` restricts a process’s view of the underlying filesystem to a single subtree. The `chroot` system call is commonly used to protect the operating system from untrusted server processes like FTP, BIND, and Sendmail, which are publicly exposed and susceptible to compromise.

In the 1980s and 1990s, various Unix variants were created with mandatory access controls for security reasons.[1](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#idm46803149032576) This meant you had tightly controlled domains running on the same Unix kernel. Processes in each domain had an extremely limited view of the system that precluded them from interacting across domains. A popular commercial version of Unix that implemented this idea was the Sidewinder firewall built on top of BSDI Unix, but this was not possible with most mainstream Unix implementations.

That changed in 2000 when FreeBSD 4.0 was released with a new command, called `jail`, which was designed to allow shared-environment hosting providers to easily and securely create a separation between their processes and those that belonged to each of their customers. FreeBSD `jail` expanded `chroot`’s capabilities and also restricted everything a process could do with the underlying system and other jailed processes.

In 2004, Sun released an early build of Solaris 10, which included Solaris containers, which later evolved into Solaris Zones. This was the first major commercial implementation of container technology and is still used today to support many commercial container implementations. In 2005, OpenVZ for Linux was released by the company Virtuozzo, followed in 2007 by HP’s Secure Resource Partitions for HP-UX, which was later renamed HP-UX Containers.

Companies like Google, which had to deal with scaling applications for broad internet consumption and/or hosting untrusted user code, started pushing container technology in the early 2000s to facilitate reliably and securely distributing their applications across global data centers. A few companies maintained their own patched Linux kernels with container support for internal use, but as the need for these features became more evident within the Linux community, Google contributed some of its work supporting containers into the mainline Linux kernel, and in 2008, Linux Containers (LXC) were released in version 2.6.24 of the Linux kernel. The phenomenal growth of Linux Containers across the community did not truly start to grow until 2013, with the inclusion of user namespaces in version 3.8 of the Linux kernel and the release of Docker one month later.

Nowadays, containers are used almost everywhere. Docker and OCI images provide the packaging format for a significant and growing amount of software that is delivered into production environments, and provide the basis for many production systems, including, but not limited to, Kubernetes and most “serverless” cloud technologies.

**NOTE**

So-called serverless technologies are not actually serverless; they simply rely on other people’s servers to get work done so that the application owner does not have to worry about managing the hardware and operating system.

## Creating a Container

So far we’ve started containers using the handy `docker container run` command. But `docker container run` is really a convenience command that wraps two separate steps into one. The first thing it does is create a container from the underlying image. We can accomplish this separately using the `docker container create` command. The second thing `docker container run` does is execute the container, which we can also do separately with the `docker container start` command.

The `docker container create` and `docker container start` commands both contain all the options that pertain to how a container is initially set up. In [Chapter 4](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch04.html#docker\_images), we demonstrated that with the `docker container run` command you could map network ports in the underlying container to the host using the `-p/--publish` argument, and that `-e/--env` could be used to pass environment variables into the container.

This only just begins to touch on the array of things that you can configure when you first create a container. So let’s take a look at some of the options that `docker` supports.

### Basic Configuration

Let’s start by exploring some of the ways we can tell Docker to configure our container when we create it.

#### Container name

When you create a container, it is built from the underlying image, but various command-line arguments can affect the final settings. Settings specified in the _Dockerfile_ are always used as defaults, but you can override many of them at creation time.

By default, [Docker randomly names your container](https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go) by combining an adjective with the name of a famous person. This results in names like _ecstatic-babbage_ and _serene-albattani_. If you want to give your container a specific name, you can use the `--name` argument:

```
$ docker container create --name="awesome-service" ubuntu:latest sleep 120
```

After creating this container, you can then start it by using the `docker container start awesome-service`. It will automatically exit after 120 seconds, but you can stop it before then by running `docker container stop awesome-service`. We will dive a bit more into each of these commands a little later in the chapter.

**WARNING**

You can only have one container with any given name on a Docker host. If you run the preceding command twice in a row, you will get an error. You must either delete the previous container using `docker container rm` or change the name of the new container.

#### Labels

As mentioned in [Chapter 4](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch04.html#docker\_images), labels are key/value pairs that can be applied to Docker images and containers as metadata. When new Linux containers are created, they automatically inherit all the labels from their parent image.

It is also possible to add new labels to the containers so that you can apply metadata that might be specific to that single container:

```
$ docker container run --rm -d --name has-some-labels \
  -l deployer=Ahmed -l tester=Asako \
  ubuntu:latest sleep 1000
```

You can then search for and filter containers based on this metadata, using commands like `docker container ls`:

```
$ docker container ls -a -f label=deployer=Ahmed
CONTAINER ID  IMAGE         COMMAND       … NAMES
845731631ba4  ubuntu:latest "sleep 1000"  … has-some-labels
```

You can use the `docker container inspect` command to see all the labels that a container has:

```
$ docker container inspect has-some-labels
…
```

```
        "Labels": {
            "deployer": "Ahmed",
            "tester": "Asako"
        },
```

```
…
```

This container runs the command `sleep 1000`, so after 1,000 seconds it will stop running.

#### Hostname

By default, when you start a container, Docker copies certain system files on the host, including _/etc/hostname_, into the container’s configuration directory on the host,[2](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#idm46803148782320) and then uses a bind mount to link that copy of the file into the container. We can launch a default container with no special configuration, like this:

```
$ docker container run --rm -ti ubuntu:latest /bin/bash
```

This command uses the `docker container run` command, which runs `docker container create` and `docker container start` in the background. Since we want to be able to interact with the container that we are going to create for demonstration purposes, we pass in a few useful arguments. The `--rm` argument tells Docker to delete the container when it exits, the `-t` argument tells Docker to allocate a pseudo-TTY, and the `-i` argument tells Docker that this is going to be an interactive session and that we want to keep STDIN open. If there is no `ENTRYPOINT` defined in the image, then the final argument in the command is the executable and command-line arguments that we want to run within the container, which in this case is the ever-useful `/bin/bash`. If there is an `ENTRYPOINT` defined in the image, then the final argument is passed to the `ENTRYPOINT` process as a list of command-line arguments to that command.

**NOTE**

You might have noticed that the preceding paragraph talks about `-i` and `-t`, but the command is using the argument `-ti`. There is a lot of Unix history that explains why this is, but a [quick overview](https://nullprogram.com/blog/2020/08/01) can be found online if you are curious.

If we now run the `mount` command from within the resulting container, we’ll see something similar to this:

```
root@ebc8cf2d8523:/# mount
overlay on / type overlay (rw,relatime,lowerdir=…,upperdir=…,workdir…)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev type tmpfs (rw,nosuid,mode=755)
shm on /dev/shm type tmpfs (rw,nosuid,nodev,noexec,relatime,size=65536k)
mqueue on /dev/mqueue type mqueue (rw,nosuid,nodev,noexec,relatime)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,…,ptmxmode=666)
sysfs on /sys type sysfs (ro,nosuid,nodev,noexec,relatime)
/dev/sda9 on /etc/resolv.conf type ext4 (rw,relatime,data=ordered)
/dev/sda9 on /etc/hostname type ext4 (rw,relatime,data=ordered)
/dev/sda9 on /etc/hosts type ext4 (rw,relatime,data=ordered)
devpts on /dev/console type devpts (rw,nosuid,noexec,relatime,…,ptmxmode=000)
proc on /proc/sys type proc (ro,nosuid,nodev,noexec,relatime)
proc on /proc/sysrq-trigger type proc (ro,nosuid,nodev,noexec,relatime)
proc on /proc/irq type proc (ro,nosuid,nodev,noexec,relatime)
proc on /proc/bus type proc (ro,nosuid,nodev,noexec,relatime)
tmpfs on /proc/kcore type tmpfs (rw,nosuid,mode=755)
root@ebc8cf2d8523:/#
```

**NOTE**

When you see any examples with a prompt that looks something like _root@hashID_, it means that you are running a command within the container instead of on the local host.

There are occasions when a container will have been configured with a different hostname instead (e.g., using `--name` on the CLI), but in the default case, it’s the container ID hash.

It is also possible to change the user that is used inside the container with `--user`, but by default, it will be _root_.

There are quite a few bind mounts in a container, but in this case, we are interested in this one:

```
/dev/sda9 on /etc/hostname type ext4 (rw,relatime,data=ordered)
```

While the device number will be different for each container, the part we care about is that the mount point is _/etc/hostname_. This links the container’s _/etc/hostname_ to the hostname file that Docker has prepared for the container, which by default contains the container’s ID and is not fully qualified with a domain name.

We can check this in the container by running the following:

```
root@ebc8cf2d8523:/# hostname -f
ebc8cf2d8523
root@ebc8cf2d8523:/# exit
```

**NOTE**

Don’t forget to `exit` the container shell to return to the local host when finished.

To set the hostname specifically, we can use the `--hostname` argument to pass in a more specific value:

```
$ docker container run --rm -ti --hostname="mycontainer.example.com" \
    ubuntu:latest /bin/bash
```

Then, from within the container, we’ll see that the fully qualified hostname is defined as requested:

```
root@mycontainer:/# hostname -f
mycontainer.example.com
root@mycontainer:/# exit
```

#### Domain Name Service

Just like _/etc/hostname_, the _resolv.conf_ file that configures Domain Name Service (DNS) resolution is managed via a bind mount between the host and container:

```
/dev/sda9 on /etc/resolv.conf type ext4 (rw,relatime,data=ordered)
```

**NOTE**

Details about the _resolve.conf_ file can be found [online](https://sslhow.com/understanding-etc-resolv-conf-file-in-linux).

By default, this is an exact copy of the Docker host’s _resolv.conf_ file. If you didn’t want this, you could use a combination of the `--dns` and `--dns-search` arguments to override this behavior in the container:

```
$ docker container run --rm -ti --dns=8.8.8.8 --dns=8.8.4.4 \
    --dns-search=example1.com --dns-search=example2.com \
    ubuntu:latest /bin/bash
```

**NOTE**

If you want to leave the search domain completely unset, then use `--dns-search=.`

Within the container, you would still see a bind mount, but the file contents would no longer reflect the host’s _resolv.conf_; instead, it would now look like this:

```
root@0f887071000a:/# more /etc/resolv.conf
nameserver 8.8.8.8
nameserver 8.8.4.4
search example1.com example2.com
root@0f887071000a:/# exit
```

#### MAC address

Another important piece of information that you can configure is the media access control (MAC) address for the container.

Without any configuration, a container will receive a calculated MAC address that starts with the _02:42:ac:11_ prefix.

If you need to specifically set this to a value, you can do so by running something similar to this:

```
$ docker container run --rm -ti --mac-address="a2:11:aa:22:bb:33" \
  ubuntu:latest /bin/bash
```

Normally, you will not need to do that. But sometimes you want to reserve a particular set of MAC addresses for your containers to avoid conflicting with other virtualization layers that use the same private block as Docker.

**WARNING**

Be very careful when customizing the MAC address settings. It is possible to cause ARP contention on your network if two systems advertise the same MAC address. If you have a strong need to do this, try to keep your locally administered address ranges within some of the official ranges, like _x2-xx-xx-xx-xx-xx_, _x6-xx-xx-xx-xx-xx_, _xA-xx-xx-xx-xx-xx_, and _xE-xx-xx-xx-xx-xx_ (with _x_ being any valid hexadecimal character).

### Storage Volumes

There are times when the default disk space allocated to a container, or the container’s ephemeral nature, is not appropriate for the job at hand, so you’ll need storage that can persist between container deployments.

**WARNING**

Mounting storage from the Docker host is not generally advisable because it ties your container to a particular Docker host for its persistent state. But for cases like temporary cache files or other semi-ephemeral states, it can make sense.

For times like this, you can leverage the `--mount/-v` command to mount directories and individual files from the host server into the container. It is important that you use fully qualified paths in the `--mount/-v` argument. The following example mounts _/mnt/session\_data_ to _/data_ within the container:

```
$ docker container run --rm -ti \
  --mount type=bind,target=/mnt/session_data,source=/data \
  ubuntu:latest /bin/bash

root@0f887071000a:/# mount | grep data
/dev/sda9 on /data type ext4 (rw,relatime,data=ordered)
root@0f887071000a:/# exit
```

**TIP**

For bind mounts specifically, you can use the `-v` argument to shorten the command. When using the `-v` argument, you will notice here that the source and target files/directories are separated by a colon(:).

It is also important to note that volumes are mounted read-write by default. You can easily make `docker` mount the file or directory read-only by adding `,readonly` to end the of the `--mount` arguments, or by adding `:ro` to the end of the `-v` arguments.

```
$ docker container run --rm -ti \
  -v /mnt/session_data:/data:ro \
  ubuntu:latest /bin/bash
```

Neither the host mount point nor the mount point in the container needs to preexist for this command to work properly. If the host mount point does not exist already, then it will be created as a directory. This could cause you some issues if you were trying to point to a file instead of a directory.

In the mount options, you can see that the filesystem was mounted read-write on _/data_ as expected.

## SELINUX AND VOLUME MOUNTS

If you have SELinux enabled on your Docker host, you may get a “Permission Denied” error when trying to mount a volume into your container. You can handle this by using one of the `z` options to the Docker command for mounting volumes:

* The lowercase `z` option indicates that the bind-mount content is shared among multiple containers.
* The uppercase `Z` option indicates that the bind-mount content is private and unshared.

If you are going to share a volume between containers, you can use the `z` option to the volume mount:

```
$ docker container run --rm -v /app/dhcpd/etc:/etc/dhcpd:z dhcpd
```

However, the best option is actually the `Z` option to the volume mount command, which will set the directory with the exact MCS label (e.g., `chcon … -l s0:c1,c2`) that the container will be using. This provides for the best security and will allow only a single container to mount the volume:

```
$ docker container run --rm -v /app/dhcpd/etc:/etc/dhcpd:Z dhcpd
```

**WARNING**

Use extreme caution with the `z` options. Bind-mounting a system directory such as _/etc_ or _/var_ with the `Z` option will very likely render your system inoperable and require you to use SELinux tools to [relabel the host machine manually](https://www.thegeekdiary.com/understanding-selinux-file-labelling-and-selinux-context).

If the container application is designed to write into _/data_, then this data will be visible on the host filesystem in _/mnt/session\_data_ and will remain available when this container stops and a new container starts with the same volume mounted.

It is possible to tell Docker that the root volume of your container should be mounted read-only so that processes within the container cannot write anything to the root filesystem. This prevents things like logfiles, which a developer may be unaware of, from filling up the container’s allocated disk in production. When it’s used in conjunction with a mounted volume, you can ensure that data is written only into expected locations.

In the previous example, we could accomplish this simply by adding `--read-only=true` to the command:

```
$ docker container run --rm -ti --read-only=true -v /mnt/session_data:/data \
    ubuntu:latest /bin/bash

root@df542767bc17:/# mount | grep " / "
overlay on / type overlay (ro,relatime,lowerdir=…,upperdir=…,workdir=…)
root@df542767bc17:/# mount | grep data
/dev/sda9 on /data type ext4 (rw,relatime,data=ordered)
root@df542767bc17:/# exit
```

If you look closely at the mount options for the root directory, you’ll notice that they are mounted with the `ro` option, which makes it read-only. However, the _/session\_data_ mount is still mounted with the `rw` option so that our application can successfully write to the one volume to which it’s designed to write.

Sometimes it is necessary to make a directory like _/tmp_ writable, even when the rest of the container is read-only. For this use case, you can use the `--mount type=tmpfs` argument with `docker container run` so that you can mount a _tmpfs_ filesystem into the container. The _tmpfs_ filesystems are completely in-memory. They will be very fast, but they are also ephemeral and will utilize additional system memory. Any data in these _tmpfs_ directories will be lost when the container is stopped. The following example shows a container being launched with a 256 MB _tmpfs_ filesystem mounted at _/tmp_:

```
$ docker container run --rm -ti --read-only=true \
  --mount type=tmpfs,destination=/tmp,tmpfs-size=256M \
  ubuntu:latest /bin/bash

root@25b4f3632bbc:/# df -h /tmp
Filesystem      Size  Used Avail Use% Mounted on
tmpfs           256M     0  256M   0% /tmp
root@25b4f3632bbc:/# grep /tmp /etc/mtab
tmpfs /tmp tmpfs rw,nosuid,nodev,noexec,relatime,size=262144k 0 0
root@25b4f3632bbc:/# exit
```

**WARNING**

Containers should be designed to be stateless whenever possible. Managing storage creates undesirable dependencies and can easily make deployment scenarios much more complicated.

### Resource Quotas

When people discuss the types of problems they must often cope with when working in the cloud, the “noisy neighbor” is often near the top of the list. The basic problem this term refers to is that other applications running on the same physical system as yours can have a noticeable impact on your performance and resource availability.

VMs have the advantage that you can easily and very tightly control how much memory and CPU, among other resources, are allocated to the VM. When using Docker, you must instead leverage the cgroup functionality in the Linux kernel to control the resources that are available to a Linux container. The `docker container create` and `docker container run` commands directly support configuring CPU, memory, swap, and storage I/O restrictions when you create a container.

**NOTE**

Constraints are normally applied at the time of container creation. If you need to change them, you can use the `docker container update` command or deploy a new container with the adjustments.

There is an important caveat here. While Docker supports various resource limits, you must have these capabilities enabled in your kernel for Docker to take advantage of them. You might need to add these as command-line parameters to your kernel on startup. To figure out if your kernel supports these limits, run `docker system info`. If you are missing any support, you will get warning messages at the bottom, like this:

```
WARNING: No swap limit support
```

**NOTE**

The details regarding getting cgroup support configured for your kernel are distribution specific, so you should consult the [Docker documentation](https://oreil.ly/Z70ZO)[3](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#idm46803147988272) if you need help configuring things.

#### CPU shares

Docker has several ways to limit CPU usage by applications in containers. The original method, still commonly used, is the concept of _CPU shares_. We’ll present other options as well.

The computing power of all the CPU cores in a system is considered to be the full pool of shares. Docker assigns the number 1,024 to represent the full pool. By configuring a container’s CPU shares, you can dictate how much time the container gets to use the CPU. If you want the container to be able to use at most half of the computing power of the system, then you would allocate it 512 shares. These are not exclusive shares, meaning that assigning all 1,024 shares to a container does not prevent all other containers from running. Rather, it’s a hint to the scheduler about how long each container should be able to run each time it’s scheduled. If we have one container that is allocated 1,024 shares (the default) and two that are allocated 512, they will all get scheduled the same number of times. But if the normal amount of CPU time for each process is 100 microseconds, the containers with 512 shares will run for 50 microseconds each time, whereas the container with 1,024 shares will run for 100 microseconds.

Let’s explore a little bit how this works in practice. For the following examples, we’ll use a new Docker image that contains the [`stress` command](https://linux.die.net/man/1/stress) for pushing a system to its limits.

When we run `stress` without any cgroup constraints, it will use as many resources as we tell it to. The following command creates a load average of around five by creating two CPU-bound processes, one I/O-bound process, and two memory allocation processes. For all of the following examples, we are running on a system with two CPUs.

Note that in the following command, everything following the container image name is related to the `stress` command, not the `docker` command:

```
$ docker container run --rm -ti spkane/train-os \
  stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M --timeout 120s
```

**WARNING**

This should be a reasonable command to run on any modern computer system, but be aware that it is going to stress the host system. So don’t do this in a location that can’t take the additional load, or even a possible failure, due to resource starvation.

If you run the `top` or `htop` command on the Docker host, near the end of the two-minute run, you can see how the system is affected by the load created by the `stress` program:

```
$ top -bn1 | head -n 15
top - 20:56:36 up 3 min,  2 users,  load average: 5.03, 2.02, 0.75
Tasks:  88 total,   5 running,  83 sleeping,   0 stopped,   0 zombie
%Cpu(s): 29.8 us, 35.2 sy, 0.0 ni, 32.0 id, 0.8 wa, 1.6 hi, 0.6 si, 0.0 st
KiB Mem:   1021856 total,   270148 used,   751708 free,    42716 buffers
KiB Swap:        0 total,        0 used,        0 free.    83764 cached Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
  810 root      20   0    7316     96      0 R  44.3  0.0   0:49.63 stress
  813 root      20   0    7316     96      0 R  44.3  0.0   0:49.18 stress
  812 root      20   0  138392  46936    996 R  31.7  4.6   0:46.42 stress
  814 root      20   0  138392  22360    996 R  31.7  2.2   0:46.89 stress
  811 root      20   0    7316     96      0 D  25.3  0.0   0:21.34 stress
    1 root      20   0  110024   4916   3632 S   0.0  0.5   0:07.32 systemd
    2 root      20   0       0      0      0 S   0.0  0.0   0:00.04 kthreadd
    3 root      20   0       0      0      0 S   0.0  0.0   0:00.11 ksoftir…
```

**NOTE**

Docker Desktop users on non-Linux systems may discover that Docker has made the VM filesystem read-only, and it does not contain many useful tools for monitoring the VM. For these demos where you want to be able to monitor the resource usage of various processes, you can work around this by doing something like this:

```
$ docker container run --rm -it --pid=host alpine sh
/ # apk update
/ # apk add htop
/ # htop -p $(pgrep stress | tr '\n' ',')
/ # exit
```

Be aware that the preceding `htop` command will give you an error unless `stress` is actively running when you launch `htop`, since no processes will be returned by the `pgrep` command.

You will also want to exit and rerun `htop` each time you run a new `stress` instance.

If you want to run the same `stress` command again, with only half the amount of available CPU time, you can do so like this:

```
$ docker container run --rm -ti --cpu-shares 512 spkane/train-os \
  stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M --timeout 120s
```

The `--cpu-shares 512` is the flag that does the magic, allocating 512 CPU shares to this container. The effect of this argument might not be noticeable on a system that is not very busy. That’s because the container will continue to be scheduled for the same time-slice length whenever it has work to do unless the system is constrained for resources. So in our case, the results of a `top` command on the host system will likely look the same, unless you run a few more containers to give the CPU something else to do.

**WARNING**

Unlike VMs, Docker’s cgroup-based constraints on CPU shares can have unexpected consequences. They are not hard limits; they are relative limits, similar to the `nice` command. An example is a container that is constrained to half the CPU shares but is on a system that is not very busy. Since the CPU is not busy, the limit on the CPU shares would have only a limited effect because there is no competition in the scheduler pool. When a second container that uses a lot of CPU is deployed to the same system, suddenly the effect of the constraint on the first container will be noticeable. Consider this carefully when constraining containers and allocating resources.

#### CPU pinning

It is also possible to pin a container to one or more CPU cores. This means that work for this container will be scheduled only on the cores that have been assigned to this container. That is useful if you want to hard-shard CPUs between applications or if you have applications that need to be pinned to a particular CPU for things like cache efficiency.

In the following example, we are running a stress container pinned to the first of two CPUs, with 512 CPU shares:

```
$ docker container run --rm -ti \
  --cpu-shares 512 --cpuset-cpus=0 spkane/train-os \
  stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M --timeout 120s
```

**WARNING**

The `--cpuset-cpus` argument is zero-indexed, so your first CPU core is 0. If you tell Docker to use a CPU core that does not exist on the host system, you will get a `Cannot start container` error. On a two-CPU example host, you could test this by using `--cpuset-cpus=0-2`.

If you run `top` again, you should notice that the percentage of CPU time spent in user space (`us`) is lower than it previously was, since we have restricted two CPU-bound processes to a single CPU:

```
%Cpu(s): 18.5 us, 22.0 sy, 0.0 ni, 57.6 id, 0.5 wa, 1.0 hi, 0.3 si, 0.0 st
```

**NOTE**

When you use CPU pinning, additional CPU sharing restrictions on the container only take into account other containers running on the same set of cores.

Using the CPU Completely Fair Scheduler (CFS) within the Linux kernel, you can alter the CPU quota for a given container by setting the `--cpu-quota` flag to a valid value when launching the container with `docker container run`.

#### Simplifying CPU quotas

While CPU shares were the original mechanism in Docker for managing CPU limits, Docker has evolved a great deal since, and one of the ways that it now makes users’ lives easier is by greatly simplifying how CPU quotas can be set. Instead of trying to set correct CPU shares and quotas yourself, you can now simply tell Docker how much CPU you would like to be available to your container, and it will do the math required to set the underlying cgroups correctly.

The `--cpus` command can be set to a floating-point number between 0.01 and the number of CPU cores on the Docker server:

```
$ docker container run --rm -ti --cpus=".25" spkane/train-os \
  stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M --timeout 60s
```

If you try to set the value too high, you’ll get an error message from Docker (not the `stress` application) that will give you the correct range of CPU cores that you have to work with:

```
$ docker container run --rm -ti --cpus="40.25" spkane/train-os \
  stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M --timeout 60s
docker: Error response from daemon: Range of CPUs is from
    0.01 to 4.00, as there are only 4 CPUs available.
See 'docker container run --help'.
```

The `docker container update` command can be used to dynamically adjust the resource limits of one or more containers. You could adjust the CPU allocation on two containers simultaneously, for example, like so:

```
$ docker container update --cpus="1.5" 092c5dc85044 92b797f12af1
```

**TIP**

Docker sees CPUs the same way that Linux sees them. Hyper-threading and cores are interpreted by Linux and exposed via the special file _/proc/cpuinfo_. When you use the `--cpus` command in Docker, you are referring to how many of the entries in this file you want the container to have access to, whether they refer to a standard core or a hyper-threaded core.

#### Memory

We can control how much memory a container can access in a manner similar to constraining the CPU. There is, however, one fundamental difference: while constraining the CPU only impacts the application’s priority for CPU time, the memory limit is a _hard_ limit. Even on an unconstrained system with 96 GB of free memory, if we tell a container that it may have access only to 24 GB, then it will only ever get to use 24 GB regardless of the free memory on the system. Because of the way the virtual memory system works on Linux, it’s possible to allocate more memory to a container than the system has actual RAM. In this case, the container will resort to using swap, just like a normal Linux process.

Let’s start a container with a memory constraint by passing the `--memory` option to the `docker container run` command:

```
$ docker container run --rm -ti --memory 512m spkane/train-os \
  stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M --timeout 10s
```

When you use the `--memory` option alone, you are setting both the amount of RAM and the amount of swap that the container will have access to. So by using `--memory 512m` here, we’ve constrained the container to 512 MB of RAM and 512 MB of additional swap space. Docker supports `b`, `k`, `m`, or `g`, representing bytes, kilobytes, megabytes, or gigabytes, respectively. If your system somehow runs Linux and Docker and has multiple terabytes of memory, then unfortunately you’re going to have to specify it in gigabytes.

If you would like to set the swap separately or disable it altogether, you need to also use the `--memory-swap` option. This defines the total amount of memory and swap available to the container. If we rerun our previous command, like so:

```
$ docker container run --rm -ti --memory 512m --memory-swap=768m \
    spkane/train-os stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M \
    --timeout 10s
```

then we’re telling the kernel that this container can have access to 512 MB of memory and 256 MB of additional swap space. Setting the `--memory-swap` option to `-1` will allow the container to use as much swap as is available on the underlying system and if `--memory-swap` and `--memory` are set to the same positive value, then the container will not have any access to swap.

**WARNING**

Again, unlike CPU shares, memory is a hard limit! This is good because the constraint doesn’t suddenly have a noticeable effect on the container when another container is deployed to the system. But it means you need to be careful that the limit closely matches your container’s needs because there is no wiggle room. An out-of-memory container causes the kernel to behave just like it would if the system were out of memory. It will try to find a process to kill so that it can free up space. This is a common failure case where containers have their memory limits set too low. The telltale sign of this issue is a container exit code of 137 and kernel out-of-memory (OOM) messages in the Docker server’s `dmesg` output.

So, what happens if a container reaches its memory limit? Well, let’s give it a try by modifying one of our previous commands and lowering the memory significantly:

```
$ docker container run --rm -ti --memory 100m spkane/train-os \
  stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M --timeout 10s
```

While all of our other runs of the `stress` container ended with a line like this:

```
stress: info: [17] successful run completed in 10s
```

we see that this run quickly fails with a line similar to this:

```
stress: FAIL: [1] (451) failed run completed in 0s
```

This is because the container tries to allocate more memory than it is allowed, and the Linux OOM killer is invoked and starts killing processes within the cgroup to reclaim memory. In this case, our container has a single-parent process that has spawned a few children processes, and when the OOM killer kills one of the children processes, the parent process cleans everything up and exits with an error.

**WARNING**

Docker has features that allow you to tune and disable the Linux OOM killer by using the `--oom-kill-disable` and the `--oom-score-adj` arguments to `docker container run`, but they are not recommended for almost any use cases.

If you access your Docker server, you can see the kernel message related to this event by running `dmesg`. The output will look something like this:

```
[ 4210.403984] stress invoked oom-killer: gfp_mask=0x24000c0 …
[ 4210.404899] stress cpuset=5bfa65084931efabda59d9a70fa8e88 …
[ 4210.405951] CPU: 3 PID: 3429 Comm: stress Not tainted 4.9 …
[ 4210.406624] Hardware name:   BHYVE, BIOS 1.00 03/14/2014
…
[ 4210.408978] Call Trace:
[ 4210.409182]  [<ffffffff94438115>] ? dump_stack+0x5a/0x6f
….
[ 4210.414139]  [<ffffffff947f9cf8>] ? page_fault+0x28/0x30
[ 4210.414619] Task in /docker-ce/docker/5…3
killed as a result of limit of /docker-ce/docker/5…3
[ 4210.416640] memory: usage 102380kB, limit 102400kB, failc …
[ 4210.417236] memory+swap: usage 204800kB, limit 204800kB,  …
[ 4210.417855] kmem: usage 1180kB, limit 9007199254740988kB, …
[ 4210.418485] Memory cgroup stats for /docker-ce/docker/5…3:
cache:0KB rss:101200KB rss_huge:0KB mapped_file:0KB dirty:0KB
writeback:11472KB swap:102420KB inactive_anon:50728KB
active_anon:50472KB inactive_file:0KB active_file:0KB unevictable:0KB
…
[ 4210.426783] Memory cgroup out of memory: Kill process 3429…
[ 4210.427544] Killed process 3429 (stress) total-vm:138388kB,
anon-rss:44028kB, file-rss:900kB, shmem-rss:0kB
[ 4210.442492] oom_reaper: reaped process 3429 (stress), now
anon-rss:0kB, file-rss:0kB, shmem-rss:0kB
```

This OOM event will also be recorded by Docker and viewable via `docker system events`:

```
$ docker system events
2018-01-28T15:56:19.972142371-08:00 container oom \
    d0d803ce32c4e86d0aa6453512a9084a156e96860e916ffc2856fc63ad9cf88b \
    (image=spkane/train-os, name=loving_franklin)
```

#### Block I/O

Many containers are just stateless applications and won’t need block I/O restrictions. But Docker also supports limiting block I/O in a few different ways via the cgroups mechanism.

The first way is applying some prioritization to a container’s use of block device I/O. You enable this by manipulating the default setting of the `blkio.weight` cgroup attribute. This attribute can have a value of 0 (disabled) or a number between 10 and 1,000, the default being 500. This limit acts a bit like CPU shares, in that the system will divide all of the available I/O between every process within a cgroup slice by 1,000, with the assigned weights impacting how much available I/O is available to each process.

To set this weight on a container, you need to pass the `--blkio-weight` to your `docker container run` command with a valid value. You can also target a specific device using the `--blkio-weight-device` option.

As with CPU shares, tuning the weights is hard to get right in practice, but we can make it vastly simpler by limiting the maximum number of bytes or operations per second that are available to a container via its cgroup. The following settings let us control that:

```
--device-read-bps     Limit read rate (bytes per second) from a device
--device-read-iops    Limit read rate (IO per second) from a device
--device-write-bps    Limit write rate (bytes per second) to a device
--device-write-iops   Limit write rate (IO per second) to a device
```

You can test how these impact the performance of a container by running some of the following commands, which use the Linux I/O tester [`bonnie`](https://www.coker.com.au/bonnie):

```
$ time docker container run --rm -ti spkane/train-os:latest bonnie++ \
    -u 500:500 -d /tmp -r 1024 -s 2048 -x 1
…
real  0m27.715s
user  0m0.027s
sys   0m0.030s

$ time docker container run -ti --rm --device-write-iops /dev/vda:256 \
    spkane/train-os:latest bonnie++ -u 500:500 -d /tmp -r 1024 -s 2048 -x 1
…
real  0m58.765s
user  0m0.028s
sys   0m0.029s

$ time docker container run -ti --rm --device-write-bps /dev/vda:5mb \
    spkane/train-os:latest bonnie++ -u 500:500 -d /tmp -r 1024 -s 2048 -x 1
…
```

**TIP**

PowerShell users should be able to use the [`Measure-Command`](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/measure-command?view=powershell-7.3) function to replace the Unix `time` command used in these examples.

In our experience, the `--device-read-iops` and `--device-write-iops` arguments are the most effective way to set block I/O limits and are the ones we recommend.

#### ulimits

Before Linux cgroups, there was another way to place a limit on the resources available to a process: the application of user limits via the `ulimit` command. That mechanism is still available and still useful for all of the [use cases](https://www.linuxhowtos.org/Tips%20and%20Tricks/ulimit.htm) where it was traditionally used.

The following code is a list of the types of system resources that you can usually constrain by setting soft and hard limits via the `ulimit` command:

```
$ ulimit -a
core file size (blocks, -c) 0
data seg size (kbytes, -d) unlimited
scheduling priority (-e) 0
file size (blocks, -f) unlimited
pending signals (-i) 5835
max locked memory (kbytes, -l) 64
max memory size (kbytes, -m) unlimited
open files (-n) 1024
pipe size (512 bytes, -p) 8
POSIX message queues (bytes, -q) 819200
real-time priority (-r) 0
stack size (kbytes, -s) 10240
cpu time (seconds, -t) unlimited
max user processes (-u) 1024
virtual memory (kbytes, -v) unlimited
file locks (-x) unlimited
```

It is possible to configure the Docker daemon with the default user limits that you want to apply to every container. The following command tells the Docker daemon to start all containers with a soft limit of 50 open files and a hard limit of 150 open files:

```
$ sudo dockerd --default-ulimit nofile=50:150
```

You can then override these ulimits on a specific container by passing in values using the `--ulimit` argument:

```
$ docker container run --rm -d --ulimit nofile=150:300 nginx
```

There are some additional advanced commands that you can use when creating containers, but this covers many of the more common use cases. The [Docker client documentation](https://dockr.ly/2ME0ygi) lists all the available options and is updated with each Docker release.

## Starting a Container

Before we got into the details of containers and constraints, we created our container using the `docker container create` command. That container is just sitting there without doing anything. There is a configuration but no running process. When we’re ready to start the container, we can do so using the `docker container start` command.

Let’s say that we needed to run a copy of Redis, a common key/value store. We won’t do anything with this Redis container, but it’s a lightweight, long-lived process and serves as an example of something we might do in a real environment. We could first create the container:

```
$ docker container create -p 6379:6379 redis:2.8
Unable to find image 'redis:7.0' locally
7.0: Pulling from library/redis
3f4ca61aafcd: Pull complete
…
20bf15ad3c24: Pull complete
Digest: sha256:8184cfe57f205ab34c62bd0e9552dffeb885d2a7f82ce4295c0df344cb6f0007
Status: Downloaded newer image for redis:7.0
092c5dc850446324e4387485df7b76258fdf9ed0aedcd53a37299d35fc67a042
```

The result of the command is some output, the last line of which is the full hash that was generated for the container. We could use that long hash to start it, but if we failed to note it down, we could also list all the containers on the system, whether they are running or not, using the following:

```
$ docker container ls -a --filter ancestor=redis:2.8
CONTAINER ID IMAGE     COMMAND                CREATED        … NAMES
092c5dc85044 redis:7.0 "docker-entrypoint.s…" 46 seconds ago elegant_wright
```

We can confirm the identity of our container by filtering the output by the image that we used and examining the container’s creation time. We can then start the container with the following command:

```
$ docker container start 092c5dc85044
```

**NOTE**

Most Docker commands will work with the container name, the full hash, the short hash, or even just enough of the hash to make it unique. In the previous example, the full hash for the container is `092c5dc850446324e…a37299d35fc67a042`, but the short hash that is shown in most command output is `092c5dc85044`. This short hash consists of the first 12 characters of the full hash. In the previous example, running `docker container start 6b7` would have worked just fine.

That _should_ have started the container, but with it running in the background we won’t necessarily know if something went wrong. To verify that it’s running, we can run the following:

```
$ docker container ls
CONTAINER ID  IMAGE      COMMAND                …  STATUS       …
092c5dc85044  redis:7.0  "docker-entrypoint.s…" …  Up 2 minutes …
```

And, there it is: running as expected. We can tell because the status says `Up` and shows how long the container has been running.

## Auto-Restarting a Container

In many cases, we want our containers to restart if they exit. Some containers are very short-lived and come and go quickly. But for production applications, for instance, you expect them to be up and running at all times after you’ve told them to run. If you are running a more complex system, a scheduler may do this for you.

In the simple case, we can tell Docker to manage restarts on our behalf by passing the `--restart` argument to the `docker container run` command. It takes four values: `no`, `always`, `on-failure`, or `unless-stopped`. If `restart` is set to `no`, the container will never restart if it exits. If it is set to `always`, the container will restart whenever it exits, with no regard to the exit code. If `restart` is set to `on-failure`, whenever the container exits with a nonzero exit code, Docker will try to restart the container. If we set `restart` to `on-failure:3`, Docker will try and restart the container three times before giving up. `unless-stopped` is the most common choice and will restart the container unless it is intentionally stopped with something like `docker container stop`.

We can see this in action by rerunning our last memory-constrained stress container without the `--rm` argument but with the `--restart` argument:

```
$ docker container run -ti --restart=on-failure:3 --memory 100m \
  spkane/train-os stress -v --cpu 2 --io 1 --vm 2 --vm-bytes 128M \
  --timeout 120s
```

In this example, we’ll see the output from the first run appear on the console before it dies. If we run a `docker container ls` immediately after the container dies, we’ll likely see that Docker has restarted the container:

```
$ docker container ls
…  IMAGE           …  STATUS                …
…  spkane/train-os …  Up Less than a second …
```

It will continue to fail because we haven’t given it enough memory to function properly. After three attempts, Docker will give up, and we’ll see the container disappear from the output of `docker container ls`.

## Stopping a Container

Containers can be stopped and started at will. You might think that starting and stopping a container is analogous to pausing and resuming a normal process, but it’s not quite the same in reality. When stopped, the process is not paused; it exits. And when a container is stopped, it no longer shows up in the normal `docker container ls` output. On reboot, Docker will attempt to start all of the containers that were running at shutdown. If you need to prevent a container from doing any additional work, without actually stopping the process, then you can pause the Linux container with `docker container pause` and `unpause`, which will be discussed in more detail later. For now, go ahead and stop the Redis container that we started a little earlier:

```
$ docker container stop 092c5dc85044
$ docker container ls
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
```

Now that we have stopped the container, nothing is in the running container list! We can start it back up with the container ID, but it would be inconvenient to have to remember that. So `docker container ls` has an additional option `(-a)` to show all containers, not just the running ones:

```
$ docker container ls -a
CONTAINER ID  IMAGE     STATUS                   …
092c5dc85044  redis:7.0 Exited (0) 2 minutes ago …
…
```

That `STATUS` field now shows that our container exited with a status code of 0 (no errors). We can start it back up with the same configuration it had before:

```
$ docker container start 092c5dc85044
092c5dc85044

$ docker container ls -a
CONTAINER ID  IMAGE     STATUS        …
092c5dc85044  redis:7.0 Up 14 seconds …
…
```

Voilà, our container is back up and running and configured just as it was before.

**NOTE**

Remember that containers exist as a blob of configuration in the Docker system even when they are not started. This means that as long as the container has not been deleted, you can restart it without needing to re-create it. Although memory and temporary file system (tmpfs) contents will have been lost, all of the container’s other filesystem contents and metadata, including environment variables and port bindings, are saved and will still be in place when you restart the container.

By now we’ve probably thumped on enough about the idea that containers are just a tree of processes that interact with the system in essentially the same way as any other process on the server. But it’s important to point it out here again because it means that we can send Unix signals to our process in the containers that they can then respond to. In the previous `docker container stop` example, we’re sending the container a `SIGTERM` signal and waiting for the container to exit gracefully. Containers follow the same process group signal propagation that any other process group would receive on Linux.

A normal `docker container stop` sends a `SIGTERM` to the process. If you want to force a container to be killed if it hasn’t stopped after a certain amount of time, you can use the `-t` argument, like this:

```
$ docker container stop -t 25 092c5dc85044
```

This tells Docker to initially send a `SIGTERM` signal as before, but if the container has not stopped within 25 seconds (the default is 10), it tells Docker to send a `SIGKILL` signal to forcefully kill it.

Although `stop` is the best way to shut down your containers, there are times when it doesn’t work and you’ll need to forcefully kill a container, just as you might have to do with any process outside of a container.

## Killing a Container

When a process is misbehaving, `docker container stop` might not cut it. You might just want the container to exit immediately.

In these circumstances, you can use `docker container kill`. As you’d expect, it looks a lot like `docker container stop`:

```
$ docker container start 092c5dc85044
092c5dc85044

$ docker container kill 092c5dc85044
092c5dc85044
```

A `docker container ls` command now shows that the container is no longer running, as expected:

```
$ docker container ls
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
```

Just because it was killed rather than stopped does not mean you can’t start it again, though. You can just issue a `docker container start` like you would for a nicely stopped container. Sometimes you might want to send another signal to a container, one that is not `stop` or `kill`. Like the Linux `kill` command, `docker container kill` supports sending any Unix signal. Let’s say we wanted to send a `USR1` signal to our container to tell it to do something like reconnect a remote logging session. We could do the following:

```
$ docker container start 092c5dc85044
092c5dc85044

$ docker container kill --signal=USR1 092c5dc85044
092c5dc85044
```

If our container process was designed to do something with the `USR1` signal, it would now do it. Any standard Unix signal can be sent to a container using this method.

## Pausing and Unpausing a Container

There are a few reasons why we might not want to completely stop our container. We might want to pause it, leave its resources allocated, and leave its entries in the process table. That could be because we’re taking a snapshot of its filesystem to create a new image or just because we need some CPU on the host for a while. If you are used to normal Unix process handling, you might wonder how this works since containerized processes are just processes.

Pausing leverages the [cgroup freezer](https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.txt), which essentially just prevents your process from being scheduled until you unfreeze it. This will prevent the container from doing anything while maintaining its overall state, including memory contents. Unlike stopping a container, where the processes are made aware that they are stopping via the `SIGSTOP` signal, pausing a container doesn’t send any information to the container about its state change. That’s an important distinction. Several Docker commands use pausing and unpausing internally as well. Here is how we pause a container:

```
$ docker container start 092c5dc85044
092c5dc85044

$ docker container pause 092c5dc85044
092c5dc85044
```

**NOTE**

To pause and unpause containers in Windows, you must be using Hyper-V or WSL2 as the underlying virtualization technology.

If we look at the list of running containers, we will now see that the Redis container status is listed as `(Paused)`:

```
$ docker container ls
CONTAINER ID  IMAGE     … STATUS                  …
092c5dc85044  redis:7.0 … Up 25 seconds (Paused)  …
```

Attempting to use the container in this paused state would fail. It’s present, but nothing is running. We can now resume the container by using the `docker container unpause` command:

```
$ docker container unpause 092c5dc85044
092c5dc85044

$ docker container ls
CONTAINER ID  IMAGE     … STATUS        …
092c5dc85044  redis:7.0 … Up 55 seconds …
```

It’s back to running, and `docker container ls` correctly reflects the new state. It shows `Up 55 seconds` now because Docker still considers the container to be running even when it is paused.

## Cleaning Up Containers and Images

After running all these commands to build images, create containers, and run them, we have accumulated a lot of image layers and container folders on our system.

We can list all the containers on our system using the `docker container ls -a` command and then delete any of the containers in the list. We must stop all containers that are using an image before removing the image itself. Assuming we’ve done that, we can remove it as follows, using the `docker container rm` command:

```
$ docker container stop 092c5dc85044
092c5dc85044ls

$ docker container rm 092c5dc85044
092c5dc85044
```

**NOTE**

It is possible to remove a running container if you use the `-f` or `--force` flag with `docker container rm`.

We can then list all the images on our system using the following:

```
$ docker image ls
REPOSITORY       TAG     IMAGE ID      CREATED       SIZE
ubuntu           latest  5ba9dab47459  3 weeks ago   188.3MB
redis            7.0     0256c63af7db  2 weeks ago   117MB
spkane/train-os  latest  78fb082a4d65  4 months ago  254MB
```

We can then delete an image and all associated filesystem layers by running the following:

```
$ docker image rm 0256c63af7db
```

**WARNING**

If you try to delete an image that is in use by a container, you will get a `Conflict, cannot delete` error. You should stop and delete the container(s) first.

There are times, especially during development cycles when it makes sense to completely purge all the images or containers from your system. The easiest way to do this is by running the `docker system prune` command:

```
$ docker system prune
WARNING! This will remove:
        - all stopped containers
        - all networks not used by at least one container
        - all dangling images
        - all build cache
Are you sure you want to continue? [y/N] y
Deleted Containers:
cbbc42acfe6cc7c2d5e6c3361003e077478c58bb062dd57a230d31bcd01f6190
…
Deleted Images:
deleted: sha256:bec6ec29e16a409af1c556bf9e6b2ec584c7fb5ffbfd7c46ec00b30bf …
untagged: spkane/squid@sha256:64fbc44666405fd1a02f0ec731e35881465fac395e7 …
…
Total reclaimed space: 1.385GB
```

**TIP**

To remove all unused images, instead of only dangling images, try `docker system prune -a`.

It is also possible to craft more specific commands to accomplish similar goals.

To delete all of the containers on your Docker hosts, use the following command:

```
$ docker container rm $(docker container ls -a -q)
```

And to delete all the images on your Docker host, this command will get the job done:

```
$ docker image rm $(docker images -q)
```

The `docker container ls` and `docker images` commands both support a `filter` argument that can make it easy to fine-tune your delete commands for certain circumstances.

To remove all containers that exited with a nonzero state, you can use this filter:

```
$ docker container rm $(docker container ls -a -q --filter 'exited!=0')
```

And to remove all untagged images, you can type this:

```
$ docker image rm $(docker images -q -f "dangling=true")
```

**NOTE**

You can read the [official Docker documentation](https://docs.docker.com/engine/reference/commandline/ps/#filtering) to explore the filtering options. At the moment, there are very few filters to choose from, but more will likely be added over time.

You can also make your own very creative filters by stringing together commands using pipes (|) and other similar techniques.

In production systems that see a lot of deployments, you can sometimes end up with old containers or unused images lying around and filling up disk space. It can be useful to script the `docker system prune` command to run on a schedule (e.g., running under `cron` or via a `systemd` timer).

## Windows Containers

Up to now we have focused entirely on Docker commands for Linux containers, since this is the most common use case and works on all Docker platforms. However, since 2016, the Microsoft Windows platform has supported running Windows containers that include native Windows applications and can be managed with the usual set of Docker commands.

Windows containers are not the focus of this book, since they still only make up a small portion of production containers and aren’t 100% compatible with the rest of the Docker ecosystem because they require Windows-specific container images. However, they’re a growing and important part of the Docker world, so we’ll take a brief look at how they work. In fact, except for the actual contents of the containers, almost everything else works the same as Linux containers. In this section, we’ll run through a quick example of how you can run a Windows container on Windows 10+ with Hyper-V and Docker.

**TIP**

For this to work, you must be using Docker Desktop on a compatible 64-bit edition of Windows 10 or later.

The first thing you’ll need to do is switch Docker from Linux containers to Windows containers. To do this, right-click on the Docker whale icon in your taskbar, select “Switch to Windows Containers…,” and then confirm the switch (Figures [5-1](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#figure5-1) and [5-2](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#figure5-2)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0501.png" alt="Switch to Windows containers" height="604" width="600"><figcaption></figcaption></figure>

**Figure 5-1. Switch to Windows containers**

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0502.png" alt="Switch to Windows containers confirmation" height="210" width="600"><figcaption></figcaption></figure>

**Figure 5-2. Switch to Windows containers confirmation**

This process might take some time, although it usually happens almost immediately. Unfortunately, there is no notification that the switch has completed. If you right-click on the Docker icon again, you should now see “Switch to Linux Containers…” in place of the original option.

**NOTE**

If the first time you right-click on the Docker icon, it reads “Switch to Linux Containers…,” then you are already configured for Windows containers.

We can test a simple Windows container by opening up [PowerShell](https://oreil.ly/SiTXP)[4](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#idm46803145899968) and trying to run the following command:

```
PS C:\> docker container run --rm -it mcr.microsoft.com/powershell `
          pwsh -command `
          'Write-Host "Hello World from Windows `($IsWindows`)"'

Hello World from Windows (True)
```

This will download and launch a [base container for PowerShell](https://hub.docker.com/\_/microsoft-powershell) and then use scripting to print `Hello World from Windows (True)` to the screen.

**NOTE**

If the output from the preceding command prints `Hello World from Windows (false)`, then you have not switched over to Windows Container mode, or you are running this command on a non-Windows platform.

If you want to build a Windows container image that accomplishes roughly the same task, you can create the following _Dockerfile_:

```
# escape=`
FROM mcr.microsoft.com/powershell
SHELL ["pwsh", "-command"]

RUN Add-Content C:\helloworld.ps1 `
      'Write-Host "Hello World from Windows"'

CMD ["pwsh", "C:\\helloworld.ps1"]
```

When you build this _Dockerfile_, it will base the image on `mcr.microsoft.com/` `powershell`, create a small PowerShell script, and then configure the image to run that script when this image is used to launch a container.

**WARNING**

You may have noticed that we had to escape the backslash (`\`) with an additional backslash in the preceding _Dockerfile_’s `CMD` line. This is because Docker has its roots in Unix, and the backslash has a special meaning in Unix shells. So, even though we [changed the escape character](https://docs.docker.com/engine/reference/builder/#escape) for the _Dockerfile_ to match what is used in PowerShell by default (which we set via [the `SHELL` directive](https://docs.docker.com/engine/reference/builder/#shell-form-entrypoint-example)), we still need to escape some backslashes to ensure that Docker does not misinterpret them.

If you build this _Dockerfile_ now, you’ll see something similar to this:

```
PS C:\> docker image build -t windows-helloworld:latest .

Sending build context to Docker daemon  2.048kB
Step 1/4 : FROM mcr.microsoft.com/powershell
 ---> 7d8f821c04eb
Step 2/4 : SHELL ["pwsh", "-command"]
 ---> Using cache
 ---> 1987fb489a3d
Step 3/4 : RUN Add-Content C:\helloworld.ps1
                 'Write-Host "Hello World from Windows"'
 ---> Using cache
 ---> 37df47d57bf1
Step 4/4 : CMD ["pwsh", "C:\\helloworld.ps1"]
 ---> Using cache
 ---> 03046ff628e4
Successfully built 03046ff628e4
Successfully tagged windows-helloworld:latest
```

And now if you run the resulting image, you’ll see this:

```
PS C:\> docker container run --rm -ti windows-helloworld:latest

Hello World from Windows
```

Microsoft maintains good [documentation about Windows containers](https://oreil.ly/fYMHl)[5](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#idm46803145707776) that also includes an [example of building a container that launches a .NET application](https://oreil.ly/WG2W2).[6](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#idm46803145685248)

**TIP**

On the Windows platform, it is also useful to know that you can get improved isolation for your container by launching it inside a dedicated and very lightweight Hyper-V VM. You can do this very easily by simply adding the `--isolation=hyperv` option to your `docker container create` and `docker container run` commands. There is a small performance and resource penalty for this, but it significantly improves the isolation of your container. You can read more about this in the [documentation](https://learn.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container).

Even if you plan to mostly work with Windows containers, for the rest of the book you should switch back to Linux containers so that all the examples work as expected. When you are done reading and are ready to dive into building your containers, you can always switch back.

**TIP**

Remember that you can re-enable Linux containers by right-clicking on the Docker icon and selecting “Switch to Linux Containers….”

## Wrap-Up

In the next chapter, we’ll continue our exploration of what Docker brings to the table. For now, it’s probably worth doing a little experimentation on your own. We suggest exercising some of the container control commands we covered here so that you’re familiar with the command-line options and the overall syntax. Now would even be a great time to try to design and build a small image and then launch it as a new container. When you are ready to continue, head on to [Chapter 6](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch06.html#exploring\_docker)!

[1](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#idm46803149032576-marker) SELinux is one current implementation.

[2](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#idm46803148782320-marker) Typically under _/var/lib/docker/containers_.

[3](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#idm46803147988272-marker) Full URL: [_https://docs.docker.com/engine/install/linux-postinstall/#your-kernel-does-not-support-cgroup-swap-limit-capabilities_](https://docs.docker.com/engine/install/linux-postinstall/#your-kernel-does-not-support-cgroup-swap-limit-capabilities)

[4](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#idm46803145899968-marker) Full URL: [_https://learn.microsoft.com/en-us/powershell/scripting/overview?view=powershell-7.3\&viewFallbackFrom=powershell-6_](https://learn.microsoft.com/en-us/powershell/scripting/overview?view=powershell-7.3\&viewFallbackFrom=powershell-6)

[5](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#idm46803145707776-marker) Full URL: [_https://learn.microsoft.com/en-us/virtualization/windowscontainers/about_](https://learn.microsoft.com/en-us/virtualization/windowscontainers/about)

[6](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch05.html#idm46803145685248-marker) Full URL: [_https://learn.microsoft.com/en-us/virtualization/windowscontainers/quick-start/building-sample-app_](https://learn.microsoft.com/en-us/virtualization/windowscontainers/quick-start/building-sample-app)
