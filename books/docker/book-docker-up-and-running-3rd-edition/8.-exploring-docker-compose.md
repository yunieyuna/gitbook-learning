# 8. Exploring Docker Compose

## Chapter 8. Exploring Docker Compose

At this point, you should have a good feel for the `docker` command and how to use it to build, launch, monitor, and debug your applications. Once you are comfortable working with individual containers, it won’t be long before you’ll want to share your projects and start building more complex projects that require multiple containers to function properly. This is particularly the case in development environments, where running a whole stack of containers can easily simulate many production environments on your local machine.

If you’re running a whole stack of containers, however, every container needs to be run with the proper setup to ensure that the underlying application is configured correctly and will run as expected. Getting these settings correct every time can be challenging, especially when you are not the person who originally wrote the application. To help with this during development, people often resort to trying to write shell scripts that can build and run multiple containers consistently. Although this works, it can become difficult to understand for a newcomer and hard to maintain as the project changes over time. It’s also not necessarily repeatable between projects.

To help address this problem, Docker, Inc., released a tool primarily aimed at developers called Docker Compose. This tool is included with Docker Desktop, but you can also install it by following the [online installation directions](https://docs.docker.com/compose/install).

**NOTE**

Docker Compose was originally a separate application written in Python that was run using the command `docker-compose`. This command is referred to as Docker Compose version 1 and has recently been replaced with Docker Compose version 2. Docker Compose v2 was completely rewritten in Go, as a Docker client plug-in. If `docker compose version` returns a result, then you have the plug-in installed. If not, we highly recommend that you take a little time to install it now.

Docker Compose is an incredibly useful tool that can streamline all sorts of development tasks that have traditionally been very cumbersome and error prone. It can easily be leveraged to help developers quickly spin up complicated application stacks, compile applications without the need for setting up complex local development environments, and much more.

In this chapter, we’ll do a run-through of how to use Compose to its best advantage. We’ll be using a GitHub repository in all of the following examples. If you want to run the examples as we go through them, you should run the following command to download the code, if you didn’t already do that in [Chapter 6](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch06.html#exploring\_docker):

```
$ git clone https://github.com/spkane/rocketchat-hubot-demo.git \
    --config core.autocrlf=input
```

**NOTE**

In the example, shell script and _docker-compose.yaml_ files below some lines have been truncated to fit in the margins. Make sure that you use the files from this Git repository if you plan to try these examples yourself.

This repository contains the configuration we’ll need to launch a complete web service that includes a MongoDB datastore, the open source Rocket.Chat communications server, a Hubot [ChatOps](https://goo.gl/hKT3QW) bot, and a `zmachine-api` instance for a little surprise entertainment value.

## Configuring Docker Compose

Before we dive into using the `docker compose` command, it is useful to see the kind of ad hoc tooling it replaces. So let’s take a moment to look at a shell script that could be used to build and deploy a local copy of our service for development and local testing via Docker. This output is long and detailed, but it’s important to prove the point about why Docker Compose is a huge leap over shell scripting.

**WARNING**

We do not recommend running this shell script. It is simply an example, and in your environment, it may not work or may leave things in an odd state.

```
#!/bin/bash

# This is here just to keep people from really running this.
exit 1

# The actual script
#
# Note: This has not been updated to directly mirror the docker-compose file
#       since it is just intended to make a point.

set -e
set -u

if [ $# -ne 0 ] && [ ${1} == "down" ]; then
  docker rm -f hubot || true
  docker rm -f zmachine || true
  docker rm -f rocketchat || true
  docker rm -f mongo-init-replica || true
  docker rm -f mongo || true
  docker network rm botnet || true
  echo "Environment torn down…"
  exit 0
fi

# Global Settings
export PORT="3000"
export ROOT_URL="http://127.0.0.1:3000"
export MONGO_URL="mongodb://mongo:27017/rocketchat"
export MONGO_OPLOG_URL="mongodb://mongo:27017/local"
export MAIL_URL="smtp://smtp.email"
export RESPOND_TO_DM="true"
export HUBOT_ALIAS=". "
export LISTEN_ON_ALL_PUBLIC="true"
export ROCKETCHAT_AUTH="password"
export ROCKETCHAT_URL="rocketchat:3000"
export ROCKETCHAT_ROOM=""
export ROCKETCHAT_USER="hubot"
export ROCKETCHAT_PASSWORD="bot-pw!"
export BOT_NAME="bot"
export EXTERNAL_SCRIPTS="hubot-help,hubot-diagnostics,hubot-zmachine"
export HUBOT_ZMACHINE_SERVER="http://zmachine:80"
export HUBOT_ZMACHINE_ROOMS="zmachine"
export HUBOT_ZMACHINE_OT_PREFIX="ot"

docker build -t spkane/mongo:4.4 ./mongodb/docker

docker push spkane/mongo:4.4
docker pull spkane/zmachine-api:latest
docker pull rocketchat/rocket.chat:5.0.4
docker pull rocketchat/hubot-rocketchat:latest

docker rm -f hubot || true
docker rm -f zmachine || true
docker rm -f rocketchat || true
docker rm -f mongo-init-replica || true
docker rm -f mongo || true

docker network rm botnet || true

docker network create -d bridge botnet

docker container run-d \
  --name=mongo \
  --network=botnet \
  --restart unless-stopped \
  -v $(pwd)/mongodb/data/db:/data/db \
  spkane/mongo:4.4 \
  mongod --oplogSize 128 --replSet rs0
sleep 5
docker container run-d \
  --name=mongo-init-replica \
  --network=botnet \
  spkane/mongo:4.4 \
  'mongo mongo/rocketchat --eval "rs.initiate({ _id: ''rs0'', members: [ { … '
sleep 5
docker container run-d \
  --name=rocketchat \
  --network=botnet \
  --restart unless-stopped  \
  -v $(pwd)/rocketchat/data/uploads:/app/uploads \
  -p 3000:3000 \
  -e PORT=${PORT} \
  -e ROOT_URL=${ROOT_URL} \
  -e MONGO_URL=${MONGO_URL} \
  -e MONGO_OPLOG_URL=${MONGO_OPLOG_URL} \
  -e MAIL_URL=${MAIL_URL} \
  rocketchat/rocket.chat:5.0.4
docker container run-d \
  --name=zmachine \
  --network=botnet \
  --restart unless-stopped  \
  -v $(pwd)/zmachine/saves:/root/saves \
  -v $(pwd)/zmachine/zcode:/root/zcode \
  -p 3002:80 \
  spkane/zmachine-api:latest
docker container run-d \
  --name=hubot \
  --network=botnet \
  --restart unless-stopped  \
  -v $(pwd)/hubot/scripts:/home/hubot/scripts \
  -p 3001:8080 \
  -e RESPOND_TO_DM="true" \
  -e HUBOT_ALIAS=". " \
  -e LISTEN_ON_ALL_PUBLIC="true" \
  -e ROCKETCHAT_AUTH="password" \
  -e ROCKETCHAT_URL="rocketchat:3000" \
  -e ROCKETCHAT_ROOM="" \
  -e ROCKETCHAT_USER="hubot" \
  -e ROCKETCHAT_PASSWORD="bot-pw!" \
  -e BOT_NAME="bot" \
  -e EXTERNAL_SCRIPTS="hubot-help,hubot-diagnostics,hubot-zmachine" \
  -e HUBOT_ZMACHINE_SERVER="http://zmachine:80" \
  -e HUBOT_ZMACHINE_ROOMS="zmachine" \
  -e HUBOT_ZMACHINE_OT_PREFIX="ot" \
  rocketchat/hubot-rocketchat:latest
echo "Environment setup…"
exit 0
```

At this point, you can probably follow most of this script pretty easily. As you may already have noticed, this is a hassle to read, is not very flexible, will be a pain to edit, and might fail unexpectedly in several places. If we were to follow shell script best practices and handle all the possible errors here in an effort to guarantee that it was repeatable, it would also be two to three times as long as it already is. Without a lot of work extracting common functionality for error handling, you’d also have to rewrite much of that logic every time you have a new project like this. This is not a very good way to approach a process that you need to work every time you use it. This is where good tooling comes in. You can accomplish the same thing with Docker Compose while also making it significantly more repeatable and easier to read, understand, and maintain.

In contrast to this messy shell script, which is very repetitive and prone to breaking, Docker Compose is typically configured with a single, declarative [YAML](https://yaml.org/) file for each project, named _docker-compose.yaml_. This configuration file is very easy to read and will work in a very repeatable fashion so that each user has the same experience when they run it. Here you can see an example _docker-compose.yaml_ file that could be used to replace the preceding brittle shell script:

```
version: '3'
services:
  mongo:
    build:
      context: ../mongodb/docker
    image: spkane/mongo:4.4
    restart: unless-stopped
    environment:
      MONGODB_REPLICA_SET_MODE: primary
      MONGODB_REPLICA_SET_NAME: rs0
      MONGODB_PORT_NUMBER: 27017
      MONGODB_INITIAL_PRIMARY_HOST: mongodb
      MONGODB_INITIAL_PRIMARY_PORT_NUMBER: 27017
      MONGODB_ADVERTISED_HOSTNAME: mongo
      MONGODB_ENABLE_JOURNAL: "true"
      ALLOW_EMPTY_PASSWORD: "yes"
    # Port 27017 already exposed by upstream
    # See the newer upstream Dockerfile:
    # https://github.com/bitnami/containers/blob/
    # f9fb3f8a6323fb768fd488c77d4f111b1330bd0e/bitnami/
    # mongodb/5.0/debian-11/Dockerfile#L52
    networks:
      - botnet
  rocketchat:
    image: rocketchat/rocket.chat:5.0.4
    restart: unless-stopped
    labels:
      traefik.enable: "true"
      traefik.http.routers.rocketchat.rule: Host(`127.0.0.1`)
      traefik.http.routers.rocketchat.tls: "false"
      traefik.http.routers.rocketchat.entrypoints: http
    volumes:
      - "../rocketchat/data/uploads:/app/uploads"
    environment:
      ROOT_URL: http://127.0.0.1:3000
      PORT: 3000
      MONGO_URL: "mongodb://mongo:27017/rocketchat?replicaSet=rs0"
      MONGO_OPLOG_URL: "mongodb://mongo:27017/local?replicaSet=rs0"
      DEPLOY_METHOD: docker
    depends_on:
      mongo:
        condition: service_healthy
    ports:
      - 3000:3000
    networks:
      - botnet
  zmachine:
    image: spkane/zmachine-api:latest
    restart: unless-stopped
    volumes:
      - "../zmachine/saves:/root/saves"
      - "../zmachine/zcode:/root/zcode"
    depends_on:
      - rocketchat
    expose:
      - "80"
    networks:
      - botnet
  hubot:
    image: rocketchat/hubot-rocketchat:latest
    restart: unless-stopped
    volumes:
      - "../hubot/scripts:/home/hubot/scripts"
    environment:
      RESPOND_TO_DM: "true"
      HUBOT_ALIAS: ". "
      LISTEN_ON_ALL_PUBLIC: "true"
      ROCKETCHAT_AUTH: "password"
      ROCKETCHAT_URL: "rocketchat:3000"
      ROCKETCHAT_ROOM: ""
      ROCKETCHAT_USER: "hubot"
      ROCKETCHAT_PASSWORD: "bot-pw!"
      BOT_NAME: "bot"
      EXTERNAL_SCRIPTS: "hubot-help,hubot-diagnostics,hubot-zmachine"
      HUBOT_ZMACHINE_SERVER: "http://zmachine:80"
      HUBOT_ZMACHINE_ROOMS: "zmachine"
      HUBOT_ZMACHINE_OT_PREFIX: "ot"
    depends_on:
      - zmachine
    ports:
      - 3001:8080
    networks:
      - botnet
networks:
  botnet:
    driver: bridge
```

The _docker-compose.yaml_ file makes it easy to describe all the important requirements for each of your services and how they need to communicate with one another. And we get a lot of validation and logic checking for free that we didn’t even have time to write into our shell script and that we’d probably get wrong on occasion, no matter how careful we are.

So, what did we tell Compose to do in that YAML file? The first line of our file simply tells Docker Compose what version of the [Compose configuration language](https://docs.docker.com/compose/compose-file) this file was designed for:

```
version: '3'
```

The rest of our document is divided into two sections: `services` and `networks`.

For starters, let’s take a quick look at the `networks` section. In this _docker-compose.yaml_ file, we are defining a single, named Docker network:

```
networks:
  botnet:
    driver: bridge
```

This is a very simple configuration that tells Docker Compose to create a single network, named `botnet`, using the (default) bridge driver, which will bridge the Docker network with the host’s networking stack.

The `services` section is the most important part of the configuration and tells Docker Compose what applications you want to launch. Here, the `services` section defines five services: `mongo`, `mongo-init-replica`, `rocketchat`, `zmachine`, and `hubot`. Each named service then contains sections that tell Docker how to build, configure, and launch that service.

If you take a look at the `mongo` service, you will see that the first subsection is called `build` and contains a `context` key. This informs Docker Compose that it can build this image and that the files required for the build are located in the _../../mongodb/docker_ directory, which is two levels above the directory containing the _docker-compose.yaml_ file:

```
    build:
      context: ../../mongodb/docker
```

If you look at the _Dockerfile_ in the _mongodb/docker_ directory, you will see this:

```
FROM mongo:4.4

COPY docker-healthcheck /usr/local/bin/

# Useful Information:
# https://docs.docker.com/engine/reference/builder/#healthcheck
# https://docs.docker.com/compose/compose-file/#healthcheck
HEALTHCHECK CMD ["docker-healthcheck"]
```

Take a moment to look at the `HEALTHCHECK` line. This tells Docker what command should be run to check the health of the container. Docker will not take action based on this health check, but it will report the health so that other things can make use of this information. If you are curious, feel free to take a look at the `docker-healthcheck` script in the _mongodb/docker_ directory.

The next setting, `image`, defines the image tag that you want either to apply to your build or to download (if you’re not building an image) and then run:

```
    image: spkane/mongo:4.4
```

With the `restart` option, you tell Docker when you want it to restart your containers. In most cases, you’ll want Docker to restart your containers any time that you have not specifically stopped them:

```
    restart: unless-stopped
```

Next, you will see an `environment` section. This is where you can define any environment variables that you want to pass into your container:

```
    environment:
      MONGODB_REPLICA_SET_MODE: primary
      MONGODB_REPLICA_SET_NAME: rs0
      MONGODB_PORT_NUMBER: 27017
      MONGODB_INITIAL_PRIMARY_HOST: mongodb
      MONGODB_INITIAL_PRIMARY_PORT_NUMBER: 27017
      MONGODB_ADVERTISED_HOSTNAME: mongo
      MONGODB_ENABLE_JOURNAL: "true"
      ALLOW_EMPTY_PASSWORD: "yes"
```

The final subsection for the `mongo` service, `networks`, tells Docker Compose which network this container should be attached to:

```
    networks:
      - botnet
```

At this point, let’s jump down to the `rocketchat` service. This service does not have a `build` subsection; instead, it only defines an image tag that tells Docker Compose that it cannot build this image and must instead try to pull and launch a preexisting Docker image with the defined tag.

The first new subsection that you will notice in this service is called `volumes`.

A lot of services have at least some data that should be persisted during development, despite the ephemeral nature of containers. To accomplish this, it is easiest to mount a local directory into the containers. The `volumes` section allows you to list all the local directories that you would like to have mounted into a container, and define where they go. This command will bind-mount _../rocketchat/data/uploads_ into _/app/uploads_ inside the container:

```
    volumes:
      - "../rocketchat/data/uploads:/app/uploads"
```

**WARNING**

You may have noticed that we do not define a `volume` for MongoDB, which might seem a bit counterintuitive. Although a bind-mounted volume would be useful to store the database files in, MongoDB will fail to write to the native Windows filesystem, so we leave this out to achieve the broadest compatibility and instead let the database write into the container for this development use case.

The primary result of this is that when you delete the container using a command like `docker compose down`, all of the data in the MongoDB instance will be lost.

We could easily solve this MongoDB storage problem by using a [data volume container](https://docs.docker.com/storage/volumes/#create-and-manage-volumes), but this example is specifically using bind mounts for the volumes.

**TIP**

In almost all cases, you should not use host-based local storage for containers in production. This can be very convenient in development since you are using a single host, but in production, your containers will often be deployed to whatever node has space and resources, and will lose access to files stored on a single host’s filesystem. In production, if you need stateful storage, you have to leverage things like network-based storage, Kubernetes Persistent Volumes, etc.

In the `environment` section for the `rocketchat` service, you will see that the value for the `MONGO_URL` does not use an IP address or fully qualified domain name. This is because all of these services are running on the same Docker network, and Docker Compose configures each container so that it can find the others via their service names. This means that we can easily configure URLs like this to simply point at the service name and internal port for the container we need to connect to. And, if we rearrange things, these names will continue to point to the right container in our stack. They are also nice because they make it quite explicit to the reader what the dependency is for that container:

```
    environment:
      …
      MONGO_URL: "mongodb://mongo:27017/rocketchat?replicaSet=rs0"
      …
```

**TIP**

The _docker-compose.yaml_ file can also refer to environment variables using the `${VARIABLE_NAME}` format, which makes it possible to pull in secrets without actually storing them in this file. Docker Compose also supports an [_.env_](https://docs.docker.com/compose/env-file) file, which can be very useful for handling secrets and environment variables that change between developers, for example.

The `depends_on` section defines a container that must be running before this container can be started. By default, `docker compose` only ensures that the container is running, not that it is healthy; however, you can leverage the `HEALTHCHECK` functionality in Docker, and the condition statement in Docker Compose, to require that the dependent service be healthy before Docker Compose brings the new service up. It is important to remember that this only impacts startup. Docker will report services that become unhealthy later on, but it does not take any action to correct the situation unless the container exits, in which case, Docker will restart the container if it is configured to do so:

```
    depends_on:
      mongo:
        condition: service_healthy
```

**NOTE**

We discuss Docker’s health-check functionality in more detail in [“Container Health Checks”](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch06.html#health\_checks). You can also find more information in the documentation for [Docker](https://dockr.ly/2MYnLZL) and [Docker Compose](https://dockr.ly/2wt366J).

The `ports` subsection allows you to define all the ports that you want to be mapped from the container to the host:

```
    ports:
      - 3000:3000
```

The `zmachine` service uses only one new subsection, called `expose`. This section allows us to tell Docker that we want to expose this port to the other containers on the Docker network but not to the underlying host. This is why you do not provide a host port to map this port to:

```
    expose:
      - "80"
```

You might notice at this point that, while we expose a port for `zmachine`, we didn’t expose a port in the `mongo` service. It wouldn’t have hurt anything to expose the `mongo` port, but we didn’t need to because it is already exposed by the upstream [`mongo` _Dockerfile_](https://github.com/docker-library/mongo/blob/58bdba62b65b1d1e1ea5cbde54c1682f120e0676/3.2/Dockerfile#L95). This is sometimes a little opaque. `docker image history` on the built image can be helpful here.

Here we’ve used an example that is complex enough to expose you to some of the power of Docker Compose, but it is by no means exhaustive. There is a great deal else that you can configure in a _docker-compose.yaml_ file, including security settings, resource quotas, and much more. You can find a lot of detailed information about configuration for Compose in the [official Docker Compose documentation](https://docs.docker.com/compose/compose-file).

## Launching Services

We configured a set of services for our application in the YAML file. That tells Compose what we’re going to launch and how to configure it. So, let’s get it up and running! To run our first Docker Compose command, we need to be sure that we are in the same directory as the _docker-compose.yaml_ file:

```
$ cd rocketchat-hubot-demo/compose
```

Once you are in the correct directory, you can confirm that the configuration is correct by running the following:

```
$ docker compose config
```

If everything is fine, the command will print out your configuration file. If there is a problem, the command will print an error with details about the problem, like so:

```
services.mongo Additional property builder is not allowed
```

You can build any containers that you need by using the `build` option. Any services that use images will be skipped:

```
$ docker compose build

 => [internal] load build definition from Dockerfile                      0.0s
 => => transferring dockerfile: 32B                                       0.0s
 => [internal] load .dockerignore                                         0.0s
 => => transferring context: 2B                                           0.0s
 => [internal] load metadata for docker.io/bitnami/mongodb:4.4            1.2s
 => [auth] bitnami/mongodb:pull token for registry-1.docker.io            0.0s
 => [internal] load build context                                         0.0s
 => => transferring context: 40B                                          0.0s
 => [1/2] FROM docker.io/bitnami/mongodb:4.4@sha256:9162…ae209            0.0s
 => CACHED [2/2] COPY docker-healthcheck /usr/local/bin/                  0.0s
 => exporting to image                                                    0.0s
 => => exporting layers                                                   0.0s
 => => writing image sha256:a6ef…da808                                    0.0s
 => => naming to docker.io/spkane/mongo:4.4                               0.0s
```

You can start up your web service in the background by running the following command:

```
$ docker compose up -d

[+] Running 5/5
 ⠿ Network compose_botnet                  Created                        0.0s
 ⠿ Container compose-mongo-1               Healthy                       62.0s
 ⠿ Container compose-rocketchat-1          Started                       62.3s
 ⠿ Container compose-zmachine-1            Started                       62.5s
 ⠿ Container compose-hubot-1               Started                       62.6s
```

Docker Compose prefixes the network and container names with a project name. By default, this is the name of the directory that contains your _docker-compose.yaml_ file. Since this command was run in a directory named _compose_, you can see that everything starts with `compose` as the project name.

**WARNING**

_Windows users_: when you first bring up the services, Windows may prompt you to authorize _vpnkit_, and Docker Desktop for Windows may also prompt you to share your disk. You must click both the “Allow access” and the “Share it” buttons for the network and volume shares to work and everything to come up properly.

Once everything comes up, we can take a quick look at the logs for all of the services ([Figure 8-1](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#figure8-1)):

```
$ docker compose logs
```

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0801.png" alt="docker compose logs output" height="114" width="600"><figcaption></figcaption></figure>

**Figure 8-1. `docker compose logs` output**

You can’t see it well in print here, but if you’re following along, note that all of the logs are color coded by service and interlaced by the time Docker received the log lines. This makes it a lot easier to follow what’s happening, even though several services are logging messages at once.

It can take Rocket.Chat a little while to set up the database and be ready to accept connections. Once the Rocket.Chat logs print a line that contains `SERVER RUNNING`, things should be ready to go:

```
$ docker compose logs rocketchat | grep "SERVER RUNNING"

compose-rocketchat-1  | |                SERVER RUNNING                |
```

At this point, we have successfully launched a reasonably complex application that makes up a stack of containers. We’ll take a look at this simple application now so that you can see what we built and get a more complete understanding of the Compose tooling. While this next section does not strictly have anything to do with Docker itself, it is intended to show you how easy it is to use Docker Compose to set up complex and fully functioning web services.

## Exploring Rocket.Chat

**NOTE**

In this section, we’re going to diverge from Docker for a moment and take a look at Rocket.Chat. We’ll spend a few pages on it so that you know enough about it that you can hopefully start to appreciate how much easier it is to set up a complex environment using Docker Compose. Feel free to skip down to [“Exercising Docker Compose”](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#exercise\_dc), if you would like.

We’ll shortly dig further into what’s happening behind the scenes of our setup. But to do that effectively, we should now take a brief moment to explore the application stack we built. [Rocket.Chat](https://rocket.chat/), the primary application we launched with Docker Compose, is an open source chat client/server application. To see how it works, let’s launch a web browser and navigate to [_http://127.0.0.1:3000_](http://127.0.0.1:3000/).

When you get there, you see the Admin Info screen for Rocket.Chat ([Figure 8-2](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#figure8-2)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0802.png" alt="Rocket.Chat Admin Info screen" height="457" width="556"><figcaption></figcaption></figure>

**Figure 8-2. Rocket.Chat Admin Info screen**

Fill out the form like this:

* Full name: **`student`**
* Username: **`student`**
* Email: **`student@example.com`**
* Password: **`student-pw!`**

Then click the blue Next button.

You then see the Organization Info screen ([Figure 8-3](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#figure8-3)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0803.png" alt="Rocket.Chat Organization Info screen" height="539" width="559"><figcaption></figcaption></figure>

**Figure 8-3. Rocket.Chat Organization Info screen**

The specifics of this form are not critical, but you can fill it in something like this:

* Organization name: **`training`**
* Organization type: **`Community`**
* Organization industry: **`Education`**
* Organization size: **`1-10 people`**
* Country: **`United States`**

Then click the blue Next button.

At this point, you see the Register Your Server screen ([Figure 8-4](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#figure8-4)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0804.png" alt="Rocket.Chat Register Your Server screen" height="423" width="551"><figcaption></figcaption></figure>

**Figure 8-4. Rocket.Chat Register Your Server screen**

You can simply delete and uncheck everything and then click the small blue “Continue as standalone” link. You then see the Standalone Server Configuration screen ([Figure 8-5](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#figure8-5)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0805.png" alt="Rocket.Chat Standalone Server Confirmation screen" height="237" width="556"><figcaption></figcaption></figure>

**Figure 8-5. Rocket.Chat Standalone Server Confirmation screen**

Click the blue Confirm button.

**WARNING**

If you are using `localhost` or something other than 127.0.0.1 to reach Rocket.Chat in your browser, you may get a pop-up window asking if you would like to update the `SITE_URL`. In most cases, go ahead and let it update that value so that it matches what you are using.

Congratulations—you are now logged in to a fully functional chat client, but you aren’t done yet. The Docker Compose configuration launched an instance of a [Hubot](https://hubot.github.com/) chat assistant and the mysterious zmachine, so let’s take a look at those.

Since the Rocket.Chat server is brand new, it doesn’t yet have a user that our bot can use. Let’s remedy that.

Start by clicking the top of the left sidebar, where you see a purple box with the letter _S_ in it. Click Administration in the pop-up menu ([Figure 8-6](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#figure8-6)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0806.png" alt="Rocket.Chat Administration sidebar" height="433" width="296"><figcaption></figcaption></figure>

**Figure 8-6. Rocket.Chat Administration sidebar**

In the Administration panel, click Users ([Figure 8-7](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#figure8-7)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0807.png" alt="Rocket.Chat User screen" height="198" width="600"><figcaption></figcaption></figure>

**Figure 8-7. Rocket.Chat User screen**

On the top-far-right side of the screen, click the New button to display the Add User screen ([Figure 8-8](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#figure8-8)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0808.png" alt="Rocket.Chat Add User screen" height="800" width="330"><figcaption></figcaption></figure>

**Figure 8-8. Rocket.Chat Add User screen**

Fill out the form as follows:

* Name: **`hubot`**
* Username: **`hubot`**
* Email: **`hubot@example.com`**
* Click: **`Verified` (Blue)**
* Password: **`bot-pw!`**
* Roles: **`bot`**
* Disable: **`Send welcome email` (Gray)**

Click Save to create the user.

To ensure that the bot can log in, we also need to disable two-factor authentication, which is enabled by default. To do this, click Settings at the bottom of the Administration sidebar on the left side of your browser ([Figure 8-9](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#figure8-9)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0809.png" alt="Rocket.Chat Administration settings" height="731" width="279"><figcaption></figcaption></figure>

**Figure 8-9. Rocket.Chat Administration settings**

The Settings screen is displayed ([Figure 8-10](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#figure8-10)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0810.png" alt="Rocket.Chat Accounts settings" height="291" width="294"><figcaption></figcaption></figure>

**Figure 8-10. Rocket.Chat Accounts settings**

In the new text search bar, type **`totp`**, then click the Open button under Accounts.

You should now see a long list of settings ([Figure 8-11](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#figure8-11)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0811.png" alt="Rocket.Chat TOTP settings" height="185" width="600"><figcaption></figcaption></figure>

**Figure 8-11. Rocket.Chat TOTP settings**

Scroll down to the Two Factor Authentication section, expand it, and then deselect the Enable Two Factor Authentication option.

Once you have done this, click “Save changes.”

At the top of the left side of the Administration panel, click the X to close the panel ([Figure 8-12](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#figure8-12)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0812.png" alt="Rocket.Chat close Administration panel" height="183" width="275"><figcaption></figcaption></figure>

**Figure 8-12. Rocket.Chat close Administration panel**

In the left side panel under Channels, click “general” ([Figure 8-13](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#figure8-13)).

<figure><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098131814/files/assets/dur3_0813.png" alt="Rocket.Chat General channel" height="157" width="600"><figcaption></figcaption></figure>

**Figure 8-13. Rocket.Chat general channel**

And finally, if you don’t already see a message in the channel that “Hubot has joined the channel,” go ahead and tell Docker Compose to restart the Hubot container. This will force Hubot to try and log into the chat server again, now that there is a user for the service to use:

```
$ docker compose restart hubot
Restarting unix_hubot_1 … done
```

If everything went according to plan, you should now be able to navigate back to your web browser and send commands to Hubot in the chat window.

**NOTE**

Hubot should auto-join the General channel when it logs into the server, but just in case, you can send the following message in the General channel to explicitly invite Hubot:

```
/invite @hubot
```

You may get a message from the internal admin `rocket.cat` that says “@hubot is already in here.” This is perfectly fine.

The environment variables used to configure Hubot defined its alias as a period. So you can now try typing `. help` to test that the bot is responding. If everything is working, you should get a list of commands that the bot understands and will respond to:

```
> . help
. adapter - Reply with the adapter
. echo <text> - Reply back with <text>
. help - Displays all of the help commands that this bot knows about.
. help <query> - Displays all help commands that match <query>.
. ping - Reply with pong
. time - Reply with current time
…
```

Finally, try typing the following:

```
. ping
```

Hubot should respond with `PONG`.

If you type:

```
. time
```

then Hubot will tell you what the time is set to on the server.

So, for one last diversion, try creating a new chat channel by typing `/create zmachine` in the chat window. You should now be able to click on the new `zmachine` channel in the left sidebar and invite Hubot with the chat command `/invite @hubot`.

**NOTE**

When you do this, Hubot might say:

```
There's no game for zmachine!
```

This is nothing to be concerned about.

Next, try typing the following commands into the chat window to play a chat-based version of the famous game [_Colossal Cave Adventure_](https://en.wikipedia.org/wiki/Interactive\_fiction#Adventure):

```
. z start adventure

more
look
go east
examine keys
get keys

. z save firstgame
. z stop
. z start adventure
. z restore firstgame

inventory
```

**WARNING**

Interactive fiction can be addictive and a huge time sink. You have been warned. That being said, if you aren’t already familiar with it and are interested in learning more, take a look at some of these resources:

* [Definition of interactive fiction](https://en.wikipedia.org/wiki/Interactive\_fiction)
* [Emulator](https://davidgriffith.gitlab.io/frotz)
* [Development](https://ganelson.github.io/inform-website)
* [Games](https://oreil.ly/IrOLh)[1](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#idm46803138496976)
* [Competition](https://ifcomp.org/)

You’ve now seen how easy it can be to configure, launch, and manage complex web services that require multiple components to accomplish their jobs using Docker Compose. In the next section, we will explore a few more of the features that Docker Compose includes.

**NOTE**

You could avoid much of the Rocket.Chat setup by providing MongoDB with a preconfigured Rocket.Chat database, but it felt important to remove any magic from this example to make it clearer how everything fits together.

## Exercising Docker Compose

Now that you have the full Rocket.Chat stack running and understand what the application is doing, we can dig in to get a little more insight into how the services are running. Some of the common Docker commands are also exposed as Compose commands, but for a specific stack rather than a single container or all of the containers on a host. You can run `docker compose top` to see an overview of your containers and the processes that are running in them:

```
$ docker compose top

compose-hubot-1
UID  PID   … CMD
1001 73342 … /usr/bin/qemu-x86_64 /bin/sh /bin/sh -c node -e "console.l…"
1001 73459 … /usr/bin/qemu-x86_64 /usr/local/bin/node node node_modules/…

compose-mongo-1
UID  PID   … CMD
1001 71243 … /usr/bin/qemu-x86_64 /opt/bitnami/mongodb/bin/mongod /opt/…

compose-rocketchat-1
UID   PID   … CMD
65533 71903 … /usr/bin/qemu-x86_64 /usr/local/bin/node node main.js

compose-zmachine-1
UID  PID   … CMD
root 71999 … /usr/bin/qemu-x86_64 /usr/local/bin/node node /root/src/server.js
root 75078 … /usr/bin/qemu-x86_64 /root/src/../frotz/dfrotz /root/src/…
```

Similar to how you would normally enter a running Linux container using the `docker container exec` command, you can run commands inside containers via the Docker Compose tooling using the `docker compose exec` command. Because `docker compose` is a newer tool, it provides some convenient shortcuts over the standard `docker` commands. In the case of `docker compose exec`, you do not need to pass in `-i -t`, and you can use the Docker Compose service name instead of trying to remember the container ID or name:

```
$ docker compose exec mongo bash

I have no name!@0078134f9370:/$ mongo
MongoDB shell version v4.4.15
connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&…
Implicit session: session { "id" : UUID("daec9543-bb9c-4e8c-ba6b…") }
MongoDB server version: 4.4.15
…
rs0:PRIMARY> exit
bye
I have no name!@0078134f9370:/$ exit
exit
```

**TIP**

`docker compose logs` and `docker compose exec` are probably the most useful commands for troubleshooting. If Docker Compose cannot build your image or start your container at all, you will need to fall back to the standard `docker` commands to debug your image and container, as we discussed in [“Troubleshooting Broken Builds”](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch04.html#broken\_builds) and [“Getting Inside a Running Container”](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch06.html#inside\_containers).

You can also use Docker Compose to `start` and `stop` and, in most environments, `pause` and `unpause` either a single container or all of your containers, depending on what you need:

```
$ docker compose stop zmachine
[+] Running 1/1
 ⠿ Container compose-zmachine-1  Stopped                                  0.3s
$ docker compose start zmachine
[+] Running 2/2
 ⠿ Container compose-mongo-1     Healthy                                  0.5s
 ⠿ Container compose-zmachine-1  Started                                  0.4s
$ docker compose pause
[+] Running 4/0
 ⠿ Container compose-mongo-1       Paused                                 0.0s
 ⠿ Container compose-zmachine-1    Paused                                 0.0s
 ⠿ Container compose-rocketchat-1  Paused                                 0.0s
 ⠿ Container compose-hubot-1       Paused                                 0.0s
$ docker compose unpause
[+] Running 4/0
 ⠿ Container compose-zmachine-1    Unpaused                               0.0s
 ⠿ Container compose-hubot-1       Unpaused                               0.0s
 ⠿ Container compose-rocketchat-1  Unpaused                               0.0s
 ⠿ Container compose-mongo-1       Unpaused                               0.0s
```

Finally, when you want to tear everything down and delete all the containers created by Docker Compose, you can run the following command:

```
$ docker compose down
[+] Running 5/5
 ⠿ Container compose-hubot-1       Removed                               10.4s
 ⠿ Container compose-zmachine-1    Removed                                0.1s
 ⠿ Container compose-rocketchat-1  Removed                                0.6s
 ⠿ Container compose-mongo-1       Removed                                0.9s
 ⠿ Network compose_botnet          Removed                                0.1s
```

**WARNING**

When you delete the MongoDB container using the `docker compose down` command, all data in the MongoDB instance will be lost.

## Managing Configuration

Docker Compose offers a few important capabilities that can help you significantly improve the flexibility of your _docker-compose.yaml_ files. In this section, we will explore how you can avoid hardcoding many configuration values into your _docker-compose.yaml_ files while still making them easy to use by default.

### Default Values

If we take a look at the _services:rocketchat:environment_ section of the _docker-compose.yaml_ file, we will see something like this:

```
    environment:
      RESPOND_TO_DM: "true"
      HUBOT_ALIAS: ". "
      LISTEN_ON_ALL_PUBLIC: "true"
      ROCKETCHAT_AUTH: "password"
      ROCKETCHAT_URL: "rocketchat:3000"
      ROCKETCHAT_ROOM: ""
      ROCKETCHAT_USER: "hubot"
      ROCKETCHAT_PASSWORD: "bot-pw!"
      BOT_NAME: "bot"
      EXTERNAL_SCRIPTS: "hubot-help,hubot-diagnostics,hubot-zmachine"
      HUBOT_ZMACHINE_SERVER: "http://zmachine:80"
      HUBOT_ZMACHINE_ROOMS: "zmachine"
      HUBOT_ZMACHINE_OT_PREFIX: "ot"
```

Now, if we look at _docker-compose-defaults.yaml_ inside the same directory, we will see that this same section looks like this:

```
    environment:
      RESPOND_TO_DM: ${HUBOT_RESPOND_TO_DM:-true}
      HUBOT_ALIAS: ${HUBOT_ALIAS:-. }
      LISTEN_ON_ALL_PUBLIC: ${HUBOT_LISTEN_ON_ALL_PUBLIC:-true}
      ROCKETCHAT_AUTH: ${HUBOT_ROCKETCHAT_AUTH:-password}
      ROCKETCHAT_URL: ${HUBOT_ROCKETCHAT_URL:-rocketchat:3000}
      ROCKETCHAT_ROOM: ${HUBOT_ROCKETCHAT_ROOM:-}
      ROCKETCHAT_USER: ${HUBOT_ROCKETCHAT_USER:-hubot}
      ROCKETCHAT_PASSWORD: ${HUBOT_ROCKETCHAT_PASSWORD:-bot-pw!}
      BOT_NAME: ${HUBOT_BOT_NAME:-bot}
      EXTERNAL_SCRIPTS: ${HUBOT_EXTERNAL_SCRIPTS:-hubot-help,
                          hubot-diagnostics,hubot-zmachine}
      HUBOT_ZMACHINE_SERVER: ${HUBOT_ZMACHINE_SERVER:-http://zmachine:80}
      HUBOT_ZMACHINE_ROOMS: ${HUBOT_ZMACHINE_ROOMS:-zmachine}
      HUBOT_ZMACHINE_OT_PREFIX: ${HUBOT_ZMACHINE_OT_PREFIX:-ot}
```

This is using a technique called [_variable interpolation_](https://docs.docker.com/compose/compose-file/#interpolation) that Docker Compose has borrowed directly from many common Unix shells, like `bash`.

In the original file, the environment variable `ROCKETCHAT_PASSWORD` is hardcoded to the value `"bot-pw!"`:

```
      ROCKETCHAT_PASSWORD: "bot-pw!"
```

By using this new approach, we are stating that we want `ROCKETCHAT_PASSWORD` to be set to the value of the `HUBOT_ROCKETCHAT_PASSWORD` variable if it is set in the user’s environment, and if it is not, then `ROCKETCHAT_PASSWORD` should be set to the default value of `bot-pw!`:

```
      ROCKETCHAT_PASSWORD: ${HUBOT_ROCKETCHAT_PASSWORD:-bot-pw!}
```

This provides us with a great deal of flexibility since we can now make almost everything configurable while still providing reasonable defaults for the most common use case. We can easily test this out by running `docker compose up` with the new file:

```
$ docker compose -f docker-compose-defaults.yaml up -d

[+] Running 5/5
 ⠿ Network compose_botnet          Created                                0.0s
 ⠿ Container compose-mongo-1       Healthy                               31.0s
 ⠿ Container compose-rocketchat-1  Started                               31.2s
 ⠿ Container compose-zmachine-1    Started                               31.5s
 ⠿ Container compose-hubot-1       Started                               31.8s
```

By default, this will result in the exact same stack that we spun up earlier. However, we could easily make changes to it now by simply setting one or more environment variables in our terminal before running our `docker compose` commands:

```
$ docker compose -f docker-compose-defaults.yaml down
…

$ docker compose -f docker-compose-defaults.yaml config | \
    grep ROCKETCHAT_PASSWORD

      ROCKETCHAT_PASSWORD: bot-pw!

$ HUBOT_ROCKETCHAT_PASSWORD="my-unique-pw" docker compose \
    -f docker-compose-defaults.yaml config | \
    grep ROCKETCHAT_PASSWORD

      ROCKETCHAT_PASSWORD: my-unique-pw
```

**TIP**

In the examples here, Docker Compose will treat an empty environment variable exactly the same as one that is set to an empty string. If an empty string is a valid value in your use case, then you will want to modify the format of the variable substitution line so that it looks like this: `${VARIABLE_NAME-default-value}`. We recommend reading through [the documentation for this feature](https://docs.docker.com/compose/compose-file/#interpolation) so that you understand all the possibilities.

This is pretty nice, but what if we don’t want to provide a default value at all and instead want to force the user to set something? We can do this pretty easily as well.

**WARNING**

Some readers might be uncomfortable with the fact that we are passing in the password as part of the command line, since those passwords might be viewable in the system process list, etc., but don’t worry—we will address that in just a few minutes.

### Mandatory Values

To set a mandatory value, we simply need to alter the variable substitution line a bit. It seems like a bad idea to pass in a default password, so let’s go ahead and make that value required.

In the _docker-compose-defaults.yaml_ file, `ROCKETCHAT_PASSWORD` is defined like this:

```
      ROCKETCHAT_PASSWORD: ${HUBOT_ROCKETCHAT_PASSWORD:-bot-pw!}
```

In the newer _docker-compose-env.yaml_ file, we can see that it is defined like this:

```
      ROCKETCHAT_PASSWORD:
        ${HUBOT_ROCKETCHAT_PASSWORD:?HUBOT_ROCKETCHAT_PASSWORD must be set!}
```

Instead of containing a default value, this approach defines an error string if the variable is not set to a nonempty string in the environment. If we try to simply spin up these services now, we will get an error message:

```
$ docker compose -f docker-compose-env.yaml up -d

invalid interpolation format for
  services.hubot.environment.ROCKETCHAT_PASSWORD.
You may need to escape any $ with another $.
required variable HUBOT_ROCKETCHAT_PASSWORD is missing a value:
  HUBOT_ROCKETCHAT_PASSWORD must be set!
```

The output gives us a few hints about what might be wrong, but the last two lines are pretty clear, and the final message is the exact error message that we defined, so it can be set to whatever makes the most sense in the situation.

If we go ahead and pass in our own password, then everything spins up just fine:

```
$ HUBOT_ROCKETCHAT_PASSWORD="a-b3tt3r-pw" docker compose \
    -f docker-compose-env.yaml up -d

[+] Running 5/5
 ⠿ Network compose_botnet          Created                      0.0s
 ⠿ Container compose-mongo-1       Healthy                     31.0s
 ⠿ Container compose-rocketchat-1  Started                     31.3s
 ⠿ Container compose-zmachine-1    Started                     31.5s
 ⠿ Container compose-hubot-1       Started                     31.8s

$ docker compose -f docker-compose-env.yaml down
…
```

### The dotenv File

Passing in a single environment variable is not that difficult, but if you need to pass in a lot of custom values, or even one real secret, then setting them in the local terminal isn’t ideal. This is where the _.env_ (_dotenv_) file can be very useful.

The _.env_ file is a [special file standard](https://www.dotenv.org/docs/security/env) that is intended to be parsed by programs that need additional configuration information that is specific to the local environment.

In the preceding use case, we must set a password to spin up our Docker Compose environment. We can pass in the environment every time, but this isn’t ideal for at least a few reasons. It would be nice if we could set it in a way that is reasonably secure for a single-user environment and that will also make our lives a bit easier and less error prone.

In essence, a _.env_ file is simply a list of key/value pairs. Since this file is intended to be unique to the local environment and will often contain at least one secret, we should start by ensuring that we will never accidentally commit these files into our revision control system. To do this with `git`, we can simply make sure that our _.gitignore_ file includes _.env_, which, in this case, it already does:

```
$ grep .env ../.gitignore
.env
```

Assuming that we are on a single-user system, we can now safely create a _.env_ file in the same directory that contains our _docker-compose.yaml_ file(s).

For this example, let’s go ahead and make the contents of our _.env_ file look like this:

```
HUBOT_ROCKETCHAT_PASSWORD=th2l@stPW!
```

We could add many more key/value pairs to this file, but to keep things simple, we are only focusing on this one password. If you run `git status` after creating this file, you should notice that `git` is completely ignoring the new file, which is exactly what we want:

```
$ git status
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
```

**NOTE**

A _.env_ file is not a Unix shell script. There are subtle but important differences between this format and how you might define variables in a standard shell script. The most important one is that, in most circumstances, you should not surround values with quotation marks.

In the previous section, when we ran `docker compose -f docker-compose-env.yaml up -d` without setting the `HUBOT_ROCKETCHAT_PASSWORD`, we got an error, but if we try this again after creating the _.env_ file, things should work just fine:

```
$ docker compose -f docker-compose-env.yaml up -d

[+] Running 5/5
 ⠿ Network compose_botnet          Created                      0.0s
 ⠿ Container compose-mongo-1       Healthy                     31.1s
 ⠿ Container compose-rocketchat-1  Started                     31.3s
 ⠿ Container compose-zmachine-1    Started                     31.5s
 ⠿ Container compose-hubot-1       Started                     31.8s
```

Let’s confirm that the value that has been assigned to `ROCKETCHAT_PASSWORD` is what we set it to in the _.env_ file:

```
$ docker compose \
    -f docker-compose-env.yaml config | \
    grep ROCKETCHAT_PASSWORD

      ROCKETCHAT_PASSWORD: th2l@stPW!
```

We can see that the value is indeed set to what we defined in the _.env_ file. This is because Docker Compose will always read in the key/value pairs that are defined in a _.env_ file that lives in the same directory as the _docker-compose.yaml_ file that we are using.

It is important to understand the precedence that is in effect here. The very first thing that Docker Compose does is read all the defaults that are set in the _docker-compose.yaml_ file. It then reads the _.env_ file and overrides any of the defaults, which are values defined in the file. Then it finally looks at any environment variables that are set in the local environment and overwrites values previously defined with these.

This means that the defaults in the file should be the most common settings, then each user can define their common changes in the local _.env_ file, and finally, they can rely on local environment variables when they need to make an unusual change for a specific use case. Using these features with Docker Compose helps ensure that you can build a very repeatable process that still contains enough flexibility to cover most common workflows.

**TIP**

There are additional features of Docker Compose that we do not cover, like [override files](https://docs.docker.com/compose/extends). As you start to use Docker Compose more, it is worth your time to review the [documentation](https://docs.docker.com/compose) so that you are aware of any additional features that might be useful for your projects.

## Wrap-Up

You should now have a very good feel for the types of things you can accomplish with Docker Compose and how you can use this tool to decrease the toil and increase the repeatability of your development environments.

In the next chapter, we will explore some of the tools that are available to help you scale Docker inside your data center and in the cloud.

[1](https://learning.oreilly.com/library/view/docker-up/9781098131814/ch08.html#idm46803138496976-marker) Full URL: [_https://ifarchive.org/indexes/if-archiveXgamesXzcode.html_](https://ifarchive.org/indexes/if-archiveXgamesXzcode.html)
